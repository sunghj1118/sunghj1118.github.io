{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L1190ReverseSubstringsParenthesis/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"1190. Reverse Substrings Between Each Pair of Parentheses","date":"July 11, 2024"},"html":"<h1>문제 설명</h1>\n<p>괄호 안의 문장들을 순서대로 뒤집는 문제이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAABuUlEQVR42p2U646CQAyFeRWvKN4FQcRbjLLGqKsS4/s/SdevSQlZL2v2x0kLnTnT03bGSdNUbrebXK9XxW63k8vlIsfjUbIsk9PppDgcDrLf7xX4YRhKtVqVer2uGAwG4vVa4qTp133zt2R3Eha2Wi1pNBrSbDbVN+t5nsJiruvmZEC/3bo4oe/JJGpLFI1lMplIkiSy2WxkPB7LdDqVbrcr5XJZszFUKhWp1WoPpMAJAl+mSawEcRznRBDjR1GklsPwAX673daDHghDXZDoIgiNFAvpfD6X5XKph2Bns1l+IGsoA9nmhJYRCxeLRb7B/lkdAZuLPrHfsh1jt0XFTYD4OzxINml0j5pYwV9t+AvOaDQSZrHX6+ksgWfd+5gwCAIl9H1fyZD5XzIlpLt0ktohGemAoEl+Vbdn/1Ty+XzWUaGWzFm/39dMjdwaZN+v/ikhm7fbrazXa0E+tTQQ63Q6elvwsUVQIosxQmSazyGTXyqVtMvF6/VM8rsRUslkByGn0RwsmX1KVITDM8QztVqt9GYwlyYDUpOM5VCkmW9JALtRDh/IBsPhUGeweLWwRlR8xoogbk/bD1reCzTyPd4XAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1190\"\n        title=\"\"\n        src=\"/static/732e19a6febce365c428e42a9df4274d/5a190/1190.png\"\n        srcset=\"/static/732e19a6febce365c428e42a9df4274d/772e8/1190.png 200w,\n/static/732e19a6febce365c428e42a9df4274d/e17e5/1190.png 400w,\n/static/732e19a6febce365c428e42a9df4274d/5a190/1190.png 800w,\n/static/732e19a6febce365c428e42a9df4274d/c1b63/1190.png 1200w,\n/static/732e19a6febce365c428e42a9df4274d/874d1/1190.png 1310w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>1차 시도</h2>\n<p>1차 시도로는 뭔가 하나씩 단어의 깊이를 찾아서 배열에 저장을 하려 했으나, 바로 처리하는게 더 효율적이다.</p>\n<pre><code class=\"language-python\">class Solution:\n    def reverseParentheses(self, s: str) -> str:\n        depth = 0\n        # list of words with their () depth\n        words = []\n        for c in s:\n            if c == '(':\n                depth += 1\n                # continue to read string\n            elif c == ')':\n                depth -= 1\n                # break reading string and push it into a new list\n                # appending the string itself and the depth\n        \n\n        for word, d in words:\n            # only reverse the word if the depth (d%2)==0    \n</code></pre>\n<h2>풀이 및 해설</h2>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">class Solution:\n\tdef reverseParentheses(self, s: str) -> str:\n\t\tstack = ['']\n\t\tfor char in s:\n\t\t\tif char == '(':\n\t\t\t\tstack.append('')\n\t\t\telif char == ')':\n\t\t\t\tword = stack.pop()[::-1]\n\t\t\t\tstack[-1] += word\n\t\t\telse:\n\t\t\t\tstack[-1] += char\n\n\t\treturn stack[0]\n</code></pre>\n<ul>\n<li>stack을 이용해서 괄호 안의 문자열을 뒤집는다.</li>\n<li>괄호가 열리면 새로운 문자열을 추가하고, 닫히면 뒤집어서 추가한다.</li>\n<li>괄호 기호가 아니라면 현재 문자열에 추가한다.</li>\n<li>마지막에 stack의 첫번째 문자열을 반환한다.</li>\n</ul>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACH0lEQVR42nWTS2/TQBSF8xtoF0kTIhJ7Ho7j2GN7/HYalEJaF7UVj1aoEossSsQGVkgsEGLHkgWCHeKfHmYmoaRELD7fGXvmnJl7r1tChpCPCkwyAdd1DaPR6DZSSncoihKL42PURYXwQ4Ojn0vUP65B0zFaYRiiLAqEQiAIAoPneSb6vg/OuWFb8NbQGYEnYzh1AKf0QR2GlmVZyLIUTdOgLAvEcYQ0TVWMDXosxPr02kSLEUIMxmBogwzWMDVv6Q+Lxyc4bc4wmx3hyfkzvLi8RFVVRizPc0RRZAS1wZ9UiM2NmMtAGb2lpV1knCOTNaRUOUkPEcUJdCo0WkxfXa9jjCvYDtvpMIKcMxBqg5INO4VQG6m9RuWTUWtLkN8RNoKO4/zXXcOJBdtLDNy6j2FwqN5TENuGroEx2Rbk/B8xSsDIUI2J2egM2niQnqOzeA/iRmg3nzB0BOJQoK4rVZCuEb0juM4RXTs5HuxJYU7WOfmI7vwt9p9/w97Vd+w//Yp717+wd/YF1sVnBKdv0JcXZi1Ve1v6wfWpRr5yDzF0Jexojv50icE4R2+2Qv/hCp3pCr16qcavcVDfoFe9wsH8HdrJS3SnN+b6zAhuihJFMUJFIELEqrKxmJi2kMEYUigCF1nsIwk9pJGHSM0T9V5HzcQP/l5ZK6dJYvpMt0qWZUiS1IzzvDAkqierqkap0L+enusYS6naTarWmhjB30bSdqWV6AS+AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/0b2a7a4ad758105f7285d5a1e83aa884/5a190/tc.png\"\n        srcset=\"/static/0b2a7a4ad758105f7285d5a1e83aa884/772e8/tc.png 200w,\n/static/0b2a7a4ad758105f7285d5a1e83aa884/e17e5/tc.png 400w,\n/static/0b2a7a4ad758105f7285d5a1e83aa884/5a190/tc.png 800w,\n/static/0b2a7a4ad758105f7285d5a1e83aa884/c1b63/tc.png 1200w,\n/static/0b2a7a4ad758105f7285d5a1e83aa884/71e8d/tc.png 1304w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>문자열의 길이만큼 loop를 돌기 때문에 O(n)이다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>stack을 사용하므로 O(n)이다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n1 &#x3C;= s.length &#x3C;= 2000\ns only contains lower case English characters and parentheses.\nIt is guaranteed that all parentheses are balanced.\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/\">Leet</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L1190ReverseSubstringsParenthesis/"}},"staticQueryHashes":[],"slicesMap":{}}