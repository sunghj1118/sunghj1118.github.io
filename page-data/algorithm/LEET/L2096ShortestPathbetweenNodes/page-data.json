{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L2096ShortestPathbetweenNodes/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"2096. Step-By-Step Directions From a Binary Tree Node to Another","date":"July 16, 2024"},"html":"<h1>문제 설명</h1>\n<p>이진 트리에서 두개의 노드 간의 가장 짧은 경로를 찾는 문제다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 101.49999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAACnElEQVR42p1US29SURC+v6I7Qnm0FG54Xcq7PFoeBWx4FXb8Fklcs1NXbJq4Y+3CxIVpd1r9DzUsaqmpVmIMLfp5vklOgylo7E2+zMw5M9+ZmTPnGtVqFb1eD91uF51OB7VaDa1WC/V6HY1GQ1CpVMSmb7vdFpt+3Gs2m/B6vbAsC2bQhJHL5/Ho4EAcU6kUNjc34fP5xIlyUV+UGrQ9Hg+2trZEGrGID+m4iVgsrgiTSCaTKBQKyo7JAX6/H+vr63A6nXA4HALqGov2xsYGjLQKKpWKKBaL2N3dxd7eniqtJiWROK8qKJVKskeboK3XKBlDPx5uZDJZlPf3US6Xsa8k+6N1gsTsHYOi0Si2t7cFkUgEoVDobo0VsXwjkUggl8sJCcEMstksMpmMrFMnWSqdlqB4PI600nd2dgTcp+QaiQ1dCokJ9o2nMlA7c43OlhURUu5rXxJRp5+UzLQZHAwG74FlMdg0Tbjdbmk6pYbL5frDlkshayqVlgazRELr7OeBGinaeiw0OF7LYPB0pszUWQLHRuu8efaS2epsdJaUSwk1ge4VJUm4Tsn+MkN9GHtJPRAILiU1WArBTBfBV8B1/Rq0n8aqsuVS+A5tNhvW1tbuwMmnA7NYhpU97Pf7GI1GePb8KQaDAY6OjjAcDmVk+Kz+dgFLCY+PT8Dv6vs5pj++4vrmAj/nkL8Is2Z5/0V4cvIG19MrTC4nmM9vcfbxDLPZTH5hDyIcvXqJb7+mwA0w/XyByXSM29lcZdh4GGHryRBvx5cYvz7Fu8cvcP7lEz6cvpcZtNvt0sPFi/jXxRhWOKTmLI9QOCx/Dw5xIBAQaD2s9qhznPRU8IVxnO4RxtQ77hweyjPjIDOYAZR8yyRksAZtzuaqJ/gbWv+t3pNDpVAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2096\"\n        title=\"\"\n        src=\"/static/3483634d1c41a21a8efe9b3e2946c6f9/5a190/2096.png\"\n        srcset=\"/static/3483634d1c41a21a8efe9b3e2946c6f9/772e8/2096.png 200w,\n/static/3483634d1c41a21a8efe9b3e2946c6f9/e17e5/2096.png 400w,\n/static/3483634d1c41a21a8efe9b3e2946c6f9/5a190/2096.png 800w,\n/static/3483634d1c41a21a8efe9b3e2946c6f9/c1b63/2096.png 1200w,\n/static/3483634d1c41a21a8efe9b3e2946c6f9/252a4/2096.png 1314w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<p>두 노드 간의 가장 짧은 경로를 찾기 위해 다음과 같은 방법을 사용한다.</p>\n<ol>\n<li>먼저 두 노드 간의 경로를 찾는다.</li>\n<li>그 다음, 두 노드 간의 가장 가까운 공통 조상을 찾는다.</li>\n<li>마지막으로, 경로를 구성한다.</li>\n</ol>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\n        def find_path(node, value, path):\n            if not node:\n                return False\n            if node.val == value:\n                return True\n            \n            if find_path(node.left, value, path):\n                path.append('L')\n                return True\n            if find_path(node.right, value, path):\n                path.append('R')\n                return True\n            \n            return False\n        \n        # 1. find paths from root to both the start and the end node\n\n        start_path = []\n        end_path = []\n\n        find_path(root, startValue, start_path)\n        find_path(root, destValue, end_path)\n\n        start_path.reverse()\n        end_path.reverse()\n\n        # 2. find lowest common ancestor between start and end node\n        i = 0\n        while i &#x3C; len(start_path) and i &#x3C; len(end_path) and start_path[i] == end_path[i]:\n            i += 1\n        \n        # 3. construct path\n        result = 'U' * (len(start_path) - i) + ''.join(end_path[i:])\n\n        return result\n</code></pre>\n<ul>\n<li>\n<p>먼저, 두 노드들과 루트 노드 간의 경로를 찾기 위해 <code>find_path</code> 함수를 사용한다.</p>\n</li>\n<li>\n<p><code>find_path</code> 함수는 노드와 루트 노드의 경로를 찾는다.</p>\n<ul>\n<li>만약 노드가 없다면, <code>False</code>를 반환한다.</li>\n<li>만약 노드의 값이 목표 값과 같다면, <code>True</code>를 반환한다.</li>\n<li>만약 왼쪽 자식 노드에서 목표 값을 찾았다면, <code>L</code>을 추가하고 <code>True</code>를 반환한다.</li>\n<li>만약 오른쪽 자식 노드에서 목표 값을 찾았다면, <code>R</code>을 추가하고 <code>True</code>를 반환한다.</li>\n<li>그렇지 않다면, <code>False</code>를 반환한다.</li>\n</ul>\n</li>\n<li>\n<p>루트로부터 찾았기 때문에 순서를 반대로 바꿔준다.</p>\n</li>\n<li>\n<p>두 노드 간의 가장 가까운 공통 조상을 찾기 위해 두 경로를 비교한다.</p>\n</li>\n<li>\n<p>공통 조상을 찾았다면, 공통 조상부터 목표 노드까지의 경로를 구성한다.</p>\n</li>\n<li>\n<p>마지막으로, 경로를 반환한다.</p>\n</li>\n</ul>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB40lEQVR42o1T247TMBDth6yo2iS2kzZ1fG1ubcVy2e0WrRaBYFkeeQWJD+Az4JVfPYydtAhWFTyMjsczPnP1RHsD/7KDrDWWiwUWfwlj7JF0XYer62tsmh7m2wEvfn5C/+MBzC0wMcagbVsopVBVClJWJBKykhGFEFGOZJxzFEURgxV5AbEukW8V8l6C5RyTJEmIsMHNYU9YwxgF7z2stQjBwjkECwRVVUWyLMt+Z5zQeZ4NSPokGPc3r3B3+xbb7SUOt2/w4f4Bu/1TuLVH0zSROBAeiQNpyL5SFfhizJ4PASacDtbWqN0G1vXQ6y3pjkg0tNaRLDwOpf5LIuHQF0ZlpGBZQkLIskeDOD74g4SdIczzHCKniebLSP4/2ZzPkA45SzETCk+a9xDplIxicDg5U5BsfiYYO/mNPeTR+erjV1zcf0ciyrEcFksS6Qzpqsa0eTcEGlvEqS1BZ/EuG4iPGQrKUG7vcHH5BfP6NZKyBpM10qUDXznM9DNMn3/GvNrRfYO09OBkT1YtmN4hWVqkvIi9jz0U1EOrFZwqYWmqSlua+BrKuIhh2t7IiNaTbiycr8luCD3pDivahNNQwk9o2w5NENo7aw1hDUfLHdF5dP0mLnuwO2fRRj8bf1nwkyPhL6PWccnuBnzIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/ddf7a4cfcb636be3a2691c37f5b55e8e/5a190/tc.png\"\n        srcset=\"/static/ddf7a4cfcb636be3a2691c37f5b55e8e/772e8/tc.png 200w,\n/static/ddf7a4cfcb636be3a2691c37f5b55e8e/e17e5/tc.png 400w,\n/static/ddf7a4cfcb636be3a2691c37f5b55e8e/5a190/tc.png 800w,\n/static/ddf7a4cfcb636be3a2691c37f5b55e8e/c1b63/tc.png 1200w,\n/static/ddf7a4cfcb636be3a2691c37f5b55e8e/71e8d/tc.png 1304w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>O(N) : 노드의 개수만큼 탐색한다. 최악의 경우, 모든 노드를 탐색해야 한다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>O(h) : 재귀 호출을 사용하기 때문에 스택에 최대 높이 h만큼 저장된다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\nThe number of nodes in the tree is n.\n2 &#x3C;= n &#x3C;= 10^5\n1 &#x3C;= Node.val &#x3C;= n\nAll the values in the tree are unique.\n1 &#x3C;= startValue, destValue &#x3C;= n\nstartValue != destValue\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/\">2096. Step-By-Step Directions From a Binary Tree Node to Another</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L2096ShortestPathbetweenNodes/"}},"staticQueryHashes":[],"slicesMap":{}}