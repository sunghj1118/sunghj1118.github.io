{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L650TwoKeysKeyboard/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"650. 2 Keys Keyboard","date":"August 19, 2024"},"html":"<h1>문제 설명</h1>\n<p>복사/붙혀놓기 기능을 이용하여 n개의 'A'를 만드는 문제이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAABOklEQVR42q2TbW+CQBCE+f//zw9KoolNeJMXgQNEwNHn2jO0Ne016SWTXdfL7M7cEux2ofb7vcIw1Ha71Waz0eFw0DRN4txuN/mcy+UiMxgFY5epN7XiOFFR5Doe35Tnhc7ns8Zx1F8OzYOySFVV5QPVg7BQ0zQW67yua7Vta3MioObqNAfzPCtI00yn08mO3HWdhmFQ3/c2B8aYZ+4IqJFzD2uu16vF+4Rl+ZCYW8RxrDRNlSTJt4gCCABNaeB8Xp/ASXVjk9OEOqCR+99JhZApjemelhDthMuyWO3TNH/E6ROQspYFvt5zd+yE+Af7f53A+UTXn3bOdx8tIYuNRxiNTy4C/GIDXj3AS0LMxXiMxfwsy+xvpnZ1iPHaixASXpMJmGQNvhSXe0uOosjLQ+9HQRJ75yvpN8I7KKZD3VKr4vMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"650\"\n        title=\"\"\n        src=\"/static/641670cc08f82c54542ad3e5d13dafb1/5a190/650.png\"\n        srcset=\"/static/641670cc08f82c54542ad3e5d13dafb1/772e8/650.png 200w,\n/static/641670cc08f82c54542ad3e5d13dafb1/e17e5/650.png 400w,\n/static/641670cc08f82c54542ad3e5d13dafb1/5a190/650.png 800w,\n/static/641670cc08f82c54542ad3e5d13dafb1/c1b63/650.png 1200w,\n/static/641670cc08f82c54542ad3e5d13dafb1/874d1/650.png 1310w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<p>해당 문제를 풀 때, 가장 먼저 든 생각이 다음 두개 방식 중 어떤게 더 빠를지 고민했었다.</p>\n<ol>\n<li>한번 복사하고, 여러번 붙혀놓기</li>\n<li>한번 복사하고, 한번 분혜놓기를 여러번</li>\n</ol>\n<p>이 중 어떤게 더 유리하고, 이걸 어떻게 판단하는지가 중요했다. 이에 대해서, DP가 어떻게든 적용될 것이라고 생각했고, 이를 어떻게 적용할지 고민했다.</p>\n<p>오히려, n의 숫자가 주어지면 이걸 낮은 수부터 n까지 계산하기보다, 역으로 n을 작게 만들어가는 방식으로 접근하는게 더 효율적이라고 생각했다. 이를 위해, n을 가장 작은 소수인 2로 나누어가면서, 나누어 떨어지는 수를 찾아가는 방식으로 접근했다.</p>\n<p>이렇게 2로 더 이상 나누어지지 않는다면, 그 다음으로 작은 소수인 3으로 나누어가면서, 나누어 떨어지는 수를 찾아가는 방식으로 접근했다.</p>\n<p>즉, 아무리 큰 수여도 결국에는 소수로 나누어지는 수로 나누어가면서, 최종적으로 1이 되는 수를 찾아가는 방식으로 접근했을때, 가장 적은 수의 연산을 찾을 수 있었다.</p>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">def minSteps(self, n: int) -> int:\n        if n == 1:\n            return 0\n        \n        # we can perform either 1 Copy, Many Pastes\n        # or we can perform 1 Copy, 1 Paste several times\n        # which one is better? how can we check? dp?\n\n        steps = 0\n        d = 2 # smallest prime factor\n        while n > 1:\n            while n%d==0:\n                steps += d\n                n = n // d\n            d+=1\n        \n        return steps\n</code></pre>\n<ul>\n<li>n이 1이면, 0을 반환한다.</li>\n<li>steps를 0으로 초기화하고, d를 2로 초기화한다.</li>\n<li>n이 1이 될때까지, n을 d로 나누어가면서, 나누어 떨어지는 수를 찾아가는 방식으로 접근한다.</li>\n<li>d를 1씩 증가시키면서, n이 1이 될때까지 반복한다.</li>\n<li>최종적으로, steps를 반환한다.</li>\n</ul>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABcElEQVR42o2S207DMAyG9/Tc8BRc8C6TEAjEBEhIoG3tKrZ269IkTXP6idPD2oIQrqw/cdIvduIFgjVWY8MynGoG7zystXDORfXeY2zWOhwOOc55ieXXClerG1y/3CKVh7i+aDdZFOURFa9Q13V0pRSklDDGTKA0pjWjDTKRY3lY4S5/ATfyAiQrigJJkoCxM85liZKVkLWMUAI0TQPOecycoL3ObQBuNynSJMMu2+P17R0fyScYZ+AVjxlrrVFVVayGxgRXWsHTNwJHIAVVrSEqHSAGQoU77H4kp7L/a4v+XpyzSE8NjGtPmxdDe/7yCbBlWDynFlz5Nuduo5soRj4GYg6kiMPj1kLq0DbhBG19F+/znTt+0aHkiMXD1uBp57Fce9wnHpuTx557FMHXR4ej9Dh1XnDXqnBQ5gIdXpnagF5TqiaoGlyShpiQKrRP083VSOvJo02AjLHQdwIitAS1iBDih/JhzoLyqNQJPfAbhCFbAAce8MoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/e52133990e673ac3abb646e5f9686050/5a190/tc.png\"\n        srcset=\"/static/e52133990e673ac3abb646e5f9686050/772e8/tc.png 200w,\n/static/e52133990e673ac3abb646e5f9686050/e17e5/tc.png 400w,\n/static/e52133990e673ac3abb646e5f9686050/5a190/tc.png 800w,\n/static/e52133990e673ac3abb646e5f9686050/c1b63/tc.png 1200w,\n/static/e52133990e673ac3abb646e5f9686050/3c492/tc.png 1300w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>O(n) ; n이 1이 될때까지, n을 나누어가는 방식으로 접근한다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>O(1) ; 추가적인 공간이 필요하지 않다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n1 &#x3C;= n &#x3C;= 1000\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/2-keys-keyboard/\">650. 2 Keys Keyboard - LeetCode</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L650TwoKeysKeyboard/"}},"staticQueryHashes":[],"slicesMap":{}}