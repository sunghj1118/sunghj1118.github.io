{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L21MergeTwoSortedLists/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"21. Merge Two Sorted Lists","date":"June 25, 2024"},"html":"<h1>문제 설명</h1>\n<p>두개의 배열이 주어지면 두개를 합치면 된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAAC/UlEQVR42q1VzWsTURBf8E8Q/wAFT17Em+BZ8CaCB/GgBw8iPQlFUCjSQ0WwFUSsohXRYmupCO3BChEVwUIttJSkadOQZvOdzccmu5vsbvbj58xLXqyC/QAHHvN23pvfmzczv7dKPpdDIpFANBpFMpkUIxaLIR6PC5uu62AJwxD7EaVuWdCqVajpNCqVCrLZLHJ0iEX2drsNz/NwEFFMcmo0DTSbTRENgxqGAdu2BSBr1+0I7TjunpEqzUYDmqah3gOr1+uoUsSlUknYec62Wq0mtIyctTxUDj5MKRaLKJfLwtBqtYTmaE3TFA7syHOpeU3ehm1yL88FoDydN/Aif0ub4zg4qCiMGgQBfN8Xw+t00GlZQrM9INCACsOpC1xXDPaRufw7p+LKPBjsf4jCbcEjpGhYzOga0oMDaBdycCgFmaFB1CIL4DiKL8ZRePIQu9VZkZOwF2F5dgprhw+hsbIMI6MievwIMiND4NXNC2eROHcGnb5T+G/A/h6K1DMa/W/PaiL0uhC+3Ybftna/8m+krmpZNjY2VFEUjmBrKwO91hRr+ZyGjFrau8qy0iw/vizj+vnbSMa3UcgWcfPyMD68WRBrD+48w/1b4/AD/48K76y0AOTouOccx4ZWquB7ZBF6XReNvfjtJ1LJNIIwQHQ1jpWlNbFPcrzfQj1MhZ1sm3qNjC3mdbXSzR0VSSfqeb38NfQGpaPVTQsxyqhV+4CmYfZvqDwfncLTe6/AnFCpJbZOHUNdVaGtR7F58iiK05MgUuHx8Eu8fjQDl/alR0ewefoEWlUN67Ek7g6MYXUp1gWcn45g/u0n0Qr5ufdIX7sEgx+F7RSSVy9C+xpBm647MzGHj7Ofxb7su0mkblyBTd2gpvOYGJtCKqH2ni/LRFkrwWCS0/VNqq5FV3dIu0EIl/RBOK2US2XxoNrk5DOPCTSQNPQp8ZQbzrfgdS9PoU+ai7KjQ2SlFX5VmMtcHK4cc9qlB4CHBDgQl/l1LhQK4j2TgH1+7/M/shPwF8UuOPHVaGsEAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"21\"\n        title=\"\"\n        src=\"/static/d93ff10aa6d8b0921d84c1d6bc25209c/5a190/21.png\"\n        srcset=\"/static/d93ff10aa6d8b0921d84c1d6bc25209c/772e8/21.png 200w,\n/static/d93ff10aa6d8b0921d84c1d6bc25209c/e17e5/21.png 400w,\n/static/d93ff10aa6d8b0921d84c1d6bc25209c/5a190/21.png 800w,\n/static/d93ff10aa6d8b0921d84c1d6bc25209c/c1b63/21.png 1200w,\n/static/d93ff10aa6d8b0921d84c1d6bc25209c/248b0/21.png 1316w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이렇게만 보면 진짜 간단해 보인다. 그냥 두개를 합치고 정렬하면 되지 않나? 제약사항을 유심히 살펴봐야 할 것 같다.</p>\n<h2>풀이 및 해설</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABMklEQVR42pVS2W7DMAzL//9h13Zdr7TIHceK73CSu/Vh2QpMACGbgSWKSuF8QIgRMSYsC1YQnpxBpWvU1IC8wcz4LRZ+UBhrYa37gl3BeebdgrrvUbYlBtJQpKC0wqinnI0xcM5Ba43Cew8fArxfIzBvHX9nld3QoayumIwGWY3ZEYy3iCkipZTVSS6apoVS3FFNIJpzfpwp8yTd2ZLgIm63Gpfyxk1sHjEtaTV2sdm84XD4wH7/jtPpjOu15Id3SKPz+QI16awwhYimanCv2uz5X1FstzvsdvsnpPjxeHoWVuxLSAtmHrXuKmhDeBXFOI4YhhETK2nbDn0/QDiBGG14WaKQFOHM487GvC7o2HQxU36PxEoe+XGPPFpejnA+QU+Uzy8LirLvrUpxwc9N/yc+AZEUvKE4O43XAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"test\"\n        title=\"\"\n        src=\"/static/0bd7f9cf6192d74432adfbdde8d28ab4/5a190/test.png\"\n        srcset=\"/static/0bd7f9cf6192d74432adfbdde8d28ab4/772e8/test.png 200w,\n/static/0bd7f9cf6192d74432adfbdde8d28ab4/e17e5/test.png 400w,\n/static/0bd7f9cf6192d74432adfbdde8d28ab4/5a190/test.png 800w,\n/static/0bd7f9cf6192d74432adfbdde8d28ab4/c1b63/test.png 1200w,\n/static/0bd7f9cf6192d74432adfbdde8d28ab4/29007/test.png 1600w,\n/static/0bd7f9cf6192d74432adfbdde8d28ab4/3c1e5/test.png 2854w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>생긴것보다는 어려웠다. 보니까 가장 첫 노드를 잃지 않는게 핵심이었고, 배열을 합치고 정렬하고 끝낼 수가 없는게, 두개의 배열이 노드로 구성되어 있어서 안됐다.</p>\n<p>그래도 다음과 같이 하니까 머리의 위치를 기록하면 해결이 됐다.</p>\n<pre><code class=\"language-python\"># Create a head and another variable to track the current node\nhead = ListNode(0)\nlist3 = head\n</code></pre>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        # Create a head and another variable to track the current node\n        head = ListNode(0)\n        list3 = head\n\n        # Append to new list for all nodes in list 1 and 2\n        while list1 and list2:\n            if list1.val &#x3C;= list2.val:\n                list3.next = list1\n                list1 = list1.next\n            else:\n                list3.next = list2\n                list2 = list2.next\n            list3 = list3.next\n            print(head)\n            \n        # Append any remaining\n        if list1:\n            list3.next = list1\n        elif list2:\n            list3.next = list2\n\n        return head.next\n</code></pre>\n<ul>\n<li>먼저, head와 list3를 생성한다.</li>\n<li>list1과 list2의 노드들을 모두 새로운 리스트에 추가한다.</li>\n<li>list1과 list2의 노드들을 비교해서 작은 값을 list3에 추가한다.</li>\n<li>list3를 다음 노드로 이동한다.</li>\n<li>list1과 list2 중 남은 노드들을 추가한다.</li>\n<li>head의 다음 노드를 반환한다.</li>\n</ul>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB3klEQVR42o1TXWsUMRTdXy0I6pMPguijH/jso1hQtCBo+2QfCoLgUlrWtdtthXEnk2Qmk8/J8d7srrtdK5jhMJmbzLn3npyMTLCY1nNUukYIocB7X8Dzm0bTSFzMLyGFwvOzPdz+8hT3vr7ApL3EaBgGtLpF13Ww1hYwGb+dc+D1nPM1Qo7FlJCHDBU6VLbBLycRh4QRb1gsFpjNzqGUhO0N2rYthH3fl0RMzEl4HmMspJxkNxGPQjidnuNi9hNXVxXGJxOcnp4RuYIxG3Jun2NMyGByxpCpg9VTCDmL1haqtmikRdU4qozbXbbM2NVyWFW3JrlWIS+wJv8z8grr4QNrmf8mzFs787/IVgudBw6+k0wCeHlMurqNpn8IE5/Y+o8tsTeiL99TkXE8Bx4dZjw5Au6+j3g7jjBhuYe3j7ZPKt/QFnfEVR3NgPv7wIMPwOND4OFH4M6biFuvEp59BpFuVZhJw94nKJvR9AMkQdNc9QnCENmPiL1voGoSDiaZMOATYf8k4d044DWtVd3OoRjTkz0cDHnP0CkzOo45D2cNyUI3xxtEulnedQiO5vTNsZQcWSlsfMiE7DFHfmu1Lv5jj7EH2dyNlCWBEAKaYkI05fpJpVHXoiR2ZHwm/A16Lp12kWeaxAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"success\"\n        title=\"\"\n        src=\"/static/aef4a75d6a725e06c1fc25a329475b4b/5a190/success.png\"\n        srcset=\"/static/aef4a75d6a725e06c1fc25a329475b4b/772e8/success.png 200w,\n/static/aef4a75d6a725e06c1fc25a329475b4b/e17e5/success.png 400w,\n/static/aef4a75d6a725e06c1fc25a329475b4b/5a190/success.png 800w,\n/static/aef4a75d6a725e06c1fc25a329475b4b/c1b63/success.png 1200w,\n/static/aef4a75d6a725e06c1fc25a329475b4b/d4377/success.png 1294w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<p>두 리스트를 한 번씩 순회하므로 O(N + M)이다. 여기서 N과 M은 각각 list1과 list2의 노드 수이다.\n각 노드를 정확히 한 번 방문하고, 상수 시간 연산만 수행하므로, 전체 시간 복잡도는 O(N + M)이다.</p>\n<h3>공간 복잡도</h3>\n<p>O(1); 새로운 노드를 생성하지 않고 기존 노드들을 재배열하므로 추가 공간이 필요하지 않다.\n단, 함수 호출 스택을 고려하면 O(1)의 추가 공간만 사용된다.</p>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\nThe number of nodes in both lists is in the range [0, 50].\n-100 &#x3C;= Node.val &#x3C;= 100\nBoth list1 and list2 are sorted in non-decreasing order.\n</code></pre>\n<p>노드의 수가 최대 50개로 매우 작기 때문에 O(N + M) 복잡도의 알고리즘은 충분히 빠르게 실행될 수 있다.\n현재 프로그램이 비효율적인 이유는 불필요한 ListNode 객체 생성과 list3 변수의 재할당 때문이다. 더미 노드를 사용하여 헤드를 유지하고, 포인터를 이동시키며 기존 노드들을 연결하는 방식으로 개선할 수 있다. 또한, 두 리스트가 이미 정렬되어 있다는 점을 활용하여 단순히 값을 비교하며 병합하는 것이 가능하다. 이러한 최적화를 통해 작은 크기의 입력에서도 효율적으로 동작할 수 있다.</p>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\">LeetCode</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L21MergeTwoSortedLists/"}},"staticQueryHashes":[],"slicesMap":{}}