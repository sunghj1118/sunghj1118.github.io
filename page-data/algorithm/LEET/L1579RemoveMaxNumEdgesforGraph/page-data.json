{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L1579RemoveMaxNumEdgesforGraph/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","date":"June 30, 2024"},"html":"<h1>문제 설명</h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABk0lEQVR42pVSDYuCUBD0//+toCsoIvsgCEpNy8qvytTSmnO29pCrO0gYdt97u7Ozuxqe52E0Ggmm0ynm8zlM08RkMkGv10O/38dsNpO7breL8XgsGA6HktPpdECOPMuRZAcYZn35VV8OBgO02220Wi0JKooCp9NJkKYpzucz9vs9DoeDnJMkkbcoiiT2druhrEoY2fGIJAoRhqEEMSkIAlyvV+R5jsvlgk8+o2Cluoq/3QrpbrfDarXCtj7TJzlJsyyTAgQV8cyiL4RsIQgfCimfKumTiND2+BbHsVjJeb69ELISAzWJgUrI88ct67AV2qpaElZVJUO/3++Cpv8bBudBdWxD29XWdFG07+b1ViGVuK4n/5LruthsNk/4tcKH4vV6XReI4ftbWJYF27ZlcU3Le47J8H0fy6VVYykgqW07QsJAx3Ge1v4hWywW4hOMp2UuuQyyUh0PVNZUSp8KVSVjFNoJ8zk2zrosy0fLTGQCLWfH5XBufNNZNueZpmchYhzJNYcLlv+QF4rmxv7b5l9b/gYOTdlzwraCiQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1579\"\n        title=\"\"\n        src=\"/static/73ba80c90ce6ded280dff3a75fb4911d/5a190/1579v1.png\"\n        srcset=\"/static/73ba80c90ce6ded280dff3a75fb4911d/772e8/1579v1.png 200w,\n/static/73ba80c90ce6ded280dff3a75fb4911d/e17e5/1579v1.png 400w,\n/static/73ba80c90ce6ded280dff3a75fb4911d/5a190/1579v1.png 800w,\n/static/73ba80c90ce6ded280dff3a75fb4911d/c1b63/1579v1.png 1200w,\n/static/73ba80c90ce6ded280dff3a75fb4911d/6c2de/1579v1.png 1334w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>문제</h2>\n<p>이 문제는 Union-Find 알고리즘을 사용하여 그래프를 완전히 탐색할 수 있도록 최대한 많은 간선을 제거하는 문제다.\n<img src=\"image.png\" alt=\"1579v2\"></p>\n<h2>문제 소개: Union-Find</h2>\n<p>UnionFind (Disjoint Set)를 사용해야 해서 조금 생소한 문제다. Union Find는 그래프에서 연결되어 있는 노드들을 찾는 자료구조의 일종이다.</p>\n<p>해당 클래스에서 <code>union</code> 함수는 두개의 노드 x와 y를 연결하려고 시도한다. <code>self.find(x)</code>와 <code>self.find(y)</code>는 각각 x와 y의 루트 노드를 찾는다. 만약 두 노드의 루트 노드가 같다면, 이미 연결되어 있는 노드이므로 <code>False</code>를 반환한다. 그렇지 않다면, 두 노드를 연결하고 <code>True</code>를 반환한다.</p>\n<p>이때, if-elif 블록에서는 Union-by-rank라는 Optimization 기법을 사용한다. rank는 트리의 높이를 나타내는데, 두 트리를 합칠 때 높이가 더 낮은 트리를 높이가 더 높은 트리에 붙이는 방식이다. 이렇게 하면 트리의 높이가 줄어들어 find 함수의 시간 복잡도를 줄일 수 있다.</p>\n<p><code>self.parent[px] = py</code> 또는 <code>self.parent[py] = px</code>은 두 트리를 합칠 때, 높이가 더 낮은 트리를 높이가 더 높은 트리에 붙이는 과정이다. <code>self.components -= 1</code>은 연결된 컴포넌트의 개수를 1 감소시킨다.</p>\n<h2>어째서 Union-Find를 사용하는가?</h2>\n<ul>\n<li>UnionFind는 노드들이 연결되어 있는지 여부와 병합을 거의 상수 시간에 수행할 수 있다.</li>\n<li>동적 연결성이 보장되기 때문에, 연결성에 대한 쿼리를 빨리 수행하고 그래프 구조를 효율적으로 업데이트할 수 있다.</li>\n<li>공간 효율적이다. 모든 간선을 저장할 필요가 없다.</li>\n</ul>\n<h1>풀이 및 해설</h1>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.components = n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return False\n        if self.rank[px] &#x3C; self.rank[py]:\n            self.parent[px] = py\n        elif self.rank[px] > self.rank[py]:\n            self.parent[py] = px\n        else:\n            self.parent[py] = px\n            self.rank[px] += 1\n        self.components -= 1\n        return True\n\nclass Solution:\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n        alice = UnionFind(n)\n        bob = UnionFind(n)\n\n        edges_used = 0\n\n        # Process type 3 edges\n        for edge_type, u, v in edges:\n            if edge_type == 3:\n                if alice.union(u-1, v-1):\n                    bob.union(u-1, v-1)\n                    edges_used += 1\n        \n        # Process type 1 edges (alice)\n        for edge_type, u, v in edges:\n            if edge_type == 1:\n                if alice.union(u-1, v-1):\n                    edges_used += 1\n        \n        # Process type 2 edges (bob)\n        for edge_type, u, v in edges:\n            if edge_type == 2:\n                if bob.union(u-1, v-1):\n                    edges_used += 1\n        \n        # Check if the graph is fully traversable\n        if alice.components != 1 or bob.components != 1:\n            return -1\n        \n        return len(edges) - edges_used\n</code></pre>\n<ul>\n<li>\n<p>가장 먼저 UnionFind 클래스를 정의한다.</p>\n</li>\n<li>\n<p>UnionFind 클래스는 다음과 같은 메소드를 가진다.</p>\n<ul>\n<li><code>__init__(self, n)</code>: n개의 노드를 가진 UnionFind 클래스를 초기화한다.</li>\n<li><code>find(self, x)</code>: x의 루트 노드를 찾는다.</li>\n<li><code>union(self, x, y)</code>: x와 y를 합친다.</li>\n</ul>\n</li>\n<li>\n<p><code>maxNumEdgesToRemove</code> 메소드는 다음과 같이 동작한다.</p>\n<ul>\n<li><code>alice</code>와 <code>bob</code> 두 UnionFind 클래스를 초기화한다.</li>\n<li><code>edges_used</code> 변수를 초기화한다.</li>\n<li>type 3 간선을 처리한다.\n<ul>\n<li>type 3 간선은 alice와 bob 모두에게 속하므로, 두 클래스 모두에게 합친다.</li>\n<li><code>edges_used</code>를 1 증가시킨다.</li>\n</ul>\n</li>\n<li>type 1 간선을 처리한다.\n<ul>\n<li>alice에게 속하는 간선이므로, alice에게 합친다.</li>\n<li><code>edges_used</code>를 1 증가시킨다.</li>\n</ul>\n</li>\n<li>type 2 간선을 처리한다.\n<ul>\n<li>bob에게 속하는 간선이므로, bob에게 합친다.</li>\n<li><code>edges_used</code>를 1 증가시킨다.</li>\n</ul>\n</li>\n<li>alice와 bob의 components가 1이 아니라면, 그래프가 완전히 탐색할 수 없는 그래프이므로 -1을 반환한다.</li>\n<li>그렇지 않다면, <code>edges</code>의 길이에서 <code>edges_used</code>를 뺀 값을 반환한다.</li>\n</ul>\n</li>\n</ul>\n<h2>Complexity Analysis</h2>\n<p><img src=\"image-1.png\" alt=\"tc\"></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>O(n): Alice와 Bob에 대한 UnionFind 클래스를 초기화하는 데 O(n)이 걸린다.</li>\n<li>O(m): m개의 간선을 처리하는 데 O(m)이 걸린다.</li>\n<li>모든 간선에 대하여 union 함수를 호출한다.\n<ul>\n<li>이때, find 함수는 O(alpha(n))이 걸리며, alpha(n)은 Ackermann 함수의 역함수이다.</li>\n<li>alpha(n)은 매우 느리게 증가하므로, O(m * alpha(n))은 O(m)이 된다.</li>\n</ul>\n</li>\n<li>Bob과 Alice의 components를 확인하는 데 O(1)이 걸린다. 즉, Traverse하는 데 O(1)이 걸린다.</li>\n</ul>\n<p>따라서, 총 O(n + m)의 시간 복잡도가 소요된다.</p>\n<p>이때 m은 최대 3 * n * (n - 1) / 2이므로, O(n^2)이 된다.<br>\n그렇다면, 총 시간 복잡도는 O(n + n^2)이다.</p>\n<h3>공간 복잡도</h3>\n<ul>\n<li>O(n): Alice와 Bob에 대한 UnionFind 클래스를 초기화하는 데 O(n)이 소요된다.</li>\n<li>O(m): m개의 간선을 처리하는 데 O(m)이 소요된다.</li>\n</ul>\n<p>즉, 총 O(n + m)의 공간 복잡도가 소요된다.</p>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n1 &#x3C;= n &#x3C;= 10^5\n1 &#x3C;= edges.length &#x3C;= min(10^5, 3 * n * (n - 1) / 2)\nedges[i].length == 3\n1 &#x3C;= type_i &#x3C;= 3\n1 &#x3C;= u_i &#x3C; v_i &#x3C;= n\nAll tuples (type_i, u_i, v_i) are distinct.\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/\">LeetCode</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Disjoint-set_data_structure\">Wikipedia - Union-Find</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Ackermann_function\">Ackermann Function</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L1579RemoveMaxNumEdgesforGraph/"}},"staticQueryHashes":[],"slicesMap":{}}