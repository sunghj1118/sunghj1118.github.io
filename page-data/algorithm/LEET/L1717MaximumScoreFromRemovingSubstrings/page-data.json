{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L1717MaximumScoreFromRemovingSubstrings/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"1717. Maximum Score From Removing Substrings","date":"July 12, 2024"},"html":"<h1>문제 설명</h1>\n<p>하나의 문자열 s에서 'ab' 또는 'ba'를 계속해서 없애는 문제다.</p>\n<h2>풀이 및 해설</h2>\n<h3>시도 1</h3>\n<p>Time Limit Exceeded Error으로 실패했다. 아마 시간복잡도가 너무 느려서 그런거라 더 빠른 방법을 사용해야 풀릴 것 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABDElEQVR42n1R2Y6DMAzk/78NqfDIAs9tCeVIaMg9tdOi7Xa1GzSycZyxPS6cUjBiQJpnJGvxeUIIcM5lGLpfpcUiNwQfEFPKCPFp+RSRHlit4Y0B+zkpxh8wdOcskXoP6yKG6YpxHaH0BqkVxbigR6LcQqkNX22LtuvQku3IvqPvezRNg2VZ4F8FZvKHm6DYDZtcoTeNnXgiFSxmGvV0OqGua1RVlf3j/0BZlhBCwIUnoZQSZ3GBmEfqziDxd4xsSRcm5Q4Y7I/j+CtmzA5NY0fSy9wNLucrxCBgP3QvWGwOsvj/IcaAu+G8iF0aTNMERQv1NCZ3dyB3mEV/bfIv5G3TYyZM8XvEdzImfACkFhuX5MJ9ZwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"wrong1\"\n        title=\"\"\n        src=\"/static/9dff75598b5f7d984e85280920b6f18a/5a190/wrong1.png\"\n        srcset=\"/static/9dff75598b5f7d984e85280920b6f18a/772e8/wrong1.png 200w,\n/static/9dff75598b5f7d984e85280920b6f18a/e17e5/wrong1.png 400w,\n/static/9dff75598b5f7d984e85280920b6f18a/5a190/wrong1.png 800w,\n/static/9dff75598b5f7d984e85280920b6f18a/c1b63/wrong1.png 1200w,\n/static/9dff75598b5f7d984e85280920b6f18a/29007/wrong1.png 1600w,\n/static/9dff75598b5f7d984e85280920b6f18a/5b30f/wrong1.png 2372w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<pre><code class=\"language-python\">class Solution:\n    def maximumGain(self, s: str, x: int, y: int) -> int:\n        score = 0\n\n        # Determine which to remove first\n        first, second = ('ab', 'ba') if x > y else ('ba', 'ab')\n        first_points, second_points = max(x,y), min(x,y)\n\n        # Remove higher-value pairs\n        while first in s:\n            s = s.replace(first, '', 1)\n            score += first_points\n\n        while second in s:\n            s = s.replace(second, '', 1)\n            score += second_points\n\n        return score\n</code></pre>\n<ul>\n<li>\n<p>시간복잡도: O(n^2)</p>\n</li>\n<li>\n<p>공간복잡도: O(1)</p>\n</li>\n<li>\n<p>어느 문자열을 먼저 제거할지 결정하기 위해 x, y를 비교하여 더 큰 값을 가지는 문자열을 먼저 제거했다.</p>\n</li>\n<li>\n<p>first가 s에 존재하는 동안 계속하여 제거하고, second가 s에 존재하는 동안 계속하여 제거했다.</p>\n</li>\n</ul>\n<h2>풀이</h2>\n<p>해당 문제를 풀기 위해서는 더 빠른 방법이 필요하기 때문에 스택을 사용했다. 스택을 사용하여 문자열을 순회하면서 'ab' 또는 'ba'를 제거하고, 그에 따른 점수를 계산했다.</p>\n<pre><code class=\"language-python\">class Solution:\n    def maximumGain(self, s: str, x: int, y: int) -> int:\n        def remove_pairs(s, first, second, points):\n            stack = []\n            score = 0\n            for char in s:\n                if stack and stack[-1] == first and char == second:\n                    stack.pop()\n                    score += points\n                else:\n                    stack.append(char)\n            return ''.join(stack), score\n\n        total_score = 0\n        if x >= y:\n            s, score = remove_pairs(s, 'a', 'b', x)\n            total_score += score\n            s, score = remove_pairs(s, 'b', 'a', y)\n        else:\n            s, score = remove_pairs(s, 'b', 'a', y)\n            total_score += score\n            s, score = remove_pairs(s, 'a', 'b', x)\n\n        total_score += score\n        return total_score\n</code></pre>\n<ul>\n<li>remove_pairs 함수를 만든다.\n<ul>\n<li>s에 있는 문자들 char에 대하여 순회한다.</li>\n<li>이때, stack에 있는 마지막 문자가 first이고, char가 second인 경우, stack에서 pop하고 점수를 추가한다.</li>\n<li>이렇게 했을 시, 아무리 가운데 'ab'가 삭제가 되어 후순번의 문자가 앞문자랑 합쳐져도, 항상 'ab'가 존재하는지 확인을 하기 때문에 제대로 된 결과를 얻을 수 있다.</li>\n<li>마지막에 stack을 join하여 문자열로 만들어 반환한다.</li>\n</ul>\n</li>\n<li>x가 y보다 크거나 같은 경우, 'ab'를 먼저 제거하고 'ba'를 제거한다.</li>\n<li>x가 y보다 작은 경우, 'ba'를 먼저 제거하고 'ab'를 제거한다.</li>\n<li>마지막에 total_score를 반환한다.</li>\n</ul>\n<h3>후기</h3>\n<p>해당 문제는 처음 읽었을 때, 뭔가 'ab'를 먼저 지웠다가 'ba'를 그 다음에 지우고, 그 다음에 'ab'를 지울 수 있게 되는 경우에 대해서 어떻게 풀 수 있는지 이해가 안되고 직관적으로 아직도 좀 헷갈린다. 두번만 순회해서 풀린다는게 신기하다.</p>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB10lEQVR42p2TS4/TMBDH+505ckNiPwASR74BR06LeEkgwQEhlRWwu2y7pS0lDXk5fia2/8w4TSivA+to5HFs/+Y/k8nMOYdGCdSyQdd1+N/hQgftLax3YNYsxICNyLBrc/R9n8x7P/l/G2VVYbv9ivx7gfvnD3Hr7T3cef8ApROY8QElJZqmgTEGWusUyVqbLISAGOMvwL73KRsOmOkS13KHjdrDk7gEbNsW680aVVUSzELKNoE5gFIqBWAA+6yeBwf5PRCvEzDLcnw4O0e2L3C13GA+P8PF+jLVVrYygVkNZzGWguGSMovHzwhUyqIuNV2wyCsDITW0IYXWpLRZ4ajgWN0/FXKdaAnXh2Q3HROwP9Tlat9hkXeHTQ4xzDcADqqefHI4/Tikt6ro/SQ2Hux4/edeAg4KApYEuP3I4u6pxclz4ORxxLPPEfNdRKEivtQRjYlUnkiBImwfId1QRx9+1nMC5jLg6YXD62WHF4uAV8s+zS8XHu+2Hm9WHteFJ2hAIT2+iYBV6SG0R6k89eCgdob0uUGtQf2mGzgj0Dn2eZbJnCGzkrpBTu1itCKTaMnn9fjbzsZK8MG6EWiEoEPk1w0kvWN/uKSSccMzQGuTZr533PA/AIQu8RKlbuqhAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"right\"\n        title=\"\"\n        src=\"/static/bd5d06b897595b895e4faf707ac9f2a7/5a190/right.png\"\n        srcset=\"/static/bd5d06b897595b895e4faf707ac9f2a7/772e8/right.png 200w,\n/static/bd5d06b897595b895e4faf707ac9f2a7/e17e5/right.png 400w,\n/static/bd5d06b897595b895e4faf707ac9f2a7/5a190/right.png 800w,\n/static/bd5d06b897595b895e4faf707ac9f2a7/c1b63/right.png 1200w,\n/static/bd5d06b897595b895e4faf707ac9f2a7/c2d9c/right.png 1326w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>시간복잡도: O(n) ; 한번씩만 순회하면 되기 때문에 n에 비례한다.</li>\n<li>string.replace보다 스택을 사용하여 문자열을 순회하는 것이 더 빠르다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>공간복잡도: O(n) ; 스택을 사용하여 문자열을 저장하기 때문에 n에 비례한다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n1 &#x3C;= s.length &#x3C;= 105\n1 &#x3C;= x, y &#x3C;= 104\ns consists of lowercase English letters.\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/maximum-score-from-removing-substrings/\">1717. Maximum Score From Removing Substrings</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L1717MaximumScoreFromRemovingSubstrings/"}},"staticQueryHashes":[],"slicesMap":{}}