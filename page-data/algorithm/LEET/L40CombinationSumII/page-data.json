{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L40CombinationSumII/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"40. Combination Sum II","date":"August 13, 2024"},"html":"<h1>문제 설명</h1>\n<p>중복된 숫자가 있는 배열에서 숫자를 사용하여 target을 만들 수 있는 모든 unique 조합을 찾는 문제이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABHElEQVR42q2U6YqEMBCE8/5P6Mj4zzPGM95X7VSWlmGWBQdsKDoG86XsblTPZ4DH4wHP8+D7PoIgQBiGOI4DDGZZf8b7O7azmLYJarQZjDHI8xxpmiJJEozjiG9j33cHVoXJoLV20DiOHdCYAlVVO9X1r5qmQdu2sNY6yb5oXVcHVlrnL0D+cqiRZZlzSfESui7LCn3fo+s6d4jats3lZVlOyecrHqa7siydiqJwIIETzDWBV0JN0wSKdaNkTVeSuXc1FB3R8l2hoig6a/Tpdp5nDMPgLmQXLwFZI0JYaB4SybPk/2bxD5CjQBe3fTJniC5uA7JWV+tzuSmEvg8ss6y/vUzxR8Aus47sKjsqmXuEXm3I2ZRb55Bu7owf+8Do81MTkZAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"40\"\n        title=\"\"\n        src=\"/static/15832fc190305d2ca5ec2eb99187f7a8/5a190/40.png\"\n        srcset=\"/static/15832fc190305d2ca5ec2eb99187f7a8/772e8/40.png 200w,\n/static/15832fc190305d2ca5ec2eb99187f7a8/e17e5/40.png 400w,\n/static/15832fc190305d2ca5ec2eb99187f7a8/5a190/40.png 800w,\n/static/15832fc190305d2ca5ec2eb99187f7a8/c1b63/40.png 1200w,\n/static/15832fc190305d2ca5ec2eb99187f7a8/203d3/40.png 1322w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>시도 1</h2>\n<p>해당 문제를 풀기 위해서는 일단</p>\n<ol>\n<li>unique combinations을 모두 찾아야 하며,</li>\n<li>해당 조합의 합이 target과 같아야 한다.</li>\n</ol>\n<p>(1)을 구현하기 위해 어떻게 할 수 있을지 고민하다가 찾아보니까 backtracking을 사용하면 된다고 한다. backtracking을 사용하면 중복된 숫자를 사용하지 않고 unique한 조합을 찾을 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 49.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABYElEQVR42nWS6XKEIBCEfY6sB6AiCIhidnNU3v+1Og1bqb3Mj6/KEuiZ7pnqfLkgpR3DOGKazA09YY4J+TwsEVtKcLNDCKEw89s5D2MsfFgQ1o3/Pao1bkgLLxuPcdQ3KDhIAal6Xo74+Eq4fF742EEphbZt0XWCdBBCQkgiBCpnPWKI8O5a9V5UUez6QGFk19pHGDtDsyupJJqmeaCuG1TRRbyvZ6zLWgSz3WwjMww9ej7sB4G0b9iJsRp9L3gmWLB7oQpuwRZo2T5ZzlDQ2AHbbvH9szBPg3XXzFQyP3FIEQwMddT6RTBbzkQGPpkJb6cadbbXdrTXHlIEF2bovC92nwW1NZiDpWD+xwh6Cclh5QHkwTxz7dCH0mVeg0dBBTPP8In5+pn2JxYdC6pXx4LeBuTVsXz42qEqWMfJsphQQ5nk31QPBfPKBL9wauODmOYeSu5WXdeFpj79K3Iv+AsYex/QjQ7zVAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"bt\"\n        title=\"\"\n        src=\"/static/1ad6491da921bccc861cddd9c0646f34/5a190/backtracking.png\"\n        srcset=\"/static/1ad6491da921bccc861cddd9c0646f34/772e8/backtracking.png 200w,\n/static/1ad6491da921bccc861cddd9c0646f34/e17e5/backtracking.png 400w,\n/static/1ad6491da921bccc861cddd9c0646f34/5a190/backtracking.png 800w,\n/static/1ad6491da921bccc861cddd9c0646f34/c1b63/backtracking.png 1200w,\n/static/1ad6491da921bccc861cddd9c0646f34/29007/backtracking.png 1600w,\n/static/1ad6491da921bccc861cddd9c0646f34/5e703/backtracking.png 1942w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위는 backtracking을 사용하여 중복된 숫자를 사용하지 않고 unique한 조합을 찾는 과정을 나타낸다.</p>\n<p>result에 조합을 저장하면서 재귀적으로 끝까지 갔다가, 마지막에 하나씩 pop을 하면서 다시 돌아오는 방식이다.</p>\n<p>이를 응용해서 문제를 풀어봤지만, 시간초과가 발생했다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsUlEQVR42qWRyQ6DMAxE8/+fiaqqalgMJGSFaWyK2mtIpKfYl/HYozr7gvaE4AOcc0gpoeWp7vnAYg1CCNg2h+NAm2CMUYqjKJ2gCfV+a0wTYV1NWdnDl9XvknOGGoYR4zgJ1m7tgsuylvtFgR22IIKcLBecbkpZ6l9fx77vUMaYYtcVvMADriG1cKiKiCSUeZ4FopPrDDXk/HX4P4Wt88/2axGHfT9A6x6cNsM9czflD6NjXuNKS496AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"acc1\"\n        title=\"\"\n        src=\"/static/74c29bcf78985fdacf7650f723d8616b/5a190/acc1.png\"\n        srcset=\"/static/74c29bcf78985fdacf7650f723d8616b/772e8/acc1.png 200w,\n/static/74c29bcf78985fdacf7650f723d8616b/e17e5/acc1.png 400w,\n/static/74c29bcf78985fdacf7650f723d8616b/5a190/acc1.png 800w,\n/static/74c29bcf78985fdacf7650f723d8616b/c1b63/acc1.png 1200w,\n/static/74c29bcf78985fdacf7650f723d8616b/78958/acc1.png 1320w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.500000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAApUlEQVR42oWQ6w6DIAxGff/HFKNMf0iioCj0W9sNY3SXJgdotSeFChLbBrIW1Pegh0VuGpD3+glE+BQb98QYD3LOWq9kkWRlwRoCIkP7/lV0Dunz3CfchOM4Mg6ehWFZXvuFheuFUpvnWYX0HuAQDsMAY4zSti0avracu67Tc0Hyuq51d87pICK9CBOmadJ32fm6vyj/pJQOJL9NKOP/k13FhbPwCaec1EA5WrNgAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tle\"\n        title=\"\"\n        src=\"/static/af4054092356f0d34ca22ad58ae7cb44/5a190/tle.png\"\n        srcset=\"/static/af4054092356f0d34ca22ad58ae7cb44/772e8/tle.png 200w,\n/static/af4054092356f0d34ca22ad58ae7cb44/e17e5/tle.png 400w,\n/static/af4054092356f0d34ca22ad58ae7cb44/5a190/tle.png 800w,\n/static/af4054092356f0d34ca22ad58ae7cb44/c1b63/tle.png 1200w,\n/static/af4054092356f0d34ca22ad58ae7cb44/203d3/tle.png 1322w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<pre><code class=\"language-python\">def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        # find all unique candidates using backtracking\n        def backtrack(start, path):\n            if sum(path[:]) == target:\n                result.append(path[:])\n            \n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                \n                path.append(candidates[i])\n                backtrack(i+1, path)\n                path.pop()\n\n        # sort items to handle duplicates\n        candidates.sort()\n        result = []\n        backtrack(0,[])\n        return result\n</code></pre>\n<h2>풀이 및 해설</h2>\n<h3>sums</h3>\n<p>시간초과가 발생한 이유는 중복된 계산이 많이 발생하기 때문이다. 가장 많은 중복이 발생하는 부분은 sum(path[:]) == target 부분이다. 이를 해결하기 위해서는 sum을 매번 계산하는 것이 아니라, target에서 path의 합을 빼서 남은 값을 계산하면 된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABd0lEQVR42pWRW2/bMAxG8/9/0163vux5XZo1bZPGN9myLF8kWbbOJAUbBmwYNgKEBIo8+kge9Bgo642m71Ba4eyEWQzGeqbJMc0Oay2TMbjVM8aYcSur95gYm+eZOb+tJDusfmMxO03XUIkXRHfhWl0puprn8sZbXXMV79z6kkJVyGEk1fht+wlcjP0V6NnjZWxG5OcHzp8+8PrwkfJ0jJ9oWqmjyoUQs/awxTPwN8sKQ4hJYWc1jvrc0IsO2Qp0GoFz/I8d0lwScN8CfolQ7ZlHhZSKJSpL4KIsEUKwLAtrbM37e82fgfGRBNx3vI1zGSzNpaa6JuhEWdwoI1APA6rvM1gNCutsLA+59reWfwBDVDn3hvpVouSQi/Q4ZlX/3LKNyQm2JYXTyPxeoF8KTNyybRuWpspuRI3rBFbc73ev8ErmNaURJD9Ydwem4Kp62uMX5PmIvpzpn0/Ib0+0T4/Zx7cz3elrdhHzutMjtrplZSEuNQG/A2tEt00pz/g1AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"target\"\n        title=\"\"\n        src=\"/static/1357d633e41a4fea06d4ef1a29b5fd0a/5a190/target.png\"\n        srcset=\"/static/1357d633e41a4fea06d4ef1a29b5fd0a/772e8/target.png 200w,\n/static/1357d633e41a4fea06d4ef1a29b5fd0a/e17e5/target.png 400w,\n/static/1357d633e41a4fea06d4ef1a29b5fd0a/5a190/target.png 800w,\n/static/1357d633e41a4fea06d4ef1a29b5fd0a/c1b63/target.png 1200w,\n/static/1357d633e41a4fea06d4ef1a29b5fd0a/d8817/target.png 1238w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>pop/append</h3>\n<p>또한, pop과 append를 매번 수행하는 것은 재귀적으로 돌아오는 과정에서 시간을 많이 소모한다. 이를 해결하기 위해서는 같은 path를 계속해서 수정하는 것이 아니라, 새로운 path를 만들어서 계산하면 된다.</p>\n<p><code>path + [candidates[i]]</code>를 사용하면 새로운 list가 생성되어서 공간이 더욱 필요하긴 하지만, 파이썬의 메모리 관리와 가비지 컬렉션이 잘 되어있기 때문에 큰 문제가 되지 않는다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABfUlEQVR42pVS2Y7bMAzM/3/fotg02HWzm1i+JNmSrFueUgoC9KVBK2CgixySQ560AoaxYJILuOTwVmHfNXYbG+TqYa2H2Q12H2BMgNYBLkb4djcNareI9HYqpdBHwcBn9EsHvjJcp2/c+YQL+8J1GPFJ+03c0K8DejHCuoiYMxEkOOcooIX1HimlB2EuB9RWwMm56864fP7CbZjBRgEuFMSqUY5COHDQ/mo1woqDjFPMmDoOMUtIKbCtK0Xf29+/rgdhjU5ZJio9u4IUqm4GIQTE4LAScUUt72hZEl4RVoO6R0uaqAC5LOi/R0yzw8DuJEOHvu8pa4lxHLHQ/0bdjKTZXwlzycipwG0e1zcG1s0kvgPnJIEQzbjaVuErnn4vMyyJSI2DuW8IRiN7i0yjkKmj/6dheXTQUwPY5Qz2ccb0ccFEZ8l6mssd27Y1DetZa92glGoj82empxq9gUgdDej95zu+frxRmRyGCBQ5VrLalCdJxbNR9a36PxP7DUl7CAsbT9zuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"pop\"\n        title=\"\"\n        src=\"/static/ecae0228ee5e7b3dce0eafcaacf134b0/5a190/popappend.png\"\n        srcset=\"/static/ecae0228ee5e7b3dce0eafcaacf134b0/772e8/popappend.png 200w,\n/static/ecae0228ee5e7b3dce0eafcaacf134b0/e17e5/popappend.png 400w,\n/static/ecae0228ee5e7b3dce0eafcaacf134b0/5a190/popappend.png 800w,\n/static/ecae0228ee5e7b3dce0eafcaacf134b0/8740f/popappend.png 1106w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        # find all unique candidates using backtracking\n        def backtrack(start, target, path):\n            if target == 0:\n                result.append(path[:])\n                return\n            \n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                \n                backtrack(i+1, target-candidates[i], path+[candidates[i]])\n\n        # sort items to handle duplicates\n        candidates.sort()\n        result = []\n        backtrack(0,target,[])\n        return result\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABtklEQVR42n2SzWsUQRDF9y/2tHjx7sWDh1wigvHoRXLQkwdBQYkhSAhBhBXcuLuEzIadnenpj+nu6Z81vd8iKXjTPdX0q6rXb4CECY7f5ZTSVMQQCSFkeO9JKbEfMXYU83vq+4qvt1cMvx/x5PKYX2qazwf9p+s6VK0ynHO0bYtvfd7HGDPpPvpCwQcab5nqgpme46LfEfZRFHdMpxPquqJcLFgsS7TRaK2x1uYiTdPk4j36Qv26jfUkmVDqMrm5ZTYpuBFc/xgxno1ZNhWNajDW5K42hBty512+u+LbJ8xjiGYu4lrRUHTqczHrGOikm1VhOFR0v8F/CA8OBT1pt86XBv6U61nSdrqHCTfir0gSd1WLkW6NTzz9mBi+hw8jeeW0k2yf/L8dbg5/FvDsU8er847nn+HRW3j8Doan8PIcFmY3yQMddug2MV4k3lwmjr50vDgTfIOTi8RrwckFHJ8lTq8To7lMoZLIkbBhRz/YGTbSaEOtnfjPElojXrPyUJogcFoR/SpvrWOpLEpbuSOWkoc76HBLKFYwxqBkrZXK/1VdZ5RlmXO1mL/3pumRfdpkS23iL8MpUJgNc2PFAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/f0c1f121da2f9c496354cfc3565a43e6/5a190/tc.png\"\n        srcset=\"/static/f0c1f121da2f9c496354cfc3565a43e6/772e8/tc.png 200w,\n/static/f0c1f121da2f9c496354cfc3565a43e6/e17e5/tc.png 400w,\n/static/f0c1f121da2f9c496354cfc3565a43e6/5a190/tc.png 800w,\n/static/f0c1f121da2f9c496354cfc3565a43e6/c1b63/tc.png 1200w,\n/static/f0c1f121da2f9c496354cfc3565a43e6/248b0/tc.png 1316w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>backtracking을 사용하여 모든 조합을 찾기 때문에 O(2^n)이다. ; n은 candidates의 길이</li>\n<li>중복된 숫자를 제거하기 위해 sort를 사용하였기 때문에 O(nlogn)이 추가된다.</li>\n<li>따라서, O(2^n) + O(nlogn) = O(2^n)이다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>backtracking을 사용하여 모든 조합을 찾기 때문에 O(2^n)이다. ; n은 candidates의 길이</li>\n<li>중복된 숫자를 제거하기 위해 sort를 사용하였기 때문에 O(n)이 추가된다.</li>\n<li>따라서, O(2^n) + O(nlogn) = O(2^n)이다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n1 &#x3C;= candidates.length &#x3C;= 100\n1 &#x3C;= candidates[i] &#x3C;= 50\n1 &#x3C;= target &#x3C;= 30\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/combination-sum-ii/\">40. Combination Sum II</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L40CombinationSumII/"}},"staticQueryHashes":[],"slicesMap":{}}