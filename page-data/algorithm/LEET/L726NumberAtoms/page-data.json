{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L726NumberAtoms/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"726. Number of Atoms","date":"July 14, 2024"},"html":"<h1>문제 설명</h1>\n<p>문자열로 주어진 화합물의 원자 수를 계산하는 문제다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 106%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB7ElEQVR42p2U6XKCQBCE9/2fz5T+sLwRFUQOUVFhwjfJUGsi0QpVXXvA9PTO9OKC9VoGHx8yGo1kMBjIZDKR4XCo6/v9Lu88TdNIXhRyrEpxVZ5LGkUSrEOJ2nG1Wsm6TcI8TVN596nrWuqmFlcej5K1gYfDQYo2y36/lziOdQ3yNuGx/aYsS33PyJr55XL5RexQgZrdbvc9Rt0a8u12q2sf7POexMST5IEwDEP9AGRZJlVVdTifzzqiBjC/Xq8K3tn7B0JUQBoEgWbnqKlXBpKwBpSAtX2HOvaSJFFiR1YIAQqpj68OmDJGCFCnTWhBh/25IwB2MuZ5oXNAfQA1syZZnSHsexwZIbMjWDMIhJg9VBv+IlNCFJoaasQIUZpmOqdekPhNIaaPWBX6djAfJsmXD+M40vqSDHJU0gRIexUSiCo6aoHWVaspym63W2eZn1aCh6vqsAr318d4PJblcimLxUJHMJ/Pu7m/N51O9bvZbKbqOx/a7eCm2LFRarbxLUTg6XRSRVjFh0Ou3VNqA+zOmonN3FZDs9Gzxjgz67u/qlePo+D8sjgORYf4ldfseL22oRGbzUZriWKOCLElMPhXrFchNeGHSiMotFkCsLZGsG+2YXx5ZIJNAUH/ramDCEKzD2tUP/sbv0P4CXCVWLiS4BN3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"726\"\n        title=\"\"\n        src=\"/static/7cd23370d32d181ad0c856c64ac30159/5a190/726.png\"\n        srcset=\"/static/7cd23370d32d181ad0c856c64ac30159/772e8/726.png 200w,\n/static/7cd23370d32d181ad0c856c64ac30159/e17e5/726.png 400w,\n/static/7cd23370d32d181ad0c856c64ac30159/5a190/726.png 800w,\n/static/7cd23370d32d181ad0c856c64ac30159/c1b63/726.png 1200w,\n/static/7cd23370d32d181ad0c856c64ac30159/eb2ef/726.png 1324w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<p>오늘 문제는 어렵다. 일단 한 눈에 봤을 때, 원소들의 수를 세야 하기 때문에 dictionary/hashmap을 사용해야 할 것 같으며, parenthesis 처리를 해줘야 하기 때문에 stack을 사용해야 할 것 같다. 또한, 원소들이나 숫자들이 두 자리수 이상일 수 있기 때문에, 숫자를 처리할 때도 주의해야 할 것 같으며, 숫자들이 괄호 이후에 나오기 때문에 원소의 수에 hashmap에 곱해주는 연산도 진행해야 할 것 같다.</p>\n<p>관건은 이 둘을 어떻게 합칠것이며, 한번에 잘 사용하는 것인데, 이게 이 문제를 어렵게 만드는 요인이다.</p>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">def countOfAtoms(self, formula: str) -> str:\n    def parse_count(i):\n        '''\n        Parses string by reading digits until it failure.\n        ex: H123\n        reads: 1 -> reads 2, adds to 1 becoming 21 -> 123\n        '''\n        count = 0\n        while i &#x3C; len(formula) and formula[i].isdigit():\n            count = count * 10 + int(formula[i])\n            i += 1\n        return max(1, count), i\n    \n    def multiply_dict(d,n):\n        '''\n        Returns a dictionary multiplied by the count provided.\n        '''\n        return {k: v*n for k,v in d.items()}\n\n    # parse numbers and letters in parenthesis\n    stack = [{}]\n    i = 0\n    while i &#x3C; len(formula):\n        if formula[i] == \"(\":\n            stack.append({})\n            i += 1\n        elif formula[i] == \")\":\n            top = stack.pop()\n            i += 1\n\n            # parse the value of the following number\n            # which could be larger than 1 digit\n            count, i = parse_count(i)\n\n            # pop top dictionary and count it\n            # then append it to the larger dictionary\n            for k,v in multiply_dict(top,count).items():\n                #get(k,0) returns either k or 0 if it doesn't exist\n                stack[-1][k] = stack[-1].get(k,0)+v   \n        else:\n            element = formula[i]\n            i += 1\n            # if this char is a lowercase, add it to atom str\n            if i &#x3C; len(formula) and formula[i].islower():\n                element += formula[i]\n                i += 1\n            \n            count, i = parse_count(i)\n            stack[-1][element] = stack[-1].get(element,0) + count\n\n    result = stack[0]\n    # order: first name (sorted), count(if >1), second name(sorted), so on.\n    return ''.join(k + (str(v) if v>1 else '') for k,v in sorted(result.items()))\n</code></pre>\n<ul>\n<li><code>parse_count</code> 함수는 숫자를 파싱하는 함수다. 숫자가 두 자리수 이상일 수 있기 때문에, 이를 처리해주는 함수다.</li>\n<li><code>multiply_dict</code> 함수는 dictionary의 모든 값을 n배 해주는 함수다.</li>\n<li><code>stack</code>은 stack을 사용해 괄호를 처리하는데 사용한다.</li>\n<li><code>while</code>문을 통해 formula를 순회하며, 괄호를 처리한다.\n<ul>\n<li><code>(</code>가 나오면 stack에 빈 dictionary를 추가한다.</li>\n<li><code>)</code>가 나오면 stack에서 dictionary를 pop하고, 다음 숫자를 파싱한다.</li>\n<li>그리고 pop한 dictionary를 count만큼 곱해주고, stack에 append한다.</li>\n<li>그 외의 경우에는 element를 파싱하고, count를 파싱하여 stack에 추가한다.</li>\n</ul>\n</li>\n<li>마지막으로 stack의 첫번째 dictionary를 result에 저장하고, 정렬하여 반환한다.</li>\n</ul>\n<h2>Complexity Analysis</h2>\n<ul>\n<li>시간 복잡도: O(N)</li>\n<li>공간 복잡도: O(N)</li>\n<li>N: formula의 길이</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB4klEQVR42qVTy47TQBDMB8MHIMEfcOOAOCEhBJcIEAIJJHbFgROHLOwqLFE2sMIxG8cbxx57Hp6Hi+4hNmGBE2212/OqrimVR9ZbnBcp0jKDtTam9z5W5xy6rsPVqCqBJFliuylxf/ECN47u4uaHe/gmVxjxASFETKUUpJQwxsRvzhDCH6DeB1hqFqheqEvMRYJFvYQhciPewGDLdImyKolZG4EYtAfmymy5GbP/Z1DjCJimFzibf8V6XWB6eobTzzNsiyIC1HUNrXWUoKqqQZKmaeJ6vEH/9IBCaJQbie1WI6MqGmalIzMGa9s2bt7PXop9OQbAjhbpjf+NAZCvEAJ3izL0cgzVU8OyyJGtKbMMeZ7j+yqLsqyoGtP+DjjosAc4dN3VrXQYH1N+dDhJFB5NGMQRGbZW+AvgFaRZDmgHvP0CvE+AW6+A2wfA9SfAnUONa+OAlzPgYAFMM+zI7GmorUehAgQ13siA1zMfQR9MOryZBzw+Bt6dd3g4CTicezyddnj+KeAZ1fEJnVE/7zPqqSql0UjynbGQ5L3WqJ1FyDItG7ylOQlnanhnKDWcVbRuyODsU/uLIUdDflOyoUMGNf85NGbbCFGjonHTSDJ+hctNgZo8yOtlWcV59iNbi+MHB26cqD5rkwcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/89ce924945d893e66787f91c14475589/5a190/tc.png\"\n        srcset=\"/static/89ce924945d893e66787f91c14475589/772e8/tc.png 200w,\n/static/89ce924945d893e66787f91c14475589/e17e5/tc.png 400w,\n/static/89ce924945d893e66787f91c14475589/5a190/tc.png 800w,\n/static/89ce924945d893e66787f91c14475589/c1b63/tc.png 1200w,\n/static/89ce924945d893e66787f91c14475589/71b12/tc.png 1308w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>formula를 한번 순회하며, 각 문자를 처리하므로 O(N)이다.</li>\n<li><code>parse_count</code> 함수는 숫자를 파싱하는데, 이는 O(1)이다.</li>\n<li><code>multiply_dict</code> 함수는 dictionary의 모든 값을 n배 해주는데, 이는 O(N)이다.</li>\n<li>sorted(result.items())는 O(KlogK)이다. 이때, K는 서로 다른 원소의 개수이다. 보통 K는 N보다 작으므로, O(N)으로 예상된다.</li>\n<li>따라서 전체 시간 복잡도는 O(N)이다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>stack에는 dictionary를 저장하므로, O(N)이다.</li>\n<li>따라서 전체 공간 복잡도는 O(N)이다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n1 &#x3C;= formula.length &#x3C;= 1000\nformula consists of English letters, digits, '(', and ')'.\nformula is always valid.\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/number-of-atoms/\">Leet</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L726NumberAtoms/"}},"staticQueryHashes":[],"slicesMap":{}}