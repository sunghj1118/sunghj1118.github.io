{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L2058MinMaxDbetweenNodes/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"2058. Find the Minimum and Maximum Number of Nodes Between Critical Points","date":"July 05, 2024"},"html":"<h1>문제 설명</h1>\n<p>로컬 최소값과 로컬 최대값 사이의 최대 거리와 최소 거리를 찾는 문제이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 97.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAACLUlEQVR42qWUB8/aQAyG7///M8oSQ4CYCSMQEkIgQNhuHkuu4FO/tqInWXceZ78ed65WrcqPUkmazaZUKhWp1WpSLpelVMharZY0Gg2VI6vX69Jut9UWHt1kMpHr9Sr7/V7SfCeu2WoXl8vqCKoWAXq9nu44wgl7mqZ68XK5/Nqh+/0urOfjKc/nU1y+DyTfhxLHG1kul7Jer2WxCIrzSrbbVMIw1Iv/utwxSyXbJZIkW4UNbTYbRZRlWeF0K4fDQfI8l9PppARCeOTwbw6jKJbZbCbT6VTRBEGgexRFihge3WKxkNFoJIPBQO193xfP81SH8/P5rOk7DCGKC8VxLLvdTtGB1s6GFj1lIQtk6MkGHU4dsFGYkPPxeHxLEcLYHBMIm1cd9o/HQ9x8PlfYpDMejzWyBbHLtidJonrKYTUGoWVyu92oYaQGpAJCDLnIzmXk8BB69tVq9WaPHWecOgwYC+BSVIiz0e9kIIFMZ6RzSEfpJo0hchAstYuUgk5a0+BpGjrssQ3DdbGHRZMinQya5Rjg4XCkNez3+/q0ut2uUqfTURk7PC8I8n1P683Y9PuDIpBXyKZFLTMQrjQyaEBBFF7NaxdpEp2058Zgw0OmgzRlm3CYV/p0ORBRE4r8dZnjPwX4qnPWbhSkYr/HxwiZIZt83i3O/8shjiis/SCvf9xHDpn44XCoL8C+L5xSgtdhNvpb0xzvkcGlOaRr4wJa+/MsC/swGJHvHP4El1f5sQiARgUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2058\"\n        title=\"\"\n        src=\"/static/4135d3ee32ad03571656d0230560f498/5a190/2058.png\"\n        srcset=\"/static/4135d3ee32ad03571656d0230560f498/772e8/2058.png 200w,\n/static/4135d3ee32ad03571656d0230560f498/e17e5/2058.png 400w,\n/static/4135d3ee32ad03571656d0230560f498/5a190/2058.png 800w,\n/static/4135d3ee32ad03571656d0230560f498/c1b63/2058.png 1200w,\n/static/4135d3ee32ad03571656d0230560f498/c2d9c/2058.png 1326w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 49.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABOUlEQVR42o2S247CMAxE+/+fyNuCdhdo1TbN3XE62EGggopEpJEaO5keO+7GZGD8Au88ChfsLS6MyU04L2fM0cCTR+L0cmZdVzAzOkqErMqEIhc1uCcbI67LgH/zizmMcMkhF3rma63NtHPOwVpJ5gyiu/G7SimIqWIYZ0x2QBbCQiwxQowBMQQkuV+U0PsgRqXR7UnL1XwS5ZhhjBGjCK5FxFjr2sheCJVMKfbE0tcs+aAEYvrzd8TheMCpP2E0E5xN8F6rtK1KIfSN4KEH2XOvZKIopkozTzMu/UVKjUgpiUlpRrpXgE57xFyb9DsEPZifsapxNZQc0b1k/dGn1b0//UPbpc1WQpJXtcG13n1l+GmRtCCooc+4Dr2MzQJimQDOTdv5/cpQCVPrKWFcJpnHsZGqqdJuiW8DlBDXPx+cTQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"crits\"\n        title=\"\"\n        src=\"/static/6092d5dd2b9e374e8b893122d22d14bf/5a190/crits.png\"\n        srcset=\"/static/6092d5dd2b9e374e8b893122d22d14bf/772e8/crits.png 200w,\n/static/6092d5dd2b9e374e8b893122d22d14bf/e17e5/crits.png 400w,\n/static/6092d5dd2b9e374e8b893122d22d14bf/5a190/crits.png 800w,\n/static/6092d5dd2b9e374e8b893122d22d14bf/c1b63/crits.png 1200w,\n/static/6092d5dd2b9e374e8b893122d22d14bf/29007/crits.png 1600w,\n/static/6092d5dd2b9e374e8b893122d22d14bf/c7ddf/crits.png 2810w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>이 문제를 풀기 위해서는 주어진 Linked List에서 로컬 최소값과 로컬 최대값을 찾아야 한다.\n<ul>\n<li>해당 값들을 찾아서 인덱스를 저장한다.</li>\n</ul>\n</li>\n<li>이후, 찾은 인덱스를 이용하여 최대 거리와 최소 거리를 찾는다.\n<ul>\n<li>최대 거리는 인덱스의 차이 중 가장 큰 값이다. 인덱스를 순서대로 정렬하고 마지막 값과 첫번째 값을 빼면 된다.</li>\n<li>최소 거리는 인덱스의 차이 중 가장 작은 값이다. 인덱스를 순서대로 정렬하고 인덱스의 차이를 구한 후, 가장 작은 값을 찾으면 된다.</li>\n</ul>\n</li>\n</ul>\n<h2>풀이</h2>\n<pre><code class=\"language-python\"># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\n        # find crit points\n        crits = []\n        i = 1\n\n        while head.next.next:\n            # is the next node a local min?\n            if head.next.val &#x3C; head.next.next.val and head.val > head.next.val:\n                crits.append(i)\n            # is the next node a local max?\n            elif head.next.val > head.next.next.val and head.val &#x3C; head.next.val:\n                crits.append(i)\n            \n            i += 1\n            head = head.next\n\n        # return results\n        if len(crits) &#x3C; 2:\n            return [-1,-1]\n        else:\n            # keep min and max distance and renew it if applies\n            min_d = 1000000000\n            max_d = crits[-1] - crits[0]\n\n            for i in range(len(crits)-1):\n                min_d = min(min_d, crits[i+1] - crits[i])\n            return [min_d, max_d]\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACOElEQVR42o1T32vUQBDOXy5CBfFZUAR/giCIL/qo1GIfSsEqUs67Vq+9Bkvucne5ZLM/kmyy+zmzOa/VWujAsN/O7H47MzsT/VzFmMoFuq5D27Zh/aPOOfwrfGaxWGI6naEoBB6fvMPW4BluHz7BbvoNUTKfYplnMMZAa42qqqCNDvumaa4Qdp2DlCqoobMfZwd4HW/j1dkHDMUEUWvbcJmJNpHRJbZbawMpR8rKPu89rhVyRXEcY3Q0QjpPIUSOaZIgmU2RyxxacSQyECnCQghKmUvh+8fqBrazcN5tNDqbnCM+TaguAsfjcxwOjjA8/o6kmMFoA0lETMgZqDXmOjIuRQljDQXWR83RR6ZqUUlLkTQQqkVtHbzrU25ss0n5JhIIO9ddMXIxTAuUNdDQShkG+3X6FyG/7sOFC2URRBavOpxmbk14wwjDC76PgoWjWhkiK4DdcYMvv1pktF8ogKqwvnhJ+8+9lHJohQvjeAm8/Ao83Ace7Ts82HN4cQA8Jx3Ngeoy6f9r6PFj4TFZAcPU483A4/4ecGfHY2vb49b7Dvc+AXd3gKefPd4OgZPME7kPD0wIzyRQVH0jRh21QEY/vNQeqbBYypacHsvSQtC6Uha5biFrhxn7lceipPGjc5l2SIsaufHQTZ98+BStStQ0bpWW1HuSsIIq84BVWUBL0fuUQFPpYOc9Y/bVlQnKXOFTypJI6jrMp1I64KIowsrTwdPCjc2Y+5Kbmue+Jszn2Gbpx7iGvwHqwjbA8p+KrwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/dbf82de525b50cc54496d05a3e5edd7f/5a190/tc.png\"\n        srcset=\"/static/dbf82de525b50cc54496d05a3e5edd7f/772e8/tc.png 200w,\n/static/dbf82de525b50cc54496d05a3e5edd7f/e17e5/tc.png 400w,\n/static/dbf82de525b50cc54496d05a3e5edd7f/5a190/tc.png 800w,\n/static/dbf82de525b50cc54496d05a3e5edd7f/c1b63/tc.png 1200w,\n/static/dbf82de525b50cc54496d05a3e5edd7f/4719e/tc.png 1330w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>while loop: O(n) ; n은 노드의 개수</li>\n<li>for loop: O(n) ; n은 critical 노드가 저장된 배열의 길이</li>\n</ul>\n<p>따라서, O(n)이다.</p>\n<h3>공간 복잡도</h3>\n<ul>\n<li>crits 배열: O(n) ; n은 critical 노드의 개수</li>\n</ul>\n<p>따라서, O(n)이다.</p>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\nThe number of nodes in the list is in the range [2, 10^5].\n1 &#x3C;= Node.val &#x3C;= 10^5\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/\">2058. Find the Minimum and Maximum Number of Nodes Between Critical Points</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L2058MinMaxDbetweenNodes/"}},"staticQueryHashes":[],"slicesMap":{}}