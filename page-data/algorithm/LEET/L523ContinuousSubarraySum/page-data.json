{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L523ContinuousSubarraySum/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"523. Continuous Subarray Sum","date":"June 08, 2024"},"html":"<h2>문제 설명</h2>\n<p>주어진 배열에서 연속된 부분배열의 합이 k의 배수인지 확인하는 문제다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 85%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAABh0lEQVR42p2U646CMBCFef8HJEaM/DCiclFQCsht1m/MJJXsJrhNJlNKezrnnIHgcDjIfr+XKIpku91KHMcShqHsdjvZbDZyvV6FMc+zrBlB31XS1rlkWaGHkyR5zXPp+16GYZBpmj5iHEeNeeZ51LUPwKoqJb1c5PIKALMs07jdbvJ4PMS5Rura6bwoCknTVHPTNHK/33V9AVjJ8ZjI+XzWjXme66blzVD+Kz4Au66TsiwVjCoBbNtWns+nBnMorh0B1KDIQWiQnXMvmrVmqkXP1YAcxGmq5LBl9KH6b0cALcwAgAxldEUCqid4xxoGte1bIuQhE77eAXQA9cX1BWfz0gRroV9NoQJ6D2A2Wf9hxNLpVZTRiy+F/jIjMIdAQ6rnErvI3Le1pWEB+qAHAPZlUJ1tXgPo09bGBpAXANE2Nv83ZX4Ep9NJneQZ6n5f+mEykC2sYhhoH9LY77Zw+tI0tCa3Rrdvl+o5bCC+ieoyjc1NppG/6WvKVIHD3Ayo/Z6s174F/AGwSi+8GcxNAQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"523\"\n        title=\"\"\n        src=\"/static/ec228f9541ccc63a91f5af43b490b7f3/5a190/523.png\"\n        srcset=\"/static/ec228f9541ccc63a91f5af43b490b7f3/772e8/523.png 200w,\n/static/ec228f9541ccc63a91f5af43b490b7f3/e17e5/523.png 400w,\n/static/ec228f9541ccc63a91f5af43b490b7f3/5a190/523.png 800w,\n/static/ec228f9541ccc63a91f5af43b490b7f3/c1b63/523.png 1200w,\n/static/ec228f9541ccc63a91f5af43b490b7f3/a8a6f/523.png 1516w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>1차 시도</h2>\n<p>처음 보자마자 뭔가 DP 문제 같다. 두가지 가능성을 고려해야되는데, 처음부터 끝까지 다 더했을때 k의 배수인지, 중간에 있는 부분배열의 합이 k의 배수인지 확인해야한다. 그런데, 배수는 오히려 숫자가 올라가면서 생길 수 있는것이기 때문에 어떻게 접근해야 할지 조금 고민이다.</p>\n<p>뭔가 두개의 포인터를 사용해서 풀어야 할 것 같은데, 어느 지점에서 앞에 있는 포인터를 줄여야 할지 모르겠다. 일단 안 줄이고 끝까지 가보고, 끝까지 다 사이클을 했는데도 불구하고 없다면 하나를 줄이고 다시 시작해보는 방법을 사용해보자. 시간복잡도가 박살날것 같긴 하지만 일단 해보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAAzklEQVR42o2QjY7EIAiE+/6Penvb+ldFUOdAs9lNtpfU5AtKcIDZXHLI54mcC4gqSrFIyBq992jS0NrCh4AYE0RzY4xJ7/1N69iK0CywRGVGrRVXxz6z1oUk+D1+4OKuRISslIRIGbWxChYCsyg8JzTWe+Ved1GqiDYeCDr50z9whB1JxTJnnAqboK2wViVQWfGKWVN5bsIa9/0J5w8UKpChDZug9YZtdpd7ZBUaOiFTR3LmtXxZs5lndwVtOjs6jHp6abUJ8m3B8anyj+Af/pUlppt1DBsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/314cc1f04cf8b719017bf2ff2e49c21a/5a190/tc.png\"\n        srcset=\"/static/314cc1f04cf8b719017bf2ff2e49c21a/772e8/tc.png 200w,\n/static/314cc1f04cf8b719017bf2ff2e49c21a/e17e5/tc.png 400w,\n/static/314cc1f04cf8b719017bf2ff2e49c21a/5a190/tc.png 800w,\n/static/314cc1f04cf8b719017bf2ff2e49c21a/c1b63/tc.png 1200w,\n/static/314cc1f04cf8b719017bf2ff2e49c21a/29007/tc.png 1600w,\n/static/314cc1f04cf8b719017bf2ff2e49c21a/66900/tc.png 2630w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>일단 이렇게 하면 테케는 다 통과하긴 하는데 시간이 좀 느릴 것 같다. 계산해보자.</p>\n<h3>시간복잡도</h3>\n<ul>\n<li>for loop: O(N) ; N은 nums 배열의 길이</li>\n<li>for loop: O(N) ; N은 nums 배열의 길이</li>\n</ul>\n<p>전체: O(N^2)이다.</p>\n<h3>제한</h3>\n<pre><code>1 &#x3C;= nums.length &#x3C;= 10^5\n0 &#x3C;= nums[i] &#x3C;= 10^9\n0 &#x3C;= sum(nums[i]) &#x3C;= 2^31 - 1\n1 &#x3C;= k &#x3C;= 2^31 - 1\n</code></pre>\n<p>배열의 길이 N이 10^5까지 가능하므로, O(N^2)은 너무 느릴 것 같다. 최대 N^2이 10^10이므로, 10억이 넘어가는 숫자이다. 이렇게 큰 숫자를 계산하는 것은 불가능하다.</p>\n<p>더 최적화된 방법을 찾아보자.</p>\n<h3>제출시도:</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.500000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA/klEQVR42l1R267DIAzr/39d1z73spcjdVq7UijhEvACOp20IUXGoDjGNLS/kJRCVjvAjN8VI8P7gJSS7AOs9djUCevOyn2McMELhlpNDAHBWiTvkaUp5/xVRcg5J7NYeJKmBGMIj+cfnq8F677DiLgmAy3YbNuGYRgw3+8Vp2nCPM8Yx7FivRMMMrgMKI4SJ2grAvaAIQ2KBM++YrMsC9q2Rdd1uN1u6Pv+s7+qcCKqgvQvTKfFuj6gDgVyhCTuOTOa8hytNY5DphkDJXkW19fZhUmezOLMOl8dBmKcykmmLFnGT0RNmVyaSlZXlbx++ZUnixMxIoKFQ86/P/ENdNrOkeZKNecAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"x1\"\n        title=\"\"\n        src=\"/static/8ffd4284a5bbbd42c57492b8cbebde7b/5a190/x1.png\"\n        srcset=\"/static/8ffd4284a5bbbd42c57492b8cbebde7b/772e8/x1.png 200w,\n/static/8ffd4284a5bbbd42c57492b8cbebde7b/e17e5/x1.png 400w,\n/static/8ffd4284a5bbbd42c57492b8cbebde7b/5a190/x1.png 800w,\n/static/8ffd4284a5bbbd42c57492b8cbebde7b/c1b63/x1.png 1200w,\n/static/8ffd4284a5bbbd42c57492b8cbebde7b/29007/x1.png 1600w,\n/static/8ffd4284a5bbbd42c57492b8cbebde7b/196e0/x1.png 2626w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>역시 시간제한에 걸린다.</p>\n<h2>2차 시도</h2>\n<h2>Hashmap</h2>\n<p>보니까 힌트에 hashmap을 사용하라고 나와있다. hashmap을 사용하면 O(1)에 접근이 가능하므로, 시간복잡도를 줄일 수 있을 것 같다. hashmap을 사용해서 누적합을 저장하고, k의 배수인지 확인하면 될 것 같다.</p>\n<h2>풀이 및 해설</h2>\n<p>해시맵을 사용해서 풀어봤다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABHElEQVR42n2RjW6DMAyEef/37KCUEgj5sZ2Em52JTd2qIX0i4OR85wxLdIiUUEpBa63z7qm1IkSG2w+kpBAjM4GEwUX6OdszpJghIv3DRA1b/6bX6ollXTAuH3BxQ+KMJBm5EGqrvfFwHAFGzvQvxKyCTV0GjI8bZjfBJ492viYaSK1/Obgob2FNwVondbWsd6z+iaCCWdKroHMO27YjxoQQIqzBO7LCUhVWdw/c1KWLKzx5SJUfwWmaME1zF913r6KpR0zpFRMkKTgtto5ovM+4P2fsYUc9a49+nicGc+X90d1d8zK3f1yygOzClFUvZp5H+GPT6E6jB60RSisYTOCan6gDg/Xwtf7+Z2+dNZPg0IaJQp8fF+7OrsifeHJv4KHCeuQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"hm\"\n        title=\"\"\n        src=\"/static/7df370c82124995eba96541989a1e88c/5a190/hm.png\"\n        srcset=\"/static/7df370c82124995eba96541989a1e88c/772e8/hm.png 200w,\n/static/7df370c82124995eba96541989a1e88c/e17e5/hm.png 400w,\n/static/7df370c82124995eba96541989a1e88c/5a190/hm.png 800w,\n/static/7df370c82124995eba96541989a1e88c/c1b63/hm.png 1200w,\n/static/7df370c82124995eba96541989a1e88c/29007/hm.png 1600w,\n/static/7df370c82124995eba96541989a1e88c/20f38/hm.png 2818w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>해당 풀이는 dictionary를 우선 선언한다.</li>\n<li>이후, 누적합을 저장할 변수를 선언하고, nums의 각 요소를 순회하면서 누적합을 계산한다.</li>\n<li>누적합을 k로 나눈 나머지를 구한다.</li>\n</ul>\n<p><strong>핵심</strong></p>\n<ul>\n<li>해당 누적합이 해시맵에 존재하지 않다면 추가한다.</li>\n<li>만약 존재할 시, 이건 k에 대한 배수가 된다는 뜻이다. 왜?\n<ul>\n<li>이미 한번 나눈 나머지가 존재한다는 뜻은 i번째 요소와 j번째 요소 사이의 누적합이 k의 배수라는 뜻이다.</li>\n<li>0부터 i까지의 누적합은 prefix_sum[i]이고, 0부터 j까지의 누적합은 prefix_sum[j]이다.</li>\n<li>k로 나눈 나머지가 같다는 것은 prefix_sum[i]와 prefix_sum[j]의 차이가 k의 배수라는 뜻이다.</li>\n</ul>\n</li>\n</ul>\n<h3>예시:</h3>\n<p>[23,2,4], k=6</p>\n<p><strong>Prefix Sums:</strong></p>\n<p>Index 0: 23 (prefix sum: 23)<br>\nIndex 1: 23 + 2 = 25 (prefix sum: 25)<br>\nIndex 2: 23 + 2 + 4 = 29 (prefix sum: 29)</p>\n<p><strong>Remainders:</strong></p>\n<p>Index 0: 23 % 6 = 5<br>\nIndex 1: 25 % 6 = 1<br>\nIndex 2: 29 % 6 = 5</p>\n<p>이때, i와 j의 나머지가 둘 다 5다. 이때, 그러면 j의 누적합으로부터 i의 누적합을 빼면 29-23=6이다. 이때, 6은 k의 배수이므로, 이는 k의 배수가 된다.</p>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">class Solution:\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:        \n        # initialize dictionary\n        remainder_map = {0:-1} # start with a remainder 0 at index -1\n        prefix_sum = 0\n\n        # iterate through the nums array\n        for i, num in enumerate(nums):\n            # update the sum with the current num\n            prefix_sum += num\n            print(\"sum is\", prefix_sum, \"\\n\")\n\n            # compute the remainder of the sum with k\n            rem = prefix_sum%k\n\n            # check if this remainder has been seen before\n            if rem in remainder_map:\n                # ensure the subarray length is at least 2\n                if (i - remainder_map[rem] > 1):\n                    print(i, num, rem, remainder_map)\n                    return True\n            else:\n                # store the remainder with the current index if not seen before\n                remainder_map[rem] = i\n                print(\"remainder map is:\", remainder_map, rem)\n        \n        # return false if no good subarray is found\n        return False\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABP0lEQVR42pWSW26DMBBFs+oupcou2o1U+elX+0VUVUkExIABv/At18pELgFVHWk049fxnbF3WmtcW4XRG/zXQgwwk4OfI805hx2Ts65Q1N+w1qZJOvMQwgOk7wecThfUV4X95yueDs/Yf7wgxpjWE9BZB91pDOOQQOLee0zTlDaLc8wLuaZch8q2aKxGvF2YgMMwoCiOqKsK1hiM45ic833fJwBzXrJqMd7TBFS6wdv7AcfyC2c1l1PVKMsSSqk7kHnbtkkZW8EoZcYl0AcPY2dlzsDMzhZIP/OyGZctWAXmi7nJ4b/sAbh2M5WxXDP3NFey5ZsK2aumadKjdF0H/lPm7NuW2lWgHCCAQCoztxfnCzMu+5o/zC8gjQdYIl1ywqmSQPlCjJyXKOo3gbKZX4QwquWcONc4z/0cs4oc+AOi/Kv+Rt1M3QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/97418b4d536c5f8099e32e0ec5fa0b3e/5a190/success.png\"\n        srcset=\"/static/97418b4d536c5f8099e32e0ec5fa0b3e/772e8/success.png 200w,\n/static/97418b4d536c5f8099e32e0ec5fa0b3e/e17e5/success.png 400w,\n/static/97418b4d536c5f8099e32e0ec5fa0b3e/5a190/success.png 800w,\n/static/97418b4d536c5f8099e32e0ec5fa0b3e/c1b63/success.png 1200w,\n/static/97418b4d536c5f8099e32e0ec5fa0b3e/68638/success.png 1510w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>매우 빠른것을 확인할 수 있다.</p>\n<h3>Time Complexity</h3>\n<ul>\n<li>for loop: O(N) ; N은 nums 배열의 길이</li>\n<li>dictionary lookup: O(1) ; dictionary의 길이는 k이다.</li>\n</ul>\n<p>최종적으로 O(N)이다.</p>\n<h3>Space Complexity</h3>\n<ul>\n<li>O(N) ; N은 nums 배열의 길이</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n\n1 &#x3C;= nums.length &#x3C;= 10^5\n</code></pre>\n<ul>\n<li>시간복잡도는 O(10^5). 하나의 operation은 10^-6이 걸린다 생각하면 10^5 * 10^-6 = 0.1초이다. 충분히 빠르다.</li>\n<li>공간복잡도는 O(10^5).</li>\n</ul>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/replace-words\">LeetCode</a></li>\n<li><a href=\"https://www.datacamp.com/tutorial/guide-to-python-hashmaps\">Python Hashmaps - Datacamp</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L523ContinuousSubarraySum/"}},"staticQueryHashes":[],"slicesMap":{}}