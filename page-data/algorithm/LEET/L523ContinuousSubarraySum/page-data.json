{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L523ContinuousSubarraySum/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"523. Continuous Subarray Sum","date":"June 08, 2024"},"html":"<h2>문제 설명</h2>\n<p>주어진 배열에서 연속된 부분배열의 합이 k의 배수인지 확인하는 문제다.</p>\n<p><img src=\"../../../images/LEET/523/523.png\" alt=\"523\"></p>\n<h2>1차 시도</h2>\n<p>처음 보자마자 뭔가 DP 문제 같다. 두가지 가능성을 고려해야되는데, 처음부터 끝까지 다 더했을때 k의 배수인지, 중간에 있는 부분배열의 합이 k의 배수인지 확인해야한다. 그런데, 배수는 오히려 숫자가 올라가면서 생길 수 있는것이기 때문에 어떻게 접근해야 할지 조금 고민이다.</p>\n<p>뭔가 두개의 포인터를 사용해서 풀어야 할 것 같은데, 어느 지점에서 앞에 있는 포인터를 줄여야 할지 모르겠다. 일단 안 줄이고 끝까지 가보고, 끝까지 다 사이클을 했는데도 불구하고 없다면 하나를 줄이고 다시 시작해보는 방법을 사용해보자. 시간복잡도가 박살날것 같긴 하지만 일단 해보자.</p>\n<p><img src=\"../../../images/LEET/523/tc.png\" alt=\"tc\"></p>\n<p>일단 이렇게 하면 테케는 다 통과하긴 하는데 시간이 좀 느릴 것 같다. 계산해보자.</p>\n<h3>시간복잡도</h3>\n<ul>\n<li>for loop: O(N) ; N은 nums 배열의 길이</li>\n<li>for loop: O(N) ; N은 nums 배열의 길이</li>\n</ul>\n<p>전체: O(N^2)이다.</p>\n<h3>제한</h3>\n<pre><code>1 &#x3C;= nums.length &#x3C;= 10^5\n0 &#x3C;= nums[i] &#x3C;= 10^9\n0 &#x3C;= sum(nums[i]) &#x3C;= 2^31 - 1\n1 &#x3C;= k &#x3C;= 2^31 - 1\n</code></pre>\n<p>배열의 길이 N이 10^5까지 가능하므로, O(N^2)은 너무 느릴 것 같다. 최대 N^2이 10^10이므로, 10억이 넘어가는 숫자이다. 이렇게 큰 숫자를 계산하는 것은 불가능하다.</p>\n<p>더 최적화된 방법을 찾아보자.</p>\n<h3>제출시도:</h3>\n<p><img src=\"../../../images/LEET/523/x1.png\" alt=\"x1\"></p>\n<p>역시 시간제한에 걸린다.</p>\n<h2>2차 시도</h2>\n<h2>Hashmap</h2>\n<p>보니까 힌트에 hashmap을 사용하라고 나와있다. hashmap을 사용하면 O(1)에 접근이 가능하므로, 시간복잡도를 줄일 수 있을 것 같다. hashmap을 사용해서 누적합을 저장하고, k의 배수인지 확인하면 될 것 같다.</p>\n<h2>풀이 및 해설</h2>\n<p>위 방안에서 정렬을 해주니 해결되었다. 정렬을 해주면 가장 짧은 단어부터 비교하게 되므로, 가장 먼저 발견되는 단어가 가장 짧은 단어가 된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABAUlEQVR42o2S23LDIAxE/f+/mXbs+BpjcxEIthKpG7fjzBTPeRGw2hVuFrti9w7MjHeryBd8hHlYJI4oRWq51Du56O5rNRQISowJKV3DnBCIsRqPcerQ9p/olxE+eGnA0uAl2WzbBiMQqWi8REVDTNXRPM+431vovXKRplmWBftuq0OieInuecV5dEOHxT7AmStnd1UwSNxnNH6LOnOSIMvc9nXHMPYwzoBYaiX/FvQ+VAcHZ1cH2tBKY3VjrMGHzHBeZ1AMVTRwQEihijd66CDn/C0Wca4XOWi9JJHHGecBt/aGyUywZEGJfuJXQfxjqaiTRpwynDxGjFR/HxX4O8MvQLFz8Y1sk/MAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ans\"\n        title=\"\"\n        src=\"/static/cd0a26bf26338e86b0305e37e2b0b6f4/5a190/2500.png\"\n        srcset=\"/static/cd0a26bf26338e86b0305e37e2b0b6f4/772e8/2500.png 200w,\n/static/cd0a26bf26338e86b0305e37e2b0b6f4/e17e5/2500.png 400w,\n/static/cd0a26bf26338e86b0305e37e2b0b6f4/5a190/2500.png 800w,\n/static/cd0a26bf26338e86b0305e37e2b0b6f4/c1b63/2500.png 1200w,\n/static/cd0a26bf26338e86b0305e37e2b0b6f4/29007/2500.png 1600w,\n/static/cd0a26bf26338e86b0305e37e2b0b6f4/fb371/2500.png 2512w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">class Solution:\n    def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n        words = sentence.split()\n        arr = []\n        dictionary = sorted(dictionary)\n\n        for word in words:\n            root_found = False\n            for root in dictionary:\n                if root == word[:len(root)]:\n                    print(\"comparing: \", root, word[:len(root)])\n                    root_found = True\n                    index = word.find(root)\n                    result = word[:index + len(root)]\n                    arr.append(result)\n                    break\n            if not root_found:\n                arr.append(word)\n        \n        string = \" \".join(arr)\n        \n        return string\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABgUlEQVR42pVT2U7CQBTth2iM0r3THboYoCwVSXzA8Eii8BH+jfFbjzlDbtNCQvTh9J505p67jpGuS6hpCt/34XkeXNfVVrht2wM4joP5fI7X7Razaorsa4vVzwmr7xP89xLG+qVFlmeI4xhJkiCKoo4rpWBZ1pUgz/I8RxLGCN4KxJ8N4o8G7nMEg86z6QxVXemLaZoOQMcgCHQFtBQ0TfMMy4T1MIJ59wjz/gn2yILRti0OhwMWiwXKskRVVQPUdY0wDHWwyWSihQdZO0MYy+US+/0em80GTdPo/lCclgIMolQAFSskaQI7sOF6rhYW9FtiMDpLYb9o+xAHPRzn3D8B/wnknxbkhyVwqsIvcTnpWzAkAocjDe9n8h90gsyOgpzq8Xi8WpNbAlcZ8kPB8XisB7Db7brFlv79BYMM+wOhsLwaroo4cHh04plwGeagZJKiKPS+UYycVlbmkvOcnAtPTpATDKxL5kWCGfGyvBhelt5SlDzLso5ThH7kfLJM7hce6I6uLcZyJwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/4a72b6015c5162e065183f6390d73426/5a190/tc.png\"\n        srcset=\"/static/4a72b6015c5162e065183f6390d73426/772e8/tc.png 200w,\n/static/4a72b6015c5162e065183f6390d73426/e17e5/tc.png 400w,\n/static/4a72b6015c5162e065183f6390d73426/5a190/tc.png 800w,\n/static/4a72b6015c5162e065183f6390d73426/c1b63/tc.png 1200w,\n/static/4a72b6015c5162e065183f6390d73426/afa26/tc.png 1258w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>Time Complexity</h3>\n<ul>\n<li>split: O(N) ; N은 문장의 길이</li>\n<li>sorted: O(klogk) ; k은 dictionary의 단어의 갯수</li>\n<li>for loop: O(WK) ; W는 문장의 단어의 갯수, K는 dictionary의 단어의 갯수</li>\n<li>compare: O(M) ; M은 접두사의 길이</li>\n<li>find: O(p) ; p는 단어의 길이</li>\n<li>append: O(1)</li>\n<li>join: O(N) ; 단어의 갯수</li>\n</ul>\n<p>최종적으로 O(N + klogk + WKM + N) = O(WKM)이다.</p>\n<h3>Space Complexity</h3>\n<ul>\n<li>O(N+K) ; N은 문장의 길이, K는 dictionary의 단어의 갯수</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n\n- 1 &#x3C;= dictionary.length &#x3C;= 1000\n- 1 &#x3C;= dictionary[i].length &#x3C;= 100\n- dictionary[i] consists of only lower-case letters.\n- 1 &#x3C;= sentence.length &#x3C;= 106\nsentence consists of only lower-case letters and spaces.\n- The number of words in sentence is in the range [1, 1000]\n- The length of each word in sentence is in the range [1, 1000]\n- Every two consecutive words in sentence will be separated by exactly one space.\n- sentence does not have leading or trailing spaces.\n</code></pre>\n<ul>\n<li>시간복잡도는 O(10^6)+O(1000log1000)+O(10^8)+O(10^6) = O(10^8)이다.</li>\n<li>공간복잡도는 O(w+k+n)=O(1000+1000+10^6)=O(10^6)</li>\n</ul>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/replace-words\">LeetCode</a></li>\n<li><a href=\"https://docs.python.org/3/library/heapq.html\">Heap Queue</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L523ContinuousSubarraySum/"}},"staticQueryHashes":[],"slicesMap":{}}