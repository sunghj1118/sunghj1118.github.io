{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L2974Minimum Number Game/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"2974. Minimum Number Game","date":"June 07, 2024"},"html":"<h2>문제 설명</h2>\n<p>배열이 주어졌을 때, 앨리스와 밥이 번갈아가며 가장 작은 숫자를 하나씩 배열에서 없애고, 이후 반대로 밥과 앨리스가 새로운 배열에 순서대로 하나씩 추가한다. 최종 배열을 출력해라.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA20lEQVR42qWSiQqEMAxE+/9/KYoHrUfX+5zdCRuR4sKChYdpmk5zaKIoAonjWL5FUeDJMs45ZFmGPM/hvcc0TRiGQaA9jiPmeZZ913Xo+17QGN0TxhlmRDFSVRXKskRd1x/xF5qm+doe67pi27aTfd+F0GfSNJUyrXUiaq09M2jbVqD9d8m8zEvM4DgO4VEP2SOup0KnYJIk0myWxSyVZVmEq499uvPrGZMybDqn+QtWENo6YU6VPv0jKGo4BH2RL3BS2kudZGiHcVdEkOoqqiXdoefMTH20r2W/AYuGDwlenMn2AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2974\"\n        title=\"\"\n        src=\"/static/c00d0495428184f856939d0952cdad96/5a190/2974.png\"\n        srcset=\"/static/c00d0495428184f856939d0952cdad96/772e8/2974.png 200w,\n/static/c00d0495428184f856939d0952cdad96/e17e5/2974.png 400w,\n/static/c00d0495428184f856939d0952cdad96/5a190/2974.png 800w,\n/static/c00d0495428184f856939d0952cdad96/c1b63/2974.png 1200w,\n/static/c00d0495428184f856939d0952cdad96/29007/2974.png 1600w,\n/static/c00d0495428184f856939d0952cdad96/fe83d/2974.png 2262w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 해설</h2>\n<p>제일 작은 숫자를 지속적으로 찾아야 함으로서 heap 자료구조를 사용하는게 좋을것 같다. 주어진 num 배열을 우선 heap으로 변환하여, 순차적으로 하나씩 차감하고 새로운 배열에 추가한다.</p>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">import heapq\n\nclass Solution:\n    def numberGame(self, nums: List[int]) -> List[int]:\n        heapq.heapify(nums)\n        arr = []\n\n        while nums:\n            Alice = heapq.heappop(nums)\n            if len(nums) > 0:    \n                Bob = heapq.heappop(nums)\n                arr.append(Bob)\n        \n            arr.append(Alice)\n        return arr\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABoElEQVR42nWSzXLTQBCE981z4TE45AgHngAOueTIAQoKqHKROA4uO7JsWf8rrdToWzLCSRypunq1muntmR23rVL92t0oq3OFPqjv+xkhBI3jqHPPMA6RP6c/dfHlrd58u9S7249yVVPrIU1UVqWapolo23bm1wX/7f8u/uj97Sd9uLvS9cNXuWEYVJWliqKIAl3XyXs/gz2YOFzDI+/4H6ePI2GxWGh1t1KRF6rrWlVVzeAg3Ha+0+FwUNu0TwQQp3wQJri6a/T95ofuN/da5WslU/m7ZKckSZSmaRSNLoNXlmeqfBnX1mcqMpewC0NQ66eE6Ufbe3V9F4MMXEws87E8nDwv+YkgwUMYzjb+eRKxvvXzBJyLcxb4muBpAo7pKaAVfJ/mzoJ2WjndNr3bbrcRm81G+/0+7q3X6yhUPk4EDLgwm9e5ZBM8HRmCl8tl5DzPlWXZC0FcGtvlzA7pC2ubNRhn/OMAuyBuHLbDbc/yHc74MPsws8gaJtjKA7QAh8fjMTonhm8YcWelsmlsQiTgAgaUxnDDCAIOph0wlf0F7rPzFkqRJzcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/577f151b2a483e0f14d0f0872c15eb7b/5a190/tc.png\"\n        srcset=\"/static/577f151b2a483e0f14d0f0872c15eb7b/772e8/tc.png 200w,\n/static/577f151b2a483e0f14d0f0872c15eb7b/e17e5/tc.png 400w,\n/static/577f151b2a483e0f14d0f0872c15eb7b/5a190/tc.png 800w,\n/static/577f151b2a483e0f14d0f0872c15eb7b/c1b63/tc.png 1200w,\n/static/577f151b2a483e0f14d0f0872c15eb7b/0d0e4/tc.png 1230w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>Time Complexity</h3>\n<ul>\n<li>heapq.heapify(min_heap)은 O(N) 시간이 소요된다. 이때 N은 nums 배열에 있는 숫자 갯수다.</li>\n<li>heappop는 O(logN) 시간이 소요된다.</li>\n<li>append는 O(1) 시간이 소요된다.</li>\n</ul>\n<p>N에 따라 scaling up이 됨으로 N * (O(logN) + O(1)) = O(NlogN) 시간이 소요된다.</p>\n<h3>Space Complexity</h3>\n<ul>\n<li>nums 배열에 있는 N개의 숫자에 따른 O(N) 공간이 필요하다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n\n2 &#x3C;= nums.length &#x3C;= 100\n1 &#x3C;= nums[i] &#x3C;= 100\nnums.length % 2 == 0\n</code></pre>\n<ul>\n<li>시간복잡도는 O(NlogN)이므로, N은 최대 100이다. O(100log100)에 대하여 최악의 경우에 최대 200번의 연산이 필요하다.</li>\n<li>공간복잡도는 O(N)이다. N은 최대 100이다.</li>\n</ul>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/minimum-number-game/\">LeetCode</a></li>\n<li><a href=\"https://docs.python.org/3/library/heapq.html\">Heap Queue</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L2974Minimum Number Game/"}},"staticQueryHashes":[],"slicesMap":{}}