{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L1530NumberofGoodLeafNodesPairs/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"1530. Number of Good Leaf Nodes Pairs","date":"Invalid date"},"html":"<h1>문제 설명</h1>\n<p>두개의 leaf node 사이의 거리가 k 이하인 경우의 수를 구하는 문제이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 84%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAABeElEQVR42qWUi46CQAxF5///Tk120ShG5SEIIvJQVOxymsyGNWziY5Jrh9rcaXs7Y9zlUr6+HZnP5zKZTMR1XZnNZjKdTtU6jiOj0UjteDyWqqpkaJVlKWVTianzrRRZKH4Qiud5HXxZrVYSRZH4vi95nivJ6XRSe7vdBgnbtpX2fu8Iq1yOeSZZlukp+/1e0jRVInyQnM9naZpGLpeL1HWt5EVRaPzxeNQY/MSZJEk1q2i77bKKZbfbSRAEivV6rS1YLBay2XiaMQhDW43X+TddbChxHOtBhmySJPkFhPj6lmzvXTlaVgf2Q2AZfvigNwQ/Wotnl6H54L9mv7oMRBY093q9fkZoN6hIr2jsR4T0h6yQnCyxjIdt/suEh8NB1ewv5g+8RchAMpx9UciSfr5FaMfm8Wq9Q/ZHFPrIEJPdR6IgANlZYVCbPX5gv58dbsMd5NliuClZn6HepbfWqm8PAY8+rCEYUoDifSJeFAv+Q3mqsQRDhD9C+S42G+f50QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1530\"\n        title=\"\"\n        src=\"/static/9d42b0f37c817b8e81a9d1b77d7fc84f/5a190/1530.png\"\n        srcset=\"/static/9d42b0f37c817b8e81a9d1b77d7fc84f/772e8/1530.png 200w,\n/static/9d42b0f37c817b8e81a9d1b77d7fc84f/e17e5/1530.png 400w,\n/static/9d42b0f37c817b8e81a9d1b77d7fc84f/5a190/1530.png 800w,\n/static/9d42b0f37c817b8e81a9d1b77d7fc84f/c1b63/1530.png 1200w,\n/static/9d42b0f37c817b8e81a9d1b77d7fc84f/248b0/1530.png 1316w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<h2>풀이</h2>\n<pre><code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countPairs(self, root: TreeNode, distance: int) -> int:\n        # find distance between every pair?\n        self.result = 0\n\n        def dfs(node):\n            if not node:\n                return []\n            \n            if not node.left and not node.right:\n                return [1]\n            \n            left = dfs(node.left)\n            right = dfs(node.right)\n\n            # count good pairs\n            for l in left:\n                for r in right:\n                    if l+r &#x3C;= distance:\n                        self.result += 1\n            \n            # return distances of leaf nodes from curr node\n            return [d+1 for d in left+right if d+1 &#x3C; distance]\n\n        dfs(root)\n        return self.result\n</code></pre>\n<ul>\n<li>self.result를 선언하여 결과를 저장한다.</li>\n<li>dfs 함수를 정의한다.\n<ul>\n<li>node가 없으면 빈 리스트를 반환한다.</li>\n<li>node가 leaf node이면 [1]을 반환한다.</li>\n<li>left, right에 각각 dfs(node.left), dfs(node.right)를 저장한다.</li>\n<li>left, right의 각각의 요소들을 더하여 distance보다 작은 경우 self.result에 1을 더한다.</li>\n<li>leaf node까지의 거리를 반환한다.</li>\n</ul>\n</li>\n<li>dfs(root)를 실행하여 결과를 반환한다.</li>\n</ul>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABw0lEQVR42qVT207bQBD1VyP1E/oBFX2nn9FHhPpSKl5oRRxE3RAFx1m83vvNh5mFkCpClSpWPtrxjufM7PhM04oOK7lBSqki5/yKeZ5xvHIu6PsB96s1hkeBj9df8OHHKU4uP6EzGzQ7ITDKEdZaaK3hnKs2g0mPFydxzle/9wHfd79w3l/h/OEKKlo0xhjK2EOOsmaPXGlMCCFQgK9gYn6PMb5Z9SEb0HR/OrTLFtttj+VygdtFi3Z9C6knGG1q1dwKpRSmaarkTCwl+akYpi+UhMHJGjFI9CtCr7G4G7B+ENiNA5TRNYDBJKWU176yzRVzouN2NJwtp1Kvm/MhEwft8c9rHhPOc4GPGdonvHdVQswZG5nw7S4+y6Kw4/9xIETBcpvx9aZUB93+nRUS4e8h4fNFxtklsBgA+j8kdoC7YKhw+4K3bN5N2BfCPSwZkk5u+oKfPdCJjNVjxv0ESIoYDfWXAkabK/a20BH00DcFQsW/CKlMQ1rzTpGgSf1OI3iDGGhaSDrOGgRn687wjqfIVJ9/OWc7BL+/MqpotSEnjZIicmMdfRCrkA2dR5ocTXpkBLZJ8GpS9dzQCLLIU3oe0ye6IfOT/VbQCwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/21410975a41437afe7c5fd59b95215e2/5a190/tc.png\"\n        srcset=\"/static/21410975a41437afe7c5fd59b95215e2/772e8/tc.png 200w,\n/static/21410975a41437afe7c5fd59b95215e2/e17e5/tc.png 400w,\n/static/21410975a41437afe7c5fd59b95215e2/5a190/tc.png 800w,\n/static/21410975a41437afe7c5fd59b95215e2/c1b63/tc.png 1200w,\n/static/21410975a41437afe7c5fd59b95215e2/e8e04/tc.png 1270w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>O(N) : 모든 노드를 방문해야 하므로 O(N)이다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>O(h) : h는 트리의 높이이다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\nThe number of nodes in the tree is in the range [1, 2^10].\n1 &#x3C;= Node.val &#x3C;= 100\n1 &#x3C;= distance &#x3C;= 10\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/\">LeetCode</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L1530NumberofGoodLeafNodesPairs/"}},"staticQueryHashes":[],"slicesMap":{}}