{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L1514PathwithMaximumProbability/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"1514. Path with Maximum Probability","date":"August 27, 2024"},"html":"<h1>문제 설명</h1>\n<p>edge는 성공확률으로 이루어진 그래프가 주어졌을 때, 시작접에서 끝 지점까지 가는데 가장 높은 확률로 갈 수 있는 경로를 찾는 문제다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABXUlEQVR42q2U6Y7CMAyE8/4PCEII9cfSK23oAaU33n7eTYUQSCt1K03tJM7EdqY1aWrl63yWw+EgQRDI8XhU/3Q66Xi328l+v5eu6+Qvjxnai3SNkzx34pyTJEkkyzL1m6aRx+Mh0zSpfQ9RrIR1VYpNUyWKokhxXjLGQprnuR4Qx7Gkv3GMsYA55y5SFKWM4yiGDVEULyThsukn2FqrgYCx9yFl7EEch0JobSbX61VMWRQaTEYE0SvAIiW3bav2fr+v9na76fwzWOv7TgynlGWpE34DqKpKSdmMBXVdr/Z53vskYuSfH+0hJc/z/DHo3e2+rq+ESAIySiftzRnyGoZBJVAsF7SZkAy5eizNRkubCL3OuCl0RumbCCm373sdoCfkQk9f4Xv9Cf5iDBrkJ0D/yBbSVxE/ixnLmp9He/gkBrFhMQxDLRVSL2gsgWRPsK8EAnzI8em5j+Fb/gb/KI32r63sJAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1514\"\n        title=\"\"\n        src=\"/static/ed4d34e3853c9bdd0badf56aa247a85a/5a190/1514.png\"\n        srcset=\"/static/ed4d34e3853c9bdd0badf56aa247a85a/772e8/1514.png 200w,\n/static/ed4d34e3853c9bdd0badf56aa247a85a/e17e5/1514.png 400w,\n/static/ed4d34e3853c9bdd0badf56aa247a85a/5a190/1514.png 800w,\n/static/ed4d34e3853c9bdd0badf56aa247a85a/c1b63/1514.png 1200w,\n/static/ed4d34e3853c9bdd0badf56aa247a85a/78958/1514.png 1320w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<ol>\n<li>adjacency list를 만든다.</li>\n<li>priority queue(heapq)를 만든다.</li>\n<li>모든 노드의 확률을 0으로 초기화한다. 단, 시작점은 1로 초기화한다.</li>\n<li>다익스트라 알고리즘을 사용하여 가장 적은 거리 대신 가장 높은 확률을 찾는다.</li>\n</ol>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start_node: int, end_node: int) -> float:\n        # create adjacency list\n        graph = [[] for _ in range(n)]\n        for (a,b), prob in zip(edges, succProb):\n            graph[a].append((b, prob))\n            graph[b].append((a, prob))\n        \n        # initialize probabilities\n        probabilities = [0] * n\n        probabilities[start_node] = 1\n\n        # pq to store (probability, node)\n        pq = [(-1, start_node)]\n\n        while pq:\n            prob, node = heapq.heappop(pq)\n            prob = -prob\n\n            if node == end_node:\n                return prob\n\n            if prob &#x3C; probabilities[node]:\n                continue\n            \n            for neighbor, edge_prob in graph[node]:\n                new_prob = prob * edge_prob\n                if new_prob > probabilities[neighbor]:\n                    probabilities[neighbor] = new_prob\n                    heapq.heappush(pq, (-new_prob, neighbor))\n        \n        return 0\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABp0lEQVR42oVSPW/UQBC9n0xBhSjo+AspQklFg0RBmSCKSKSAgISEDuPAKU7IOfHZ+/01j529s885hBhp/HZ3dt88jd8COVz0+Nk32JgBKSaEGBFCKElEmEfM9dt1i6HtcXbzGU8+HeHZxTFq2ZT6gj8pJfR9j2EYoLWGtRbeezjrCs5Jec1nMUT0TqISV6hFAxPdnpBjvV7j8rLOpBt03T3au6xCCSilSgNOIURWGIsAVp8o7aXvek6Eq18N6u8rXF3f4+u3H1hWS9z2LZRU0MbAOQcpZSHkNZ9bb5EyE+2UT4S8cS7C2whjA1xI5Ywf+6yE8X/xF+Hh8H3m6MzDB4ezPNw/IOS5MIZIUNbjtCI8PwHOV7R7MCbNcLv+B+HYkXC6DHj8Bnj6lvDoNeF9neuEqT7imHO1EyHPSVjCjSC8uog4/pDxC+HFecLLj4R3VcJqQ/g9JFR3hKZPaCWVNGH/mxdzw8r854TSMEbDGwmrJVxG70ypSWUgpM53TLkndzn36kTIM2SfKSULdtnobPau22wbia3pZa7p7E2VLcQeZSsx4Rh/AAiAVNo4hpE8AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/f1c7d061f39f1a10b4a398d93dd0e173/5a190/tc.png\"\n        srcset=\"/static/f1c7d061f39f1a10b4a398d93dd0e173/772e8/tc.png 200w,\n/static/f1c7d061f39f1a10b4a398d93dd0e173/e17e5/tc.png 400w,\n/static/f1c7d061f39f1a10b4a398d93dd0e173/5a190/tc.png 800w,\n/static/f1c7d061f39f1a10b4a398d93dd0e173/c1b63/tc.png 1200w,\n/static/f1c7d061f39f1a10b4a398d93dd0e173/78958/tc.png 1320w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>O(ElogV) ; E는 edge의 개수, V는 vertex의 개수</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>O(V) ; V는 vertex의 개수</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n2 &#x3C;= n &#x3C;= 10^4\n0 &#x3C;= start, end &#x3C; n\nstart != end\n0 &#x3C;= a, b &#x3C; n\na != b\n0 &#x3C;= succProb.length == edges.length &#x3C;= 2*10^4\n0 &#x3C;= succProb[i] &#x3C;= 1\nThere is at most one edge between every two nodes.\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/path-with-maximum-probability/\">1514. Path with Maximum Probability</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L1514PathwithMaximumProbability/"}},"staticQueryHashes":[],"slicesMap":{}}