{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L2924FindChampionII/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"2924. Find Champion II","date":"November 26, 2024"},"html":"<h1>문제 설명</h1>\n<p>이 문제는 DAG 구조의 그래프에서 a->b로 가는 edge가 주어지면, a가 b보다 강하다는 뜻이 된다. 그렇다면 이때 가장 강한 노드를 찾는 문제이다. 단, 여러개의 노드가 가장 강할 경우 -1을 반환한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 85.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAACAElEQVR42o2UW5OiQAyF+f+/zSrXhx28KwiK0ggqoHjL+qU3M/MyNVp1qjvd5OTk0gZhOJT+n4GMx2Pp9Xry8fFX+v2+YjgcyuFwEH7P51Pe+QVtXUl9dFK9HLfbrRyPR0nTtWRZJmVZKq7X69ukwbl2cioTdUzTVPI8lyiKJUkS2e/3stvt5HQ6yeVykaZppG3bT5zPZ4XZBAyiOJGiKOXyusARoBLnpmlVHeCM9L+DMwN+SogynFEAiAiBj9zox0S3+667/g/Sqc3e/O73uwRxHMtgMJAwDF+NmWhzqCXp291oNJLJZCLT6VQWi4XM53Pdc75cLnUfRZESB0i3NKkfaqwB1gTb/wZtynq91gagAGDTYeecrqilMQRjJfBqtVJF2KAo9ipKCfmgrmt1hIDOApRSEwO1Yn08HrrebrfPO/acK6FXsVMS0sdGMc2qquoVvVBwb3Np37Ly7Waz0cYqIalxSUFtnvzINEpIBjZrNoc2FZYddtd1npDaUDfqQjTnCg0AGWptsLFRBwl7ziiTqYdYCT2J0xoR5d03++PTIxqKIAOW+vcmGLi3spgAe3746Ush/9lspikzpICh9unwlnMdcDKJYz8u2LYy5OxpjCokd8jy3KlTlvm5sxGCHAfOqa9lYspMnf0jBcjHyYpLPf2wfo2KnaPC5u2nGv4D5jsUXiTvSYcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2924\"\n        title=\"\"\n        src=\"/static/dc3730aee40fb9ec299bf47f0d011e06/5a190/2924.png\"\n        srcset=\"/static/dc3730aee40fb9ec299bf47f0d011e06/772e8/2924.png 200w,\n/static/dc3730aee40fb9ec299bf47f0d011e06/e17e5/2924.png 400w,\n/static/dc3730aee40fb9ec299bf47f0d011e06/5a190/2924.png 800w,\n/static/dc3730aee40fb9ec299bf47f0d011e06/1ac29/2924.png 1022w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<p>이 문제를 풀기 위해서는 가장 강한 노드가 지는 경우가 없을것이라 생각하고 이를 0으로 만들어야 한다고 생각했다. 따라서, 모든 edge에 대해서 도착 지점이 발생할때마다 +1를 딕셔너리에 추가하는 형식으로 했다. 다만, 이는 그래프가 복잡해지고 가장 강한 노드조차 한번 정도는 지는 경우에 대해서는 처리하지 못할것이다.</p>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        node_dict = dict.fromkeys(range(n), 0)\n        for edge in edges:\n            u,v = edge[0],edge[1]\n            node_dict[v] += 1\n        \n        # if there is a single node with value 0, return it's key, else return -1\n        zero_keys = [key for key,value in node_dict.items() if value ==0]\n        return zero_keys[0] if len(zero_keys) == 1 else -1\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 69%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACVklEQVR42o2Tz2tTQRDH8wcL3nrSg3hTPIgI4kkQvdSLCpYWKy1VrKD4I7SltTbW2qRJmpe8fb9234/9OLM1aSgVXJi3M/tmv/Od2ZlWPxuxO/rJaRbR1A1VXVHX9UyapmF+qX16OuL3cQ8TGRYP37Dw+T7XvzzkSWeZVpKlHPe7TExMnudkWRZ2FWstzrkLgJ4kSYljg80tH4ZbAehpZ4W3g6+0vDg460jFSS9774Mou6qqKIpidn4Z44urVZYlB50D9n/sSypDhsMB3e4x4/E4sJ1MJqRpGsBVV+YKrrYGcqWjbEoa31CLtCqJevSrRzSMGfQj2tv7fGtvBWC9rGCaujLTAMpYdd2TJCHNJbPmrCwaKACmiaQ8cRhTEqf6MJKeMLBSCpWyKvmfFQCntfFacPnkpdiiqD6V8BjeB/H/kBlgUP5GOElg7eA8Yu5qBvE0nSnwBVZz92cMq6rmxMCLbc9i2/P+UF5e0t4+qfl06MIVPVP2qk/ZNv7M9nPsW9PIq3vwahdur8PV53BnA+5teB5vWpb0fA3aPehEMCnO2V1aQ+S5V7/Dyx3P3XewsATXVuDRR8/NFcsVCXBr3bMsQW+8hp2B1hpGGTzYhGdtiIs5QC9tEOUwTNXJczSuGIpzlDV0xyV9OR8kNd1JRV/qfBTJHp/57A1KOqMmsJ49itbQFtJjmSFLY6zspU2DbXND5eSfnBd5IrqMpOxW+k91VyTB19k8dEtrOvBFYaWRC2nkjNgYcm1caWojI1lIYxuTBNvKdBhpaG1yJ1MWdBkA58qA8wcswzJQFY6JnQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/0e4a20bd1f054a5c6f02d7f4e5627561/5a190/tc.png\"\n        srcset=\"/static/0e4a20bd1f054a5c6f02d7f4e5627561/772e8/tc.png 200w,\n/static/0e4a20bd1f054a5c6f02d7f4e5627561/e17e5/tc.png 400w,\n/static/0e4a20bd1f054a5c6f02d7f4e5627561/5a190/tc.png 800w,\n/static/0e4a20bd1f054a5c6f02d7f4e5627561/709cb/tc.png 1034w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>O(n+m) : n은 노드의 개수, m은 edge의 개수이다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>O(n) : n은 노드의 개수이다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n1 &#x3C;= n &#x3C;= 100\nm == edges.length\n0 &#x3C;= m &#x3C;= n * (n - 1) / 2\nedges[i].length == 2\n0 &#x3C;= edge[i][j] &#x3C;= n - 1\nedges[i][0] != edges[i][1]\nThe input is generated such that if team a is stronger than team b, team b is not stronger than team a.\nThe input is generated such that if team a is stronger than team b and team b is stronger than team c, then team a is stronger than team c.\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/find-champion-ii/\">2924. Find Champion II</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L2924FindChampionII/"}},"staticQueryHashes":[],"slicesMap":{}}