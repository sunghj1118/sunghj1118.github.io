{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L1110DeleteNodesAndReturnForest/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"1110. Delete Nodes And Return Forest","date":"July 17, 2024"},"html":"<h1>문제 설명</h1>\n<p>하나의 이진 트리에서 몇개의 노드들을 지우면 생기는 여러개의 이진 트리를 반환하는 문제다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 79.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABXUlEQVR42p1Uy26EMAzk/7+OA0gcoBwKLAdeCe+nm3HXiKKuliXSyI5JxvHEwXqkKQVfIXmeR67r7tb3fXIch2zbpiAIOBaGIWFs20bHgXld19SMLVlTm1GnU4qTByVJQlEUMVme5zSOI3Vdx7bvexqGgV6NZVlpXVeytCpJVQVpk0FrTUVRMJRSnLVtW2qahm39XLMsy0tiq6oUn6aqqp0MflmaREozEMuyjNcBIAUkCbATYuNxMeZCLDFJID4s9gAiiehqTdPEAegjWgmwGMA3iR19ALr9KRn6vNPlk2FJCSA8Z7tFuF+7Iev+KeEW4WC0G42W4k/zfJ8QJ+qM0CBC2f0wsr+eXsNlQpQ6G6J5Xn7tE7cJ0ZRR9M0vA7eNS5K+QwfIK5F2eUuIG47jmPttNtqd8fEJcZLU/HGQHRqi0QUgRBwND/9KB3Bj4y8jDx9zbAYJSFGqkF8h/AG0huJ6GuWBfQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1110\"\n        title=\"\"\n        src=\"/static/3b5a2cbae8fc3b7f7170af1e8b22fd6c/5a190/1110.png\"\n        srcset=\"/static/3b5a2cbae8fc3b7f7170af1e8b22fd6c/772e8/1110.png 200w,\n/static/3b5a2cbae8fc3b7f7170af1e8b22fd6c/e17e5/1110.png 400w,\n/static/3b5a2cbae8fc3b7f7170af1e8b22fd6c/5a190/1110.png 800w,\n/static/3b5a2cbae8fc3b7f7170af1e8b22fd6c/c1b63/1110.png 1200w,\n/static/3b5a2cbae8fc3b7f7170af1e8b22fd6c/bb072/1110.png 1318w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<ul>\n<li>to_delete_set에 to_delete를 저장한다.</li>\n<li>dfs 함수를 정의한다.\n<ul>\n<li>node가 None이면 None을 반환한다.</li>\n<li>node.val이 to_delete_set에 있는지 확인한다.</li>\n<li>is_root가 True이고 is_deleted가 False이면 forest에 node를 추가한다.</li>\n<li>node.left와 node.right에 대해 dfs를 호출한다.</li>\n<li>is_deleted가 False이면 node를 반환하고, True이면 None을 반환한다.</li>\n</ul>\n</li>\n<li>root와 True를 dfs에 전달한다.</li>\n<li>forest를 반환한다.</li>\n</ul>\n<h2>풀이</h2>\n<pre><code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: Optional[TreeNode], to_delete: List[int]) -> List[TreeNode]:\n        def dfs(node, is_root):\n            if not node:\n                return None\n            \n            is_deleted = node.val in to_delete_set\n\n            if is_root and not is_deleted:\n                forest.append(node)\n            \n            node.left = dfs(node.left, is_deleted)\n            node.right = dfs(node.right, is_deleted)\n\n            return None if is_deleted else node\n        \n        \n        # need to find the children that are cut off by deleting a particular node\n        # if that node is a root, we need to add it to the forest\n\n        to_delete_set = set(to_delete)\n        forest = []\n\n        dfs(root, True)\n        return forest\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2ElEQVR42n2TS2/UMBSF57+yYY/EhjWLskJCsOoSia4BCYlHFzxEEQKxQO1URdNJp51KQ5qXY8dJbH/YbpPOCMqVrnIcHx/flyeq08wvzliJC7quG11rTdu2/MuyLOdkcUqZVTyc7nDn2yPufn/MQq6YOOeoRY2SiqZpog+Cwa21BM66GWO9G5x1iE6StRV5KzDOMgmENE1JkjlFkSNlTVmWKKWi13U9RhtwEAoWLomX4cZ1sCiYJAtOkjOW57+ZHs7Ynx6w8GWQUiKEGKMuioK+7yMOl4la0Jo2Sq4J+pSrBpFrf0CTFi2qaWl0M6YdBC6j2KxlEBmENiIMof/PBqHwse4mzppgXKwdWrfeXnqSw3l1ve9uEgwgdsxdUwO0ce34lcKD97D9BZ58hk9z6Ax/yW5EOKTVX2W+Kjt+Lju2v8L9Xbj1FLbewL0XcPuZF96DH0vIG5C+vE2/EWGooUHqnkw5cmU4zS2vpz2vDh3vjizP9y0fji1vPX55YNk9MvHfx5nhOHPMUuO7zWZTwoiEjiolfVc1faf8iPhxaWuPa1ot6Lwbo/y+wsQ9z/Fc3chxEkbBqqrivA1zV5QVlX9BeV5EnPlvdoVLzxW19A+g8iPWxLOD4B+wpJ3afJN9UwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/cde2b4164d5da6dafd7b1f2d786ac3e0/5a190/tc.png\"\n        srcset=\"/static/cde2b4164d5da6dafd7b1f2d786ac3e0/772e8/tc.png 200w,\n/static/cde2b4164d5da6dafd7b1f2d786ac3e0/e17e5/tc.png 400w,\n/static/cde2b4164d5da6dafd7b1f2d786ac3e0/5a190/tc.png 800w,\n/static/cde2b4164d5da6dafd7b1f2d786ac3e0/c1b63/tc.png 1200w,\n/static/cde2b4164d5da6dafd7b1f2d786ac3e0/3c492/tc.png 1300w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>O(N) : 모든 노드를 한번씩 방문한다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>O(H) : 재귀 호출 스택에 최대 높이만큼의 공간이 필요하다.</li>\n<li>O(M) : to_delete_set에 최대 M개의 노드를 저장한다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\nThe number of nodes in the given tree is at most 1000.\nEach node has a distinct value between 1 and 1000.\nto_delete.length &#x3C;= 1000\nto_delete contains distinct values between 1 and 1000.\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/delete-nodes-and-return-forest/\">1110. Delete Nodes And Return Forest</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L1110DeleteNodesAndReturnForest/"}},"staticQueryHashes":[],"slicesMap":{}}