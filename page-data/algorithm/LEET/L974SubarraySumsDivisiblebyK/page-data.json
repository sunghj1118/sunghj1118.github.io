{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L974SubarraySumsDivisiblebyK/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"974. Subarray Sums Divisible by K","date":"June 09, 2024"},"html":"<h2>문제 설명</h2>\n<p>주어진 배열에서 연속된 부분배열의 합이 k의 배수인 부분배열의 수를 확인하는 문제다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA/UlEQVR42p2SiYqEQAxE/f8PFEQFBcXBs71va61IlnEYdne2oUjSx4tJtKIogue5cBwHruuKfN+X2LZtBEGAYRjAdRwHflvWMhr0bY7HI0VRFEiSBFmWYds2rOuKZVnEMn7e01j39n2/gMZUJ+CCEZTnhfhU1/Vo2xZN03zbqqqQpimMMRJT9Pu+v4B0COEDXizLUg4ZM/uny5rnGdRP/dGzV/sWyDLDMMQ0TdIbwrVv1F8GcQPWdX1O2TvLzs+edSJOlb1h6eM4iuhTmpiJdBA3IC8QykdaPvcURGnMRPS1CuoVavHL4jiWAfCQ+rTMG5Bl8N+j1b79Z7oK/AJxswzwEQ++uwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"974\"\n        title=\"\"\n        src=\"/static/fb8bc58bf25c5efbaabcca49562fc533/5a190/974.png\"\n        srcset=\"/static/fb8bc58bf25c5efbaabcca49562fc533/772e8/974.png 200w,\n/static/fb8bc58bf25c5efbaabcca49562fc533/e17e5/974.png 400w,\n/static/fb8bc58bf25c5efbaabcca49562fc533/5a190/974.png 800w,\n/static/fb8bc58bf25c5efbaabcca49562fc533/c1b63/974.png 1200w,\n/static/fb8bc58bf25c5efbaabcca49562fc533/985a9/974.png 1512w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>1차 시도</h2>\n<p>어제 풀었던 부분배열 문제랑 비슷한것 같다. 다만 어제는 부분배열의 합이 k의 배수인지만 확인했는데, 이번에는 부분배열의 수를 확인해야한다.</p>\n<p>또한, 제약조건이 <code>1 &#x3C;= nums.length &#x3C;= 3 * 10^4</code>이므로 해시맵을 써야 하긴 하겠다. 일단 풀면서 생각해보자.</p>\n<p>전에는 나머지들을 계산해서 다시 등장하면, k만큼의 차이가 있어서 무조건 배수라는 논리를 사용했었다. 그러나, 이제는 그 이후도 생각을 해야한다. 즉, 테케에서 연달아 [5, 5, 5] 이렇게 나오는 경우에 어떻게 [[5], [5], [5], [5, 5], [5, 5], [5, 5], [5, 5, 5]] 이렇게 나오는지 생각해봐야한다.</p>\n<h2>풀이 및 해설</h2>\n<h2>Hashmap</h2>\n<ul>\n<li>파이썬이다보니 dictionary로 해시맵 구현. 처음 선언할때 {0:1}으로 선언한다. 이유는 전체가 k의 배수인 경우를 고려하기 위함이다.</li>\n<li>누적합을 저장할 변수를 선언하고, 전체의 갯수를 저장할 변수를 선언한다.</li>\n<li>nums의 각 요소를 순회하면서 누적합을 계산한다.\n<ul>\n<li>누적합을 구하고 k로 나눈 나머지를 구한다.</li>\n<li>음수가 나올 수 있으므로, 나머지를 구할 때 음수가 나오면 k를 더해준다.</li>\n<li>해당 나머지가 해시맵에 존재한다면, 해당 나머지의 갯수 dic[remainder]를 더해준다.</li>\n<li>해당 나머지가 존재한다면 해시맵에 1을 추가하고, 존재하지 않았다면 1로 초기화한다.</li>\n</ul>\n</li>\n<li>최종적으로, 전체의 갯수를 반환한다.</li>\n</ul>\n<p>해시맵을 사용해서 풀어봤다.</p>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">class Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        dic = {0: 1} # initialize dictionary for cases where the sum itself is %k\n        prefix_sum = 0\n        count = 0\n\n        for num in nums:\n            prefix_sum += num\n            rem = prefix_sum % k\n\n            # Adjust for negative remainders\n            if rem &#x3C; 0:\n                rem += k\n\n            # If remainder has been seen before, add the frequency to count\n            if rem in dic:\n                count += dic[rem]\n\n            # Update the frequency of the current remainder\n            if rem in dic:\n                dic[rem] += 1\n            else:\n                dic[rem] = 1\n        \n        return count\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABj0lEQVR42oVT206DQBDl+33wK0zUX9D4bGJ81LYPEIiNUlugYYHdhQWOPdsMaWhThwwThjln57ZBYUqE+y8oW2McRvR9j2EYvKWO44i5NI3B73YHlSu8bj9ws7jD7fIBT+kbgto0+NmmUJWC0QbGGGitvbXWevK5WNuiVCVsY7HYx7hPnvGYvOA9XyEgQDcaSilP0HUd2radVHyME3tNAgatliuEYYhKVYdyGq91XXutqspny7iyLP0BpzIenmEcJg1a1+IzWiBeJ1iX39jlO+RZjizLUBSFJ7fGgnFsi2413ODQux7OOa/SZ1pfcus6uN6h649WAmVAUiYBl3TKloRz55mMMtljGwR4MVQIrzVawJvNBmma+qw5rEuk/xISLAOJ49gPjmTMlKs1n/oZoZTv+3oAskxOmZNNkgRRFHkS2QD+54HsNzETIR0kkBtCAhkK/bKbBNPKsBh3+u33kC+CuWNyS5gVLZULz3/0UblK9DE7+pmp4Eg6ETJYMmGQ3BApTzKUG8VvOZh4xrLkP4ZP9Mk5OdFgAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/86f354d6ccebaa8769a38a050658d4d0/5a190/tc.png\"\n        srcset=\"/static/86f354d6ccebaa8769a38a050658d4d0/772e8/tc.png 200w,\n/static/86f354d6ccebaa8769a38a050658d4d0/e17e5/tc.png 400w,\n/static/86f354d6ccebaa8769a38a050658d4d0/5a190/tc.png 800w,\n/static/86f354d6ccebaa8769a38a050658d4d0/c1b63/tc.png 1200w,\n/static/86f354d6ccebaa8769a38a050658d4d0/8b70b/tc.png 1266w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>해시맵이라 확실히 빠른것을 확인할 수 있다. 그러나, 확실히 이해가 잘 되지 않기 때문에 추후에 다시 풀어봐야겠다.</p>\n<h3>Time Complexity</h3>\n<ul>\n<li>for loop: O(N) ; N은 nums 배열의 길이</li>\n<li>dictionary lookup: O(1) ; dictionary의 길이는 k이다.</li>\n</ul>\n<p>최종적으로 O(N)이다.</p>\n<h3>Space Complexity</h3>\n<ul>\n<li>O(N) ; N은 nums 배열의 길이</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n\n1 &#x3C;= nums.length &#x3C;= 3 * 10^4\n-10^4 &#x3C;= nums[i] &#x3C;= 10^4\n2 &#x3C;= k &#x3C;= 10^4\n</code></pre>\n<ul>\n<li>시간복잡도는 O(10^4). 하나의 operation은 10^-6이 걸린다 생각하면 10^4 * 10^-6 = 0.01초이다. 충분히 빠르다.</li>\n<li>공간복잡도는 O(10^4).</li>\n</ul>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/subarray-sums-divisible-by-k\">LeetCode</a></li>\n<li><a href=\"https://www.datacamp.com/tutorial/guide-to-python-hashmaps\">Python Hashmaps - Datacamp</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L974SubarraySumsDivisiblebyK/"}},"staticQueryHashes":[],"slicesMap":{}}