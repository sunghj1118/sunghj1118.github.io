{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L1248CountNumberofNiceSubarrays/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"1248. Count Number of Nice Subarrays","date":"June 27, 2024"},"html":"<h1>문제 설명</h1>\n<p>주어진 배열에서 홀수의 개수가 k개인 연속된 부분 배열의 개수를 구하는 문제다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABOUlEQVR42p1Si4rCQAzs///dVW2rICL0ZevW2ve26pwTiXiiyLkwZJNdJskkThjF+HFn2Gw2CIIAy2WA+XyO9XoN3/fheR4WiwVc1xV/HEfwXC4XwfNxbGfQlhF2WY4kSRFFkZBlWXb1E1RVBWstuq5D3/cvSf4QlqVBYTIYY5Dn+dUWOBwOApI2TYO2bYWYKMtSLP8WRXH3+Y/JnP3eIEl3QsAKCGtHqYqYpkkwDMM9Rtz+3e6UgX+kQrIfj0fJRLBSWsY+tfey5fP5DIUKTdD/5jjUguI/T+/dFD8S1nWNMAxBSz2olerFJP8ldTjB7XaLNE1lUhSbK6LT5Z0JNKaDIzROqyslLcdxLA+PehKn00mgmvL+SutHeWTKXGZWwxZ1HbgGX2u4Wq3uOmqbJOZdtVVf9+0d4S/e5qYE7Js8ZgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1248\"\n        title=\"\"\n        src=\"/static/f64d562a1ddd8364a97d226db4d5a281/5a190/1248.png\"\n        srcset=\"/static/f64d562a1ddd8364a97d226db4d5a281/772e8/1248.png 200w,\n/static/f64d562a1ddd8364a97d226db4d5a281/e17e5/1248.png 400w,\n/static/f64d562a1ddd8364a97d226db4d5a281/5a190/1248.png 800w,\n/static/f64d562a1ddd8364a97d226db4d5a281/c1b63/1248.png 1200w,\n/static/f64d562a1ddd8364a97d226db4d5a281/248b0/1248.png 1316w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>시도 1</h2>\n<p>이 문제를 풀기 위해서는 subarray를 구하고, 해당 subarray에 홀수의 개수가 k개라면 count를 증가시켜 봤다. 그러나, 시간초과가 발생했다. 아무래도 O(n^3)의 시간복잡도가 문제인 것 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.49999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABDUlEQVR42n2SC3ODIBCE/f//s+2kvuIDOOBwu4dtx8QYxx0U8ON2vaZ1I6awIKcMVcW2bbi6RCLGyXRHigExKpWQckbit1oKGu88YanCbMHGwoVXipl7UkHb3nCfBs5tyJzTX1hhMc2yLJjnBSHIW8UYEenCHLhxRXu7QZKcXDTeh30zZZb+np9lLjztWRUpRHRth6j5DHTOsYIdmmn5SmbL80DVgmHsMM1TBVjFRzXruv5bTrR0JWVWjsBM8ML9wzxAcjhBGxGpp1q471QIcnRh4ats6Jnh59cHLLJjZ9QMj5XsFrWOzxWusgPBe/qe0bc9QpRHoL08tAar2P9qOrVNInRjq6iUmvurnv0BQ9DCkb1g8p8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"test\"\n        title=\"\"\n        src=\"/static/936fc9e060cb764faa0e8426ae3bf330/5a190/test.png\"\n        srcset=\"/static/936fc9e060cb764faa0e8426ae3bf330/772e8/test.png 200w,\n/static/936fc9e060cb764faa0e8426ae3bf330/e17e5/test.png 400w,\n/static/936fc9e060cb764faa0e8426ae3bf330/5a190/test.png 800w,\n/static/936fc9e060cb764faa0e8426ae3bf330/c1b63/test.png 1200w,\n/static/936fc9e060cb764faa0e8426ae3bf330/29007/test.png 1600w,\n/static/936fc9e060cb764faa0e8426ae3bf330/7d62e/test.png 2368w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABIklEQVR42o1R2Y6DMBDr//9auQ8VKFK5yxMPQAEBYTYeGrZaVSuQLHsmHickl+31IlGWEgWJSnLyYD7zTdNE4zgeLISgy7rMNHUdDW3LWOUCyd6Zb9s2DurkfCtn98B1pUE2F8nQQpq2N2BQ/BfKsywLz4FRc2BRFJQkCeV5Ts/nkxnIsoxRVRV7gFJeD3pYh4Yfs3Vd86k50Pd90jSNTNMkx3GYUVuWRbZtk2EYXOu6zj2sgz+9cRzvgTiqGgIDruseQ9gMPdToK5/aEPX1ev0NxAnDMGTcbjcKgoCiKGKNX4FGKGporN/vd/I8j3vQ4DRN90Bc8Pp+kG+Y55lfse971sr/Oaf08SjDMLAZwBV8g1pTvk+v0kdg0zT/hp0FAn8AkxL1UBMOlhwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"timeex\"\n        title=\"\"\n        src=\"/static/e32c39953ab19d1dcda8471cd426850d/5a190/timeex.png\"\n        srcset=\"/static/e32c39953ab19d1dcda8471cd426850d/772e8/timeex.png 200w,\n/static/e32c39953ab19d1dcda8471cd426850d/e17e5/timeex.png 400w,\n/static/e32c39953ab19d1dcda8471cd426850d/5a190/timeex.png 800w,\n/static/e32c39953ab19d1dcda8471cd426850d/c1b63/timeex.png 1200w,\n/static/e32c39953ab19d1dcda8471cd426850d/d4377/timeex.png 1294w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이</h2>\n<p>for loop 두개에다 sum까지 쓰면 O(n^3)이 되어 시간초과가 발생한다. 따라서, for loop를 한번만 사용하여 문제를 해결해야 한다.</p>\n<p>이를 해결하기 위해, defaultdict를 사용하여 홀수의 개수를 저장하고, 해당 개수가 k개가 되는 경우를 찾아야 한다. 이렇게 하면, O(n)의 시간복잡도로 문제를 해결할 수 있다.</p>\n<pre><code class=\"language-python\">class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        count = defaultdict(int)\n        count[0] = 1\n        curr_sum = 0\n        result = 0\n\n        for num in nums:\n            curr_sum += num % 2 # increment sum by 1 for odd nums\n            \n            # if we've seen the value for (curr_sum-k), add its count to result\n            result += count[curr_sum-k]\n\n            # increment the count for the current count\n            count[curr_sum] += 1\n        \n        return result\n</code></pre>\n<ul>\n<li>defaultdict를 사용하여 홀수의 개수 count를 저장한다.</li>\n<li>count[0] = 1로 초기화한다. 처음부터 끝까지 홀수의 개수가 k개인 경우를 고려하기 위함이다.</li>\n<li>curr_sum을 0으로 초기화한다.</li>\n<li>result를 0으로 초기화한다.</li>\n<li>nums를 순회하면서, curr_sum에 num % 2를 더한다. 이는 홀수인 경우 1을 더하는 것이다.</li>\n<li>result에 count[curr_sum-k]를 더한다. 이는 현재 홀수의 개수에서 k를 뺀 값이 이미 나왔다면, 그 값을 더해주는 것이다.</li>\n<li>count[curr_sum]을 1 증가시킨다.</li>\n<li>result를 반환한다.</li>\n</ul>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABnElEQVR42p2TzU7cMBSF53X7DCx4gb5A4QVatVIrNl2xoPtKpdOq7YAQZAYGhknwf+z45/TamQSYzobe6OrE0c3nY/t6YoPD5cM1bvgK3vuSIYTxPaWE7WCMY7G4AWsYDs4+Ye/bG+x/P8RtW2OSfxBCQAoJY0xJay3ati2Z4dsRgkfXdQg+Yq7v8JtfYSYquNhhkgu44KjmFThnVOjQEnQADhNkgNZ65wRjkLkCrKoFZr/Ocb9qcHG5wHT6A8vlssCklAWcgXklxRlBlVLle+EMzwAUTONhrdA0Bre1AZcKhtwMDp1zGwPp33xmcAOMMZZ5XhKRymu9veLUH8r/BJ0HTi4A18XRyugw78nO5exI4FFffwGOppbGcfz+YocdHXLrgTkD9j8Dr94GvD/ttyBDi8MU6dSoqtYJaxXQkN7LXtejetzJhD+rgK/XCcezgI8/Ez6cerwj4FI8BZJLpQ2UsZCqV7GlXBpoUk11nbNw1sA7XTIES7eqe9zDcls4pxbR1Gu95iYfx3oz3mhucMYYGP1T1w31pB5b6y9oqaOiN7yeAwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/386ad530c068dd85394a6d0ae499663b/5a190/tc.png\"\n        srcset=\"/static/386ad530c068dd85394a6d0ae499663b/772e8/tc.png 200w,\n/static/386ad530c068dd85394a6d0ae499663b/e17e5/tc.png 400w,\n/static/386ad530c068dd85394a6d0ae499663b/5a190/tc.png 800w,\n/static/386ad530c068dd85394a6d0ae499663b/c1b63/tc.png 1200w,\n/static/386ad530c068dd85394a6d0ae499663b/71b12/tc.png 1308w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<p>O(n) ; nums를 한번 순회하면서 count를 증가시키기 때문에 O(n)이다.</p>\n<h3>공간 복잡도</h3>\n<p>O(n) ; defaultdict를 사용하여 count를 저장하기 때문에 O(n)이다.</p>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n1 &#x3C;= nums.length &#x3C;= 50000\n1 &#x3C;= nums[i] &#x3C;= 10^5\n1 &#x3C;= k &#x3C;= nums.length\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/count-number-of-nice-subarrays/\">1248. Count Number of Nice Subarrays</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L1248CountNumberofNiceSubarrays/"}},"staticQueryHashes":[],"slicesMap":{}}