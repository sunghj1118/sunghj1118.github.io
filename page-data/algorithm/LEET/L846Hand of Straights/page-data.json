{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L846Hand of Straights/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"846. Hand of Straights","date":"June 07, 2024"},"html":"<h2>문제 설명</h2>\n<p>배열이 주어졌을 때, 이를 K개의 연속된 숫자로 나눌 수 있는지 판별하는 문제다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.49999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA4klEQVR42pVQSW7DMBDTWwzvm2x5hR3YRqse/f/nsOEEEziHNOiBGM5Iojg0P/4L/tvDe4/zPNF1HYIgQBRF/0IYhojjGGaZHW63Fdu2Yd93DMOApmngnJPatu2zXrm1Vjhh7eN+VVUwTevQ9/3dmRN3FGQ/TZNUgjP2wzg+e4XeG+9nfG9IiqIQu2maIkkS4YRyVj27VgV7nZnjOLCuq9hV1HUtq+R5/iKgefGTd1kaZjfPs7gkKFKWpQiT61y3+ARxuCyLCFCI7hh4lmUvK6qzj4LMkA5VUN1de7q7ZvuX4C+1k/L8+0f0gQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"846\"\n        title=\"\"\n        src=\"/static/6fd0c4f558dbc7cf96c68745e4258347/5a190/846.png\"\n        srcset=\"/static/6fd0c4f558dbc7cf96c68745e4258347/772e8/846.png 200w,\n/static/6fd0c4f558dbc7cf96c68745e4258347/e17e5/846.png 400w,\n/static/6fd0c4f558dbc7cf96c68745e4258347/5a190/846.png 800w,\n/static/6fd0c4f558dbc7cf96c68745e4258347/c1b63/846.png 1200w,\n/static/6fd0c4f558dbc7cf96c68745e4258347/29007/846.png 1600w,\n/static/6fd0c4f558dbc7cf96c68745e4258347/fbae3/846.png 2260w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>1차 시도</h2>\n<p>배열의 길이를 K만큼 나누었을 때의 나머지가 0이 아니라면, 바로 False를 반환한다. 만약 0일 경우 True를 반환한다. 해당 방법으로 Test Case는 모두 해결해냈다. 이렇게 간단할리가 없는데 어떻게 실패할지 예상이 안돼서 일단 제출해봤다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABV0lEQVR42qWSWXLDIBBEOUuMEItAgCIrsuL4w/c/U2dmFKXKcVxO7I+nhaWZpkelnFBrgXcOznl4f4mTcSfzgr9eE0JA7DrEGKH4kYcR5W1ClzrZZJ0XcccbaDEjwvRvrb2CBZmcM1TTNDCtQ6kVH8cDpnnCOM0YXkc6ICKkHqHPcCzaBRhjfkVrjb7vodq2hWkMvHEY0ggXC3ispUV8WEML5c0HMzcEeV4EueQueyEkR9WQrUCHtIask7Btb4r8FBTLItiHL0Ei0sV3dF/Brm9v14rvwIISCnvXusHuZSfonV7R+vL7DlwlFycpl1JQhoJ5nr8T+y8dtQ2jLFtdMvqaUUuVya33HkFFao3DcqAA1qb9i71b8D2S5YShDkgpSezPwO4UR30+n3E6nXA8HrHf7x9imqa1D1lwWd4xjuNTsCi7lJS3crekHoUzUCy2lcvVPgO3zSeU0cUUrxvqrAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/8b3ff261018cee49e8877cb3bee1dacd/5a190/tc.png\"\n        srcset=\"/static/8b3ff261018cee49e8877cb3bee1dacd/772e8/tc.png 200w,\n/static/8b3ff261018cee49e8877cb3bee1dacd/e17e5/tc.png 400w,\n/static/8b3ff261018cee49e8877cb3bee1dacd/5a190/tc.png 800w,\n/static/8b3ff261018cee49e8877cb3bee1dacd/c1b63/tc.png 1200w,\n/static/8b3ff261018cee49e8877cb3bee1dacd/29007/tc.png 1600w,\n/static/8b3ff261018cee49e8877cb3bee1dacd/6274f/tc.png 2098w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>1차 결과</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAu0lEQVR42o2Saw6DIBCEPYwgIMhDpJrUpN7/UFOWaFObKP3xhcfC7DCh4Zzj4KEUnr1CkhJCCKi8ppEx9qFtW8hcX9cVKaWy963RHBOWmaYJ0zjCDgOGC6y18N4XsRDCjWAuzPOM17YhknCFGCOccyexkyDfHc7LUg7XBMkhOb10SPjc0RgDrfVfUMaXDinD5ANizsXlzr4C5UeZ3jrsBwOhJPh+qOu6KtcZMg6le+gsarQpT6cv83uhxhtWB/DLAaBpbwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"w1\"\n        title=\"\"\n        src=\"/static/36ff047e80272a16f16774e84cefa2aa/5a190/w1.png\"\n        srcset=\"/static/36ff047e80272a16f16774e84cefa2aa/772e8/w1.png 200w,\n/static/36ff047e80272a16f16774e84cefa2aa/e17e5/w1.png 400w,\n/static/36ff047e80272a16f16774e84cefa2aa/5a190/w1.png 800w,\n/static/36ff047e80272a16f16774e84cefa2aa/c1b63/w1.png 1200w,\n/static/36ff047e80272a16f16774e84cefa2aa/29007/w1.png 1600w,\n/static/36ff047e80272a16f16774e84cefa2aa/47f6c/w1.png 2206w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n생각보다 간단한 테케에 막혔서 틀렸다. 이유는 배열을 정렬하지 않았기 때문이다. 따라서, 배열을 정렬한 후 위와 같은 방법으로 풀이하였다.</p>\n<p>문제를 다시 읽어보니까, 배열을 정렬할 수 있다면 참을 반환하라는 조건이 있기 때문에, 이미 정렬되어 있는 배열은 다시 정렬할 수 가 없다. 따라서, 정렬이 되어 있는지 한번 검토를 할 필요가 있다.</p>\n<h2>2차 시도</h2>\n<ul>\n<li>배열이 K개로 나눠지지 않는 경우에는 바로 0 반환한다.</li>\n<li>이후, 배열이 이미 정렬되어 있는 상태라면 0을 반환한다.</li>\n</ul>\n<p>여러 배열이 존재할 경우 성공할지 모르겠어서 긴 배열을 만들어서 테스트해봤다. 일단 모든 테케는 통과했다.</p>\n<h2>2차 실패</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAABk0lEQVR42qWU6ZKbMBCE9TCA7gswBry2K+//UL092rgqydoptvzjqxFX03NIap5neOfgnIf3/8D7jcfa+6eEEBqyVrlOqOczQkkweoDWpmGMgbUWlj+SteFaa/0NefYQLqVAaWPhc8X1vuH+64b1esOyX5CmEaESPrPewQYPbTSGYfhG3/ctjuMIZfkHuVFjxTwuSBTxFHi82HcdBvng90evELdN0NChNgNSCiTBxwjnJVWm7M1LV88Ea610KHWi6Mo6jsI8ok6FYpZ1M+3FI4KCGFLSCNNrJBeRS8ZIsRAl5e7vdA9gaUDpNKGPBb7M0L5gIF8xH0aHAhNZ+8Qu76cTNs7i9eNKdzNiyvAh0mVs66OEVFtUG2t4Zp0CY5SGcIBlSHPOX10+RIduMG1mlaNIx0F2PnBINaNr7T/R+bNBfoU0xTkL9XG54LwsWIhsw2nizqGgjIBc/wTJTN1vN+z7jm3bmqt3kJKpdV2bG0FSfYfmcGTx/zwx3qGdNhtrliia30R2SXOYudXcf866nyBH2SchOgOdvCyMYgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"w2\"\n        title=\"\"\n        src=\"/static/28126fbfb9f3ab7fe825c8b1b6920e0c/5a190/w2.png\"\n        srcset=\"/static/28126fbfb9f3ab7fe825c8b1b6920e0c/772e8/w2.png 200w,\n/static/28126fbfb9f3ab7fe825c8b1b6920e0c/e17e5/w2.png 400w,\n/static/28126fbfb9f3ab7fe825c8b1b6920e0c/5a190/w2.png 800w,\n/static/28126fbfb9f3ab7fe825c8b1b6920e0c/c1b63/w2.png 1200w,\n/static/28126fbfb9f3ab7fe825c8b1b6920e0c/29007/w2.png 1600w,\n/static/28126fbfb9f3ab7fe825c8b1b6920e0c/7970d/w2.png 1908w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n보니까 기존에 정렬이 되어 있어도 새로운 방식으로 정렬이 가능해지면 안된다. 예시로, [1, 2, 3, 4, 5, 6]는 이미 정렬되어 있지만, [1,3],[2,4],[5,6]으로 나눌 수 있기 때문이다.</p>\n<h2>3차 시도</h2>\n<ul>\n<li>배열이 K개로 나눠지지 않는 경우에는 바로 0 반환한다.</li>\n<li>배열 각각의 원소에 대하여 collections.Counter를 이용하여 각 원소의 개수를 세어준다.</li>\n<li>heapq를 이용하여 각 원소의 개수를 세어준다.</li>\n<li>heapify를 이용하여 정렬된 배열을 만들어준다.</li>\n<li>K만큼 배열을 수행하면서, 연속적인 값이 존재할 경우 원소의 개수를 줄여준다.</li>\n<li>heapq가 모두 소진되면 True를 반환한다.</li>\n</ul>\n<pre><code>import heapq\n\nheapq.heapify(x)  \nTransform list x into a heap, in-place, in linear time.\n\nheapq.heappop(heap)\nPop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0].\n</code></pre>\n<h3>풀이 해설</h3>\n<pre><code>if count[first + i] == 0:\n    return False  \ncount[first + i] -= 1\n</code></pre>\n<p>This condition checks if the current card value (first + i) is available in sufficient quantity. If the count of this card is 0, it means we cannot form a group starting with first because there are not enough consecutive cards. In such a case, the function returns False.</p>\n<p>If the card is available, this line decrements its count by 1 because we are using one instance of this card to form the current group.</p>\n<pre><code class=\"language-python\"># check if count has reached 0\nif count[first + i] == 0: \n    # if 0, need to check if it's the smallest val\n    if first + i != min_heap[0]: \n        # if it isn't, there's an inconsistency hence false\n        return False \n    # if smallest and 0, remove from heap\n    heapq.heappop(min_heap) \n</code></pre>\n<ul>\n<li>Check if the card count is zero after being used to form a group</li>\n<li>Ensure that this card value is the smallest value currently in the heap, else return False as it would be an inconsistency</li>\n<li>If first + i is indeed the smallest value in the heap and its count has reached zero, we remove it from the heap using heapq.heappop(min_heap).</li>\n</ul>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">from collections import Counter\nimport heapq\n\nclass Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        # check if hand is in multiples of groupSize\n        if (len(hand) % groupSize) != 0:\n            return False\n        \n        # count frequencies\n        count = Counter(hand)\n\n        # use a min-heap to process cards in ascending order\n        min_heap = list(count.keys())\n        heapq.heapify(min_heap)\n\n        while min_heap:\n            first = min_heap[0] # get the smallest value\n            for i in range(groupSize): # check consecutive values and decrease if exists\n                if count[first+i] == 0:\n                    return False\n                count[first + i] -= 1\n                if count[first + i] == 0: # check if count has reached 0\n                    if first + i != min_heap[0]: # if 0, need to check if it's the smallest val\n                        return False # if it isn't, there's an inconsistency hence false\n                    heapq.heappop(min_heap) # if smallest and 0, remove from heap\n            \n        # heap has been emptied\n        return True\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABhElEQVR42p1TyU7DMBTMdyBxKIm3hOybkzRFXYQqEQmEhCoO/RRO/AL/O+S5uHIlDoXD+Pl5GY/Hz15WFygfO8RdjigMEUURwjlacM4vIIRA3/fYbndodYvi4wnrryOazxewSMDTWmO5GpHlOdIkRZImSJIEaZqaSAQElzDLMpRlaeaj1w758QHxWw+uZkLf91FXNTabDXSrzeJ8JreoqspsDFWI+/geUkgEfgDaFwQB2O0dgpuFiXSgxwKG6XnC4f2AdtTohx7L5RLjOGIYBnRdZ4jjJEbTNFCRMiqllCcoCS7FCUQo5qZZaax3a2RDgbbXGPrhTFbXtbm+DKUhFaGAUsqAPCZS12OPTlNSYbGYZfsMnHEwxs5wF1MuuPj1oazPhlDMcslkuprZ9LPgrzCEJJkMnqYJ+/3eKKWxfxPahNS1bWvI3TK5FheE1CmKwpQIqSPDqcCpT8a7uTtuc1eARw1NWA+J1I3XjsdxfElI34l+jS0Vymmxm9tI9ehGW/z0oN/5vG7NtlY4gQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"comp\"\n        title=\"\"\n        src=\"/static/9d08d71699a6214f81e661a6f1e3e073/5a190/comp.png\"\n        srcset=\"/static/9d08d71699a6214f81e661a6f1e3e073/772e8/comp.png 200w,\n/static/9d08d71699a6214f81e661a6f1e3e073/e17e5/comp.png 400w,\n/static/9d08d71699a6214f81e661a6f1e3e073/5a190/comp.png 800w,\n/static/9d08d71699a6214f81e661a6f1e3e073/c1b63/comp.png 1200w,\n/static/9d08d71699a6214f81e661a6f1e3e073/ea964/comp.png 1312w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>Time Complexity</h3>\n<ul>\n<li>Counter(hand)는 O(N) 시간이 소요된다. N은 hand 배열에 있는 카드의 개수이다.</li>\n<li>heapq.heapify(min_heap)은 O(M) 시간이 소요된다. 이때 M은 서로 다른 카드의 개수이다.</li>\n<li>heappop과 heappush는 O(logM) 시간이 소요된다.</li>\n</ul>\n<p>모든 카드를 한번씩만 볼 수 있으므로, 전체 시간 복잡도는 O(NlogM)이다.</p>\n<h3>Space Complexity</h3>\n<ul>\n<li>heap에는 최대 M개의 카드가 들어갈 수 있으므로, O(M) 공간이 필요하다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n\n1 &#x3C;= hand.length &#x3C;= 104\n0 &#x3C;= hand[i] &#x3C;= 109\n1 &#x3C;= groupSize &#x3C;= hand.length\n</code></pre>\n<ul>\n<li>시간복잡도는 O(NlogM)이므로, N은 최대 10^4이고 M은 최대 10^4이다. M은 최악의 경우 N과 같기 때문이다. 따라서 O(10^4log10^4)이다.</li>\n<li>공간복잡도는 O(M)이다. M은 최대 10^4이다.</li>\n</ul>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/hand-of-straights/\">LeetCode</a></li>\n<li><a href=\"https://docs.python.org/3/library/heapq.html\">Heap Queue</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L846Hand of Straights/"}},"staticQueryHashes":[],"slicesMap":{}}