{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L2070MostBeautifulItemforEachQuery/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"2070. Most Beautiful Item for Each Query","date":"November 12, 2024"},"html":"<h1>문제 설명</h1>\n<p>이 문제는 2D 배열이 [price, beauty]로 주어진다. 또한, queries 배열도 주어진다. 이때, query의 가격보다 작은 가장 높은 beauty를 가진 아이템들을 찾아 반환하는 문제이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 134.50000000000003%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAABYlAAAWJQFJUiTwAAACkUlEQVR42q2ViY7iQAxE8/+/x3AIxBkIBBKucF+ePDMVtbJIu9JOJOO+XG2X7SZKkrl9fTWt1+tZu922VqtlnU7Hms2mdbtdX0OH0mg0bLVa2acv2m4yWyRjWy5Tm0wmFsexjcdjGw6HNp/PbTqdWpqmlmWZg+R5bovFwoqi+Az4vBX2OM7teDy4wWazcQBkv9/ber32tfr3fD4rud/v9ng83oB5vrZkntp0NnMQbkcDnmV56fnSgbfbrXtVFIdyXthut3PhMrxn7IDL0nhWhhXHUxsMBg40K8ERwufw7XarvLher641R2vtx8PcDQGAQ0BJDOTD31vYT6r9fr9vo9G4HA/ddjKJy8hSB4/gSB6RjNFo5Ibo2Q8NgDInScfj0UM/HA5OA3OALpdLqR8WwZO4I7zNZuuZ1BogzBEA3nztKy6Zs4djp9PJIm7CEB1mTBr+NEfEp3Q4xj6CyNfr5fIbnycFzpT2/wYk5fBwPp+r9KMJA6IR5ojmhMd5ztQji9ikDACliCEePjEQQF0AkgN/ALLJw0BpAEqmdPu/fiFoRGYAItMInUKdUV94i6jNwhpEmMvTChDOVGPUksLGkHUuYF1UAEJvI6KGNcQBcVe3h7wpKeiwzhCcCF8bzR2QH14MPFPYSlCdBjzCM43lGWMwvFNA5oAOKjSt4T0aD/+WGKTyMEkSF7KNxjPG9DJj+OSc+paLuFx9TmK89UBVplRfiIpXe2g8Jyy0uGadNTVFRGiqv19pPVynUwhDXoa6Pg6rgCjqD0vVevADuB5LGYdAGiN6uj4+DgDytEO+2i7kNPwfUX3WHxDEOWQRIOpO/72UiXo6fCiUANWfxtp3QH5IjFpIAKEIXCAYM0ZzPuzlbwUmInHMxSvmAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2070\"\n        title=\"\"\n        src=\"/static/63ca50d5ec2f4143852d2efbeccbe3d3/5a190/2070.png\"\n        srcset=\"/static/63ca50d5ec2f4143852d2efbeccbe3d3/772e8/2070.png 200w,\n/static/63ca50d5ec2f4143852d2efbeccbe3d3/e17e5/2070.png 400w,\n/static/63ca50d5ec2f4143852d2efbeccbe3d3/5a190/2070.png 800w,\n/static/63ca50d5ec2f4143852d2efbeccbe3d3/d7ab4/2070.png 1014w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<ol>\n<li>items 배열을 price를 기준으로 오름차순 정렬한다. 이때, beauty는 내림차순으로 정렬한다. 그렇게 하기 위해선 lambda 정규식을 사용하여 (key=lambda x: (x[0], -x[1]))로 정렬한다.</li>\n<li>prices 배열과 max_beauties 배열을 선언한다.</li>\n<li>items 배열을 순회하면서 price가 prices 배열의 마지막 값보다 크다면 prices 배열에 추가하고, current_max_beauty와 beauty 중 큰 값을 max_beauties 배열에 추가한다.</li>\n<li>queries 배열을 순회하면서 bisect.bisect_right(prices, q) - 1을 통해 가격이 q보다 작은 가장 높은 beauty를 가진 아이템을 찾는다. 만약, 해당 아이템이 없다면 0을 반환한다.</li>\n<li>결과를 반환한다.</li>\n</ol>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\n    items.sort(key=lambda x: (x[0], -x[1]))\n    \n    prices = []\n    max_beauties = []\n    current_max_beauty = 0\n\n    for price, beauty in items:\n        if not prices or price > prices[-1]:\n            prices.append(price)\n            current_max_beauty = max(current_max_beauty, beauty)\n            max_beauties.append(current_max_beauty)\n\n    result = []\n    for q in queries:\n        idx = bisect.bisect_right(prices, q) - 1\n        result.append(max_beauties[idx] if idx>=0 else 0)\n    \n    return result\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 71.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACaElEQVR42o1TW0/UQBTuP/YXiPHy4gvGxAffiM8+SGJiIngJoBiFxAQVZKELLNvdZdttp+3M9Dadz3OmdAOJMU5yem4z3/lmeo4X6QS/Qh+TbA7TNGhIjDFOettai341jUEYRhgHEyih8Hywjjv7T5y8GL6BV1YlrsI5RJaiKAoopaC1RlEWTpdliZurbVtIqSDSFJWusBse4NVoC+ujbewtjuDxBj4ohCAwTYxad6glbYgNF2FhlnVdO8b/Wg5weObj6PchomiOeBFhEgS4nIwR5TGyNEOe5w4sSRJXnM/wcxSablRoVIYKWSJB4nHli/MA4/MpgeU4PZtgcDKEf+5jls6hVXdtBpRSOiAGZD/LcuSSirW1Y8dYnmkNtKyg0xp5WiHJDcq6hWUWVbME+5/lAPnDVMm9lXDylwPLfWRnhb3VAUvA7u+RkNmQNtfCvrHXuu3sPs7iL277XMwB8ruwUzUWX0cWo8TiOASmokKYNdAUj7XFz5nFadSxDFJ6e9oXKgtZdTHmtmTI1b4HwMsfwNtj4PUhsO032D0z+HZJ9rCLbQ6AgynpE+CjDyIAfLkAhosbDPkHrO1ZPN4Cnn62uLdp8eA9sLptSCzuv7NY2bBY3aH8J4uHHyzubgCPSD/bBVZo/9p+R8wBcrPO6Q/HGriiK05Fg0jRlZMSkWwp1iJIapefiZp8Gj9pMUm6M9O0oafpOsHjDwNq6qeqoLGTGQqVo9SSerDTLH1MUb6PqZxt5XK8l6fM6+czpikoihIpTYYg0WTHcQJJs53livKC5rukaRHkExhNzILymsYyzeiMSF3b/AGw5i5g3Izo7gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/7a2b80489c107e71699cc311c34423f3/5a190/tc.png\"\n        srcset=\"/static/7a2b80489c107e71699cc311c34423f3/772e8/tc.png 200w,\n/static/7a2b80489c107e71699cc311c34423f3/e17e5/tc.png 400w,\n/static/7a2b80489c107e71699cc311c34423f3/5a190/tc.png 800w,\n/static/7a2b80489c107e71699cc311c34423f3/d7ab4/tc.png 1014w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>시간 복잡도: O(NlogN + QlogN)\n<ul>\n<li>N: items 배열의 길이</li>\n<li>Q: queries 배열의 길이</li>\n<li>items 배열을 정렬하는 데 O(NlogN)이 걸리고, queries 배열을 순회하면서 가격이 q보다 작은 가장 높은 beauty를 가진 아이템을 찾는 데 O(QlogN)이 걸린다.</li>\n<li>따라서, 총 시간 복잡도는 O(NlogN + QlogN)이다.</li>\n</ul>\n</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>공간 복잡도: O(N)\n<ul>\n<li>prices 배열과 max_beauties 배열을 사용하므로 O(N)이다.</li>\n</ul>\n</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n1 &#x3C;= items.length, queries.length &#x3C;= 10^5\nitems[i].length == 2\n1 &#x3C;= pricei, beautyi, queries[j] &#x3C;= 10^9\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/most-beautiful-item-for-each-query/\">2070. Most Beautiful Item for Each Query</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L2070MostBeautifulItemforEachQuery/"}},"staticQueryHashes":[],"slicesMap":{}}