{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L1382BalanceaBST/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"1382. Balance a Binary Search Tree","date":"June 26, 2024"},"html":"<h1>문제 설명</h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 92%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAABo0lEQVR42q2U646CQAyF5/3fzhg1URMVWJGbFxRQULt+NTVoVvTHdlNnZ4aent7GeZ4vw+FQBoOB9Ho9mUwm0u/3ZTQa6crZeDyW6XQq7+R6vUq+z6WoS3FNlUldJJKmmSRJIlEUSRD8yHq91v3xeFSjy+UiXQIofy6OI1mtwptxegOLZblc3vYrVf4PgkB831fw7XarjjabzZOmaap3iMuyO7M4jvUCIFiyBxCww+Egp9NJqqrSFdbtvZ3B0hVFIfv9XhVDc5DnuardwWC32+kZK8oZamdN04ir61o9gP4f4giTEEF/l2wKcj6f74n/4Nh98xFheZ6noB8Zknjif5T+Rdt5IrcUohOQQhA26ytT9mEYCoVDrAM6AfkBbLFYqHdYYDifz5+Ym8B0Npu9bXRnBhQFNrQNYkVAcETY9t1f0TwBmlj4ZVk+DGDCdFAUG8OPIbcFI4ytN5kUGyvOLYJOhnZplaXZTWALCPmkOO27rxj+JYwe7fXNNOks8zH5a8+1zTEMSYM9BB8BMaJF7HlCeZIoBIoTc8QKME5Y28odj8MvKOp47xehuMMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1382\"\n        title=\"\"\n        src=\"/static/e154a0def9ed88be229184b5f34b9316/5a190/1382.png\"\n        srcset=\"/static/e154a0def9ed88be229184b5f34b9316/772e8/1382.png 200w,\n/static/e154a0def9ed88be229184b5f34b9316/e17e5/1382.png 400w,\n/static/e154a0def9ed88be229184b5f34b9316/5a190/1382.png 800w,\n/static/e154a0def9ed88be229184b5f34b9316/c1b63/1382.png 1200w,\n/static/e154a0def9ed88be229184b5f34b9316/252a4/1382.png 1314w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n이 문제는 이진 탐색 트리가 주어졌을 때, 이진 탐색 트리를 균형 이진 탐색 트리로 변환하는 문제이다.</p>\n<h2>풀이 및 해설</h2>\n<p>크게는 두 단계로 나누어 풀 수 있다.</p>\n<ol>\n<li>이진 탐색 트리를 중위 순회하여 정렬된 배열을 만든다.</li>\n<li>정렬된 배열을 이용하여 균형 이진 탐색 트리를 만든다.</li>\n</ol>\n<p>중위 순회를 하기 위해서는 재귀적으로 순회를 해야 한다.</p>\n<ul>\n<li>왼쪽 자식 노드를 방문한다.</li>\n<li>현재 노드를 방문한다. 이때, 현재 노드의 값을 배열에 추가한다.</li>\n<li>오른쪽 자식 노드를 방문한다.</li>\n<li>이를 재귀적으로 반복한다.</li>\n</ul>\n<p>이어서, 배열을 이용하여 균형 이진 탐색 트리를 만들어야 한다.</p>\n<ul>\n<li>배열의 중간 값을 루트로 하여 노드를 만든다.</li>\n<li>배열의 왼쪽 부분을 왼쪽 서브트리로 만든다.</li>\n<li>배열의 오른쪽 부분을 오른쪽 서브트리로 만든다.</li>\n<li>이를 재귀적으로 반복한다.</li>\n</ul>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">def balanceBST(self, root: TreeNode) -> TreeNode:\n        arr = []\n        # Create a Sorted Array using inOrderTraversal\n        def inOrderTraversal(root, arr):\n            if root:\n                inOrderTraversal(root.left, arr)\n                arr.append(root.val)\n                inOrderTraversal(root.right, arr)\n        inOrderTraversal(root, arr)\n\n        # Construct Balanced Tree from Sorted Array\n        if not arr:\n            return None\n\n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left+right)//2\n            root = TreeNode(arr[mid])\n            root.left = helper(left, mid-1)\n            root.right = helper(mid+1, right)\n\n            return root\n        \n        return helper(0, len(arr) - 1)\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB0klEQVR42o1TPW8TQRC9302PlJaKggIqJKCioESCDkGRCMWWMVHAOI4Fvpxvv+/26zGzG9v5IBIrjce7N/fmvbm3zRg9vrcLLLdrBO/hKUIIJXPknHF3bbc9lssV2q7Dk9lrPDp+isenLyC9QZNSgpACUik452CtwzAMJXjPzxn0AJxLo3Ec4anxtP+Jz+0UJ90cIUU0XKK1wmp1gV70xI6YcfHoC6i1tr5MIPw/xogHF/UsgBfLS8ym37BpO/xYrDCZTDH7NYc0ClrpwpQBhRD7kWitoYjIEIfCPuWqpGFYJR361qDrLH5fWZJvYKyBLSOoDAuBa9m7EdweBXaAKHN6QEEJ/vnHt7lffwsw7w5pTxHpyAVADACRh4/1PP8PIA863ZORsbgacSki5puMjc6IuVK9WZfuSN8D5r3A+vJZCzz7FHD0PuHoA/D8Sy7AIR0actQeNwCLRPKPdBF/NHDeRnw8z3g7SXjzNeHVSaSc8fI44t0s43QdiXVGqyKNglR0CWtZR8INmp12Q1/Tke+0seTBgYI9N9DtoRxczX4oddZRNod6R3s2+V4yL6UkDHuLbo02Bn0v6EyXayakJEtti/fYi4aec7bX2Tlb/MmAfwF4mKIq/AnO8AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/a9e1df1515ded750f1d31c795097dbc8/5a190/tc.png\"\n        srcset=\"/static/a9e1df1515ded750f1d31c795097dbc8/772e8/tc.png 200w,\n/static/a9e1df1515ded750f1d31c795097dbc8/e17e5/tc.png 400w,\n/static/a9e1df1515ded750f1d31c795097dbc8/5a190/tc.png 800w,\n/static/a9e1df1515ded750f1d31c795097dbc8/c1b63/tc.png 1200w,\n/static/a9e1df1515ded750f1d31c795097dbc8/bb072/tc.png 1318w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<p>전체 알고리즘의 시간 복잡도는 O(n); 여기서 n은 트리의 노드 수.</p>\n<ul>\n<li>중위 순회(inOrderTraversal): O(n)</li>\n</ul>\n<p>모든 노드를 한 번씩 방문하므로 O(n) 시간이 소요.</p>\n<ul>\n<li>균형 이진 탐색 트리 구축(helper 함수): O(n)</li>\n</ul>\n<p>배열의 모든 요소를 한 번씩 처리하므로 O(n) 시간이 소요.</p>\n<p>각 노드 생성 및 연결은 상수 시간 연산.\n따라서 전체 시간 복잡도는 O(n) + O(n) = O(n)</p>\n<h3>공간 복잡도</h3>\n<p>공간 복잡도는 O(n).</p>\n<p>정렬된 배열(arr): O(n)<br>\n모든 노드 값을 저장하므로 O(n) 공간이 필요.</p>\n<ul>\n<li>재귀 호출 스택: O(log n)</li>\n</ul>\n<p>균형 잡힌 트리를 구축하는 과정에서 재귀 깊이는 log n을 넘지 않는다.</p>\n<ul>\n<li>새로운 트리 노드: O(n)</li>\n</ul>\n<p>새로운 균형 잡힌 트리를 구축하므로 O(n) 공간이 필요.</p>\n<p>따라서 전체 공간 복잡도는 O(n) + O(log n) + O(n) = O(n).</p>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\nThe number of nodes in the tree is in the range [1, 10^4].  \n1 &#x3C;= Node.val &#x3C;= 10^5\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/balance-a-binary-search-tree/\">1382. Balance a Binary Search Tree</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L1382BalanceaBST/"}},"staticQueryHashes":[],"slicesMap":{}}