{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L1337TheKWeakestRowsinaMatrix/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"1337. The K Weakest Rows in a Matrix","date":"June 08, 2024"},"html":"<h2>문제 설명</h2>\n<p>여러 행렬이 주어졌을 때, 각 행의 1의 갯수를 기준으로 가장 약한 행 K개를 찾는 문제다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAABSklEQVR42q2UiYqDUAxF/f+/E0Q6IAju+75vGW+cgAOttFThYt+S83LTPJWfx4MsyyLDMEjTNNJ1nYWxaZqkqio5jkNXz7Zt1DQNtXNHStG2VBQF5XlOvu9TmqaUZRl1Xccbl2Xh9xXs/Ch+EPyBMgrDkBVF8X5AwWCZ8zxvn49YwR6DORxe1zXvQ4YMxKJt23uAy6A4PoLCMOIgHIaAsixZVVWx4OjsYl3XAwi7cRyz5ERsBiRJEp7DHmQwDMOlfQYiQABSP4wBA6jve5qmieZ5/lfPV2DlDIElWBQY5iD8Fsn4ZYY4Gf6hcz2e6bz2Eogeg627HgV/hvTdLUC0AFoH9bsq9ttAtANg0phfZ+i6LltG/32b3XH19jbBTQEQdUTzQtJ/HwPlOiG7Z/oYKI16h10GwioyhF3YbPfPGTSOI7+lDFh75y7/Am7fMBM14XtRAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1337\"\n        title=\"\"\n        src=\"/static/36948c9d3aecb59329d8bcacc6429408/5a190/1337.png\"\n        srcset=\"/static/36948c9d3aecb59329d8bcacc6429408/772e8/1337.png 200w,\n/static/36948c9d3aecb59329d8bcacc6429408/e17e5/1337.png 400w,\n/static/36948c9d3aecb59329d8bcacc6429408/5a190/1337.png 800w,\n/static/36948c9d3aecb59329d8bcacc6429408/c1b63/1337.png 1200w,\n/static/36948c9d3aecb59329d8bcacc6429408/985a9/1337.png 1512w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>1차 시도 - 정렬 (해결)</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 49%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABN0lEQVR42o1S2XLDIBDz/39kHvJSH4kJtiGcVldLnbZJ2ykzGi97CAncvfUDzuczTqcT+r7HOI6IMSLkiHGbJU6otaKtHTEkrNYjpij5XWvHN6aEbpwmDMOgRATjy+WCcA/w7o4kTQSJc85IucIYD2uN5EurpSy1FnfGGExCuiwLrterwnuvKnnYPBut3W4WbnOIuQ1bI3vnHg72fVcP3TzP0nxTWGuxbZsqIUKIcmp+QHPypTW3rdrrfNG+UksjXNdVFVHuQcTTuHfOq5ojXyS+8wpChplmrOsiRMf94lMhh58XrWxisRE2lCKEalEeoYhNvK6OVin9lTCC6mmV5ATj+qTohZAvykGeThyX236Hqjk6KKVdPNX9SciHCCF8NNdvhM+LtaP+KyHtkpBKvj7KT4P/IXwHv3APqPdbwwsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"v1\"\n        title=\"\"\n        src=\"/static/7352fdd30684b4c746da9a9aaeee34fa/5a190/v1.png\"\n        srcset=\"/static/7352fdd30684b4c746da9a9aaeee34fa/772e8/v1.png 200w,\n/static/7352fdd30684b4c746da9a9aaeee34fa/e17e5/v1.png 400w,\n/static/7352fdd30684b4c746da9a9aaeee34fa/5a190/v1.png 800w,\n/static/7352fdd30684b4c746da9a9aaeee34fa/c1b63/v1.png 1200w,\n/static/7352fdd30684b4c746da9a9aaeee34fa/29007/v1.png 1600w,\n/static/7352fdd30684b4c746da9a9aaeee34fa/9f75f/v1.png 2858w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n각 행의 1의 갯수를 더해서 하나의 리스트로 만들었다. 그리고 이 리스트를 정렬해서 가장 작은 K개의 행을 찾았다. 이렇게 해도 풀리긴 한다. 그러나, 이 문제를 어떻게 하면 heap을 이용해서 풀 수 있을지 생각해보자.</p>\n<h2>2차 시도 - Heap Queue</h2>\n<p>Heap을 사용해서 K 크기의 heap queue를 만들고, 가장 작은 행들의 합을 유지시키면 된다. 이렇게 하면 행렬이 엄청 커져도 빠르게 풀 수 있다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABDUlEQVR42o1Ry26EMAzk/z+m99567T90t2iritUSSgh5OQmZ2qGgHtdokIOHGdvpJjfDBoeSM1JK2LYNEjESzGLw+v2Ol9sbItesLphmzZwCoQm3FM5r3XNGtxoDpUY45+CsY6EISoTMBsxjUkFmEJ+JKtRD4WdSzcwsSzNOmetsGCmhm/SEQd1hLBNYPMTQECk217Nj6Z4dVrvicrtgHO9Y3YoQwsmpXO/k1Z66Q0K6+y8m4UJE5vG897h+feJDROcHf/fML417Ch5x5H3fQ2vdfpa91rrxWGJSQYEQfGg1zx3KyD7wWvJu3gRlsQLpTDAMA6y1bRzB0fEz0Qmxuf1BLkdERFAgZyJ6WvAXu4cihH7qOTsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"v2\"\n        title=\"\"\n        src=\"/static/9ffdbae2b5184c845012431616faffaa/5a190/v2.png\"\n        srcset=\"/static/9ffdbae2b5184c845012431616faffaa/772e8/v2.png 200w,\n/static/9ffdbae2b5184c845012431616faffaa/e17e5/v2.png 400w,\n/static/9ffdbae2b5184c845012431616faffaa/5a190/v2.png 800w,\n/static/9ffdbae2b5184c845012431616faffaa/c1b63/v2.png 1200w,\n/static/9ffdbae2b5184c845012431616faffaa/29007/v2.png 1600w,\n/static/9ffdbae2b5184c845012431616faffaa/322c5/v2.png 2286w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<p>생각보다 속도는 두개 모두 똑같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 15%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAeklEQVR42oWO2woDMQhE8/9/ubSwlKa5mcTcp26gj0sFkRmHo4qZ0VrDr3LOiDGilIJrN+cEEWGMIV7d865671AuE3QwIgaWmN57hEACZqSUUGuDtVaOJCwJzLlue0lAPd4njtdzA64PjLECcAIOcM5vkNafrZnL3/4CbVLp6HBv1UIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mem\"\n        title=\"\"\n        src=\"/static/7fbcac692f647f3cd799d2785958c94f/5a190/mem.png\"\n        srcset=\"/static/7fbcac692f647f3cd799d2785958c94f/772e8/mem.png 200w,\n/static/7fbcac692f647f3cd799d2785958c94f/e17e5/mem.png 400w,\n/static/7fbcac692f647f3cd799d2785958c94f/5a190/mem.png 800w,\n/static/7fbcac692f647f3cd799d2785958c94f/c1b63/mem.png 1200w,\n/static/7fbcac692f647f3cd799d2785958c94f/a8a6f/mem.png 1516w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">import heapq\n\nclass Solution:\n    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:\n        heap = []\n        for i, row in enumerate(mat):\n            strength = sum(row)\n            # maxheap\n            heapq.heappush(heap, (-strength, -i))\n            # remove values that are over K\n            if len(heap) > k:\n                heapq.heappop(heap)\n        # return arr in rev order\n        return [-i for _, i in sorted(heap, reverse=True)]\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABR0lEQVR42n1TW04DMQzsrbkJcIueoGfgo/0BpApBURDd7kP7zOYx7Jh6Cd2CJTeu45mMnewqIsLUR7yWBs652cdxhPcel9a2HYz5QFlWuHte4+bhFvdPa4QYZH/Fn77vp4ISXddJTB+GAdZaxBhnpznvZI8Hmi7DS2NkpbCZkESHtwPKooSdipWU3ratKGaNHSyuWvwJhfBUnbB73OE9N/gsjshPObIsE9UkHN2IospRtzVccPDOyyE+fI9E1c+EBHT91K6dVNlBlGhbBCqAc2IcQhDX/IJQJEf8aQRouyS6tv+LMD3x0mm87f1+P8+Ss02VLxX+o4xkJNlsNmiaBnVdizNmnsSprVKgqmTMlTMczre+3W7lf/qk5ObPT2tBqEAW8GYVoAQKVmXMsY5r+gHMLbNICQgimK1pXh8+V+ZJVlWV5FLCLychW0KAbWRWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/a3db49d2511f3e080aed579300997fb5/5a190/tc.png\"\n        srcset=\"/static/a3db49d2511f3e080aed579300997fb5/772e8/tc.png 200w,\n/static/a3db49d2511f3e080aed579300997fb5/e17e5/tc.png 400w,\n/static/a3db49d2511f3e080aed579300997fb5/5a190/tc.png 800w,\n/static/a3db49d2511f3e080aed579300997fb5/c1b63/tc.png 1200w,\n/static/a3db49d2511f3e080aed579300997fb5/66632/tc.png 1504w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>Time Complexity</h3>\n<p>[정렬 시간복잡도]</p>\n<ul>\n<li>for loop: O(M) ; M is the number of rows\n<ul>\n<li>sum: O(N) ; N is the number of elements in a row</li>\n<li>append: O(1) ; append to array</li>\n</ul>\n</li>\n<li>sort: O(MlogM) ; M elements</li>\n<li>output array\n<ul>\n<li>for loop: O(K) ; K is the number of weakest rows</li>\n</ul>\n</li>\n</ul>\n<p>전체: O(MN + MlogM + K) = O(MN + MlogM)</p>\n<p>[힙 시간복잡도]</p>\n<ul>\n<li>heap:\n<ul>\n<li>for loop: O(M) ; M is the number of rows</li>\n<li>sum: O(N) ; N is the number of elements in a row</li>\n<li>heappush: O(logK) ; K is the size of heap</li>\n<li>heappop: O(logK) ; K is the size of heap</li>\n</ul>\n</li>\n<li>extracting weakest rows\n<ul>\n<li>sorting heap: O(KlogK) ; K is the number of weakest rows</li>\n<li>create output array: O(K) ; K is the number of weakest rows</li>\n</ul>\n</li>\n</ul>\n<p>전체: O(m×n+mlogk+klogk)=O(MN + MlogM)</p>\n<h3>Space Complexity</h3>\n<p>[정렬 공간복잡도]</p>\n<ul>\n<li>O(m)+O(m)+O(k)=O(m+k)</li>\n</ul>\n<p>[힙 공간복잡도]</p>\n<ul>\n<li>O(k)</li>\n</ul>\n<p>따라서, 시간복잡도는 똑같은데, 공간복잡도는 heap이 더 효율적이다.</p>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n\nm == mat.length\nn == mat[i].length\n2 &#x3C;= n, m &#x3C;= 100\n1 &#x3C;= k &#x3C;= m\nmatrix[i][j] is either 0 or 1.\n</code></pre>\n<ul>\n<li>시간복잡도는 O(100*100 + 100log100) = O(10000 + 200) = O(10200)이다.</li>\n<li>공간복잡도는 O(100).</li>\n</ul>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/\">LeetCode</a></li>\n<li><a href=\"https://docs.python.org/3/howto/sorting.html\">Python Docs - Sorting</a></li>\n<li><a href=\"https://docs.python.org/3/library/heapq.html\">Python Docs - Heap Queue</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L1337TheKWeakestRowsinaMatrix/"}},"staticQueryHashes":[],"slicesMap":{}}