{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L440KthSmallestinLexicographicalOrder/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"440. K-th Smallest in Lexicographical Order","date":"September 22, 2024"},"html":"<h1>문제 설명</h1>\n<p>사전식 순서로 정렬된 숫자들이 주어질 때, k번째로 작은 숫자를 찾아라.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA4UlEQVR42q1Ri2qEQAzc//8+Ramigop6xdsVfL+mTmDFa7lr4RoYJo8lyWbURxAgyzKEYQjP8xBFEZIkge/7cBwHrutKjdx1HWj7vuOZqbosUVYViqJAHMcoj3iaJvR9Lw2GYZCYvG0bfjNl7hq32yeMMdDaCLdtK6DfNM0JrbUw8xy2ruvPhlyfk8nWJ/j4FZ5tq6rju8uy4L9MURDea55nwauD/6lhcKicpul5HzJvRBE4iIKM4/gADrZs61Y8Vdf1uSELTNpNr9t+j6/5qy9fZiMrxts3zPNcNrTqvdvwC/bfDjEj4kFaAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"440\"\n        title=\"\"\n        src=\"/static/e233e9ef195bee442528bdf02e69af27/5a190/440.png\"\n        srcset=\"/static/e233e9ef195bee442528bdf02e69af27/772e8/440.png 200w,\n/static/e233e9ef195bee442528bdf02e69af27/e17e5/440.png 400w,\n/static/e233e9ef195bee442528bdf02e69af27/5a190/440.png 800w,\n/static/e233e9ef195bee442528bdf02e69af27/c1b63/440.png 1200w,\n/static/e233e9ef195bee442528bdf02e69af27/bb072/440.png 1318w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<p>어제 문제와 매우 유사하다. 그래서 일단은 직관적으로 배열을 만들고, 거기서 k번째 값을 반환하면 되지 않을까 했지만, 역시나 메모리 초과가 발생했다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA3ElEQVR42o2SjVLEIAyE+/7Pqc4pWnstJBACa4LW0XpaM/MNM/xsloXphRYsvEFE0FrDWWlTpFQwL4TEEaptUFVtrWGixJAiNqnovZ/iB6U2xI0RHi9Yr1fUqjbfPgSJwTkj5wLmfEqx5lIreuuYw4y7h3sQ8+cNpn3TEW9wE1+TOtyWJAhPAVuK6Ltgzi5YflDNxRE1imVNJtp7QzEz4fKM17iObIdgjMlCJhC9w2bfx1uCjpi7YplpqViXFZTpW8bD4ejur/SF3wSdvVzg+DMmdzeClvov/EX/qjdLcnQ0SN8bCwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"test\"\n        title=\"\"\n        src=\"/static/c60d8820f86584c0862d36bd241b590f/5a190/test.png\"\n        srcset=\"/static/c60d8820f86584c0862d36bd241b590f/772e8/test.png 200w,\n/static/c60d8820f86584c0862d36bd241b590f/e17e5/test.png 400w,\n/static/c60d8820f86584c0862d36bd241b590f/5a190/test.png 800w,\n/static/c60d8820f86584c0862d36bd241b590f/c1b63/test.png 1200w,\n/static/c60d8820f86584c0862d36bd241b590f/29007/test.png 1600w,\n/static/c60d8820f86584c0862d36bd241b590f/38116/test.png 2086w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.500000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA5UlEQVR42m2RjW6EIBCEff/nbM+cp1CV/wWms+RiLq0kE11gP2fHqRmDai36tqJ7j7+r1oqUEnIu6L2P+nQNy2rh3A6RjiIVuQjfKybPyzFnVL3c2mj4VOOeAlUK1KZM+d1j/v7CZjYUwhrPVJOluxACpBQUgos+byQiFzCx7gKYxeJlVror10RT4Ji6oe7UTavt7fS/WxIHLNGRLkeXj8cMF8P42AAePiKYH0hI76wSHdGp5FtgZJZJ82wV0SXYzWD3J4T1APqYsMxP2NeTIR+ERiqwKd6OPMLXH3VGHPtxgfRM9QsTr9XJ+KZGAAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"memlim\"\n        title=\"\"\n        src=\"/static/4489653020b6ce7e59afc3107de706f7/5a190/memlim.png\"\n        srcset=\"/static/4489653020b6ce7e59afc3107de706f7/772e8/memlim.png 200w,\n/static/4489653020b6ce7e59afc3107de706f7/e17e5/memlim.png 400w,\n/static/4489653020b6ce7e59afc3107de706f7/5a190/memlim.png 800w,\n/static/4489653020b6ce7e59afc3107de706f7/c1b63/memlim.png 1200w,\n/static/4489653020b6ce7e59afc3107de706f7/29007/memlim.png 1600w,\n/static/4489653020b6ce7e59afc3107de706f7/eff3b/memlim.png 2072w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>역시 그렇게 간단하지 않고, 딱 k만큼만 처리해야 풀 수 있는 문제 같다. 따라서, 다음과 같이 풀었다.</p>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">def findKthNumber(self, n: int, k: int) -> int:\n        def count_prefix(prefix, n):\n            # 해당 prefix를 갖고 있는 수를 반환\n            # 예: count_prefix(1, 13) = 5 (1, 10, 11, 12, 13)\n            count = 0\n            current = prefix\n            next_prefix = prefix + 1\n            while current &#x3C;= n:\n                count += min(n+1, next_prefix) - current\n                current *= 10\n                next_prefix *= 10\n            return count\n        \n\n        current = 1\n        k -= 1\n\n        # k번째 수를 찾는만큼 한번식 조정\n        while k > 0:\n            # 이 값을 prefix으로 갖고 있는 수 반환\n            count = count_prefix(current, n)\n\n            # 현재 값들로는 아직 k에 닿지 못한다는 뜻\n            if k >= count:\n                k -= count\n                current += 1\n            # 현재 prefix를 갖고 있는 값들 중 하나라는 뜻\n            else:\n                k -= 1\n                current *= 10  # 기존에 닿지 못했기 때문에 10을 곱해본다\n                while current > n: # current가 너무 커졌으면 다시 낮추는 작업\n                    current //= 10\n                    current += 1\n\n        return current\n</code></pre>\n<p>def count_prefix 함수는 해당 prefix를 갖고 있는 수를 반환하는 함수이다.<br>\n예를 들어, count_prefix(1, 13) = 5 (1, 10, 11, 12, 13)이다.</p>\n<p>count_prefix 함수는 다음과 같이 동작한다.\n- count = 0\n- current = prefix\n- next_prefix = prefix + 1\n- current가 n보다 작거나 같을 때까지 반복\n- count += min(n+1, next_prefix) - current\n- current *= 10\n- next_prefix *= 10\n- count 반환</p>\n<p>current는 1로 초기화하고, k는 1을 빼준다.<br>\nk가 0보다 클 때까지 다음을 반복한다.<br>\n- count = count_prefix(current, n)\n- k가 count보다 크다면\n- k에서 count를 빼고, current에 1을 더한다.\n- k가 count보다 작다면\n- k에서 1을 빼고, current에 10을 곱한다.\n- current가 n보다 크다면, current를 10으로 나누고 1을 더한다.\ncurrent를 반환한다.</p>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABpklEQVR42oWSW2sUQRCF978LPsdHXwLmIRDwDwj7oCDEJYlIVHYTxEtmzWSvM909l+7py7Gq5+IsJljDoapvH9U9ZwIK6y2W8gH7SsB7D+dczKwQAsbBc5vtDnIncL66xvMvr3A0P8NaZ3F90m/KRAapJLTWg+q6jvAxlGutDZxxSMstZpuvuNotUDn9F8iRZXsskwRC5JBCQEiBqq5QVVWEG2NQluXQ9T/dd+UAvF8+YHmX4vf9CvPFNyRpgkzlKFRBnVYEbKCoZhDDi6KAdZY43dfBJy2crlFb6NJBkQrt4lVtY2EaA2st/hcHQA4G9H2HsbqrGBei+KD1AY4V2tzCHgHyQr/YZ9/l2y3w7gcO1sZ6okOykPNYCboqDQsTsCnaA8cXwLMp8OYW+HAHzEipBM5/0Q+t+4cb3rC1jtIea+kwvTG4TgPefg94/dnj597j5GMgeRxferycUb7wOP0U8OJ9wGLdPVUYdcgt1+w9UmN0ZxWqG0320bCmjHK2jrKd2toMb30AZCuw1xRlpVSbeY6UC4ksF8ilJI+qKEl7eMxe7eMPkYJUc9QV22QAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/9cc1be107946423d0ddb8747dc368956/5a190/tc.png\"\n        srcset=\"/static/9cc1be107946423d0ddb8747dc368956/772e8/tc.png 200w,\n/static/9cc1be107946423d0ddb8747dc368956/e17e5/tc.png 400w,\n/static/9cc1be107946423d0ddb8747dc368956/5a190/tc.png 800w,\n/static/9cc1be107946423d0ddb8747dc368956/c1b63/tc.png 1200w,\n/static/9cc1be107946423d0ddb8747dc368956/252a4/tc.png 1314w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>while문은 +1 또는 *10을 실행해서 O(logN)이다.</li>\n<li>그러나, 이 안에 count_prefix 함수가 있어서 O(logN) * O(logN) = O(logN^2)이다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>O(1)</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n1 &#x3C;= k &#x3C;= n &#x3C;= 109\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/\">440. K-th Smallest in Lexicographical Order</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L440KthSmallestinLexicographicalOrder/"}},"staticQueryHashes":[],"slicesMap":{}}