{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L3011FindifArrayCanBeSorted/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"3011. Find if Array Can Be Sorted","date":"November 06, 2024"},"html":"<h1>문제 설명</h1>\n<p>이 문제는 주어진 배열을 정렬할 수 있는지 확인하는 문제이다.</p>\n<p>이때, 정렬이 가능하다는 것은 다음과 같은 조건을 만족해야 한다.</p>\n<ul>\n<li>배열의 set bits(1의 개수)가 같은 모든 연속된 숫자들은 오름차순으로 정렬되어야 한다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 113.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAABYlAAAWJQFJUiTwAAACeUlEQVR42o2UaW7qQBCEfRYWg80SMPu+CkRASCAi7n+Sjr+Oym8EifR+lGaxp7q6umeiz8+zbXc72+/3dj6f7XQ6Fbher753v9/tcrlYpVKxOI7fUKvVLOtm1ug0LZpP+zab9Gw6ndlqtbLZbObki8XCwbrT6Tiq1eqvhCBNUqsldYsmw7ZNxx0bDIe2XC5yLJ14Pp/nQaY2Go2sXq9bkiSuBJUQMwpVR9nifD8aDEY5ycqJwC5PH1VSut1ubbPZuNp2u12Qt1ot+/j4yPdaljaaVklaFtdyhajCn6+vhxNAKA+Px6M9Ho9ifbvd7Pl8uqcE+gk8tSwXVW5NLE5yD8fjsQ3zdAXWk8nEUyVlfe/1etZoNFwZIO1SqWTlcvmnWFUKlqfMx2az6fJlvubdbrfYI93QN/wMEcc1L04kL4hINCGMLvxV4RDRer12ryAmUpqmDtKjAOHPBFXrhGPYThF+YTIVxiuIsywrPCMIxKouo/bCb1rnbTPwCtJ7zPENQnlIcfr9vn8DFElrBPCdOXtOyEF6TD+jFNXssQ731QkiYc6ojKhFhAr6CYW0CURqcoi4Mcx1BUlbHodzwDyiZRRRijSXAkZUq31QghDmYZvB5W0TNrNSCpuabyjFJxGS5r/r1/YATsiGUgQcBFhA+rKBK0kAFQvy8DIUHhIFRYJSDFNmHw91KOwERhQy4mnEIrzHr36SLkCRrOAMh4XweYtgJroOModMbyHpho+FiqPU5Sn+cWMiIkNCFD2ef12x8Mn/DX71IOM+E0E/6yr9z2Pw9jjgEw8rSlV6tUJ4+V9Vvz4Kb4/D4XBwf1RFjQqE10D78pFihK/NN9/z1P/kRQfzAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3011\"\n        title=\"\"\n        src=\"/static/db27f473394b87ad30f20df48a66c4b0/5a190/3011.png\"\n        srcset=\"/static/db27f473394b87ad30f20df48a66c4b0/772e8/3011.png 200w,\n/static/db27f473394b87ad30f20df48a66c4b0/e17e5/3011.png 400w,\n/static/db27f473394b87ad30f20df48a66c4b0/5a190/3011.png 800w,\n/static/db27f473394b87ad30f20df48a66c4b0/26a94/3011.png 1102w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<ul>\n<li>n만큼 순회하며 각 숫자의 set bits(1의 개수)를 확인한다.</li>\n<li>현재 숫자의 최소값과 최대값을 저장하며, 이를 이용해 다음 그룹이 이전 그룹 뒤에 올 수 있는지 확인한다.</li>\n</ul>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">def canSortArray(self, nums: List[int]) -> bool:\n    prev_max = 0\n    i = 0\n    n = len(nums)\n\n    while i &#x3C; n:\n        # count set bits(1s) of current number\n        count = nums[i].bit_count()\n        j = i + 1\n        min_val = max_val = nums[i]\n\n        # find all adjacent numbers with the same set bit count\n        while j &#x3C; n and nums[j].bit_count() == count:\n            min_val = min(min_val, nums[j])\n            max_val = max(max_val, nums[j])\n            j += 1\n        \n        # check if this group can be placed after the previous group\n        if prev_max > min_val:\n            return False\n        \n        prev_max = max_val\n        i = j\n    \n    return True\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACWUlEQVR42n1TyVLcMBD1Z1DFMjO2Je+bLMvbMB4YYygmEIosEI7JJbccc0tVfiK3fOtLS5MQoCo5vOpWq/X0Wn62ilWF9EQiymMEfoAgeA7O+TO4rouyLDGenWFcjxBXPdof95h+fkT57RUsvdF0LfIiR1EUBnmem7WOnueBMfZIqPMoilAIAZELRHWG5L5H8TAgulKw9IFlv8QwDIYsThJkaQahiYlUSmkU6b44jo1qxlw4jgPbtsEcF+zIhntog89dWJpku91ims4II25vbjBdnaPqFdq6Qdd1UEoZVVVFz5Om8H0fCV2sJwijEIzTBB43sLIsx3o54bjdYLW+xOb8huIKqlGo6xp1Uz8qDMPQRD26JtVrHZ++sRUEIdIkQxQmpCKl23y4jCOOYqNK4ynRS+j6U1h/EkZynfk+mmHCeP0Bi6P9ZyQvD/4Llpbsk108egcnkgirUySrN7BjBZa28JhDjf7/ieis5/G/Cn0a23cOMOvfY1ZuMY+XcMQApxiomQi5a4h9Ta5hamxXJ3A//k1Mb6g3eFxiIUYcrj9h7/wrZs0d9jdfcHDyGfPmFizM4GTHcNIGbtrBTWqq5WBBCjeusLf9jkWxoctsGllLDWMs8hMqnsJtXmNWXWPR32HeviOlI3i5wUJegNeXmIsJrLqAm/Xg+RKM9mbNW3jydPeVtfMTMmwlMoNOCSiRoClTqGJXV2UBWSSoZb6LZU71HEpSL+W6r1HSGN/SrDoRooQk47Zdb/K6aVHKimoKFRlbkBcbqhW0p8jweq3r2uylpJ+g7Yy9fgFTr5PVYvpoUgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/2b1e405696d8dca47a5d3a1ca3b3164e/5a190/tc.png\"\n        srcset=\"/static/2b1e405696d8dca47a5d3a1ca3b3164e/772e8/tc.png 200w,\n/static/2b1e405696d8dca47a5d3a1ca3b3164e/e17e5/tc.png 400w,\n/static/2b1e405696d8dca47a5d3a1ca3b3164e/5a190/tc.png 800w,\n/static/2b1e405696d8dca47a5d3a1ca3b3164e/525d3/tc.png 1090w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>O(N): 주어진 배열을 한 번 순회하며 정렬 가능 여부를 확인한다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>O(1): 상수 개수의 변수만 사용한다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n1 &#x3C;= nums.length &#x3C;= 100\n1 &#x3C;= nums[i] &#x3C;= 2^8\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/find-if-array-can-be-sorted/\">3011. Find if Array Can Be Sorted</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L3011FindifArrayCanBeSorted/"}},"staticQueryHashes":[],"slicesMap":{}}