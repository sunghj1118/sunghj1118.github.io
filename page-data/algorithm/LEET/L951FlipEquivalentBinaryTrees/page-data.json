{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L951FlipEquivalentBinaryTrees/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"951. Flip Equivalent Binary Trees","date":"October 24, 2024"},"html":"<h1>문제 설명</h1>\n<p>이 문제는 트리가 두개가 주어졌을때, 하나의 트리를 뒤집어서 같은 트리가 되는지 확인하는 문제이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 98%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAAC1klEQVR42n1Vy05iQRC936ERF77AF4K8BUEEF6KM77jU+Htu3etCZSTgJEbYI5rMjLwE5ALqmXvKNAHB6eRQdaurq091dxXaxkYcq6tRHBzsIx7/gZ2dHWxvb2NzcxOHh4ci4/E4YrEYJiYmMDk5+V9oAZ8NSx4r/IEAwuEwlpeXEYlEsLKyAqvVCovFArPZjJmZGYyNjWF8fPy/0FwOKzxuO5xOJzweD9xuNwJGcMLhcMBms8Fut2Nubg4LCwuYn58Xyc2U7Na1cDiC9fWYkdK6MGOAxcVFCeLz+YSxCu5yuURyU0qSoI1QusZJr9criylppI1BFbgJAyjwm9kwiLJRJ3vN7/cLi2AwiFAoJCxJf3p6WhyYKs9vdna2T1dQNq7RgsEQotEo1tbWRDI9siWcBlsyIXOyps4MVEYKihSz0XhWHo+348wbnZqa6kilD4Ka7/bX1PvhGyM+nT+fisVi/jYY0b1OvVFtaWlJzo9vaHR0VGAymXowMmIaOMc1fQ/79PQUd3d3uLm5wfn5ORKJBFKpFJLJZAfpdBoXFxe4vLySOfpS7u7uGpuNdNhKwEwmA452u42G3kSr1cbHxwe6B78bDR3NZqtn7vj4GMPDw1JNnYDZbBbFYgm///wVJ13XkcvlDdmUxZVKBfn8k+jcNJd7QK1WF9+joyMJ2MMwnb7F66uO5+cC3t7eUC6XUa+/Km7yyw11vWHY66IXS6XvGV5dXRvOLTzkH/HyUhWmTI/j/f1dZKFQRKlUxnOhYDCuIv/4JBmcnJxgaGhAyhyVyguq1Vrf+X0dNcOHG3NTxbAn5bOzM9ze/jJuLW3c8E/Rs9kMeFn39/c9oO36OgEeUzKZwt7efv8ts7BZw93dRDUIQnUT6qoZUDqdDqmMvndI562tLalhlh8bA7vJV7BO2QRUNTHYoA6u0ZEdhsXN4OwarG82S3YbStpUY1VdiPZBfwH/AE5iVcYVbH5iAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"951\"\n        title=\"\"\n        src=\"/static/3005335bb7748d6a34b0a6f75d0421c8/5a190/951.png\"\n        srcset=\"/static/3005335bb7748d6a34b0a6f75d0421c8/772e8/951.png 200w,\n/static/3005335bb7748d6a34b0a6f75d0421c8/e17e5/951.png 400w,\n/static/3005335bb7748d6a34b0a6f75d0421c8/5a190/951.png 800w,\n/static/3005335bb7748d6a34b0a6f75d0421c8/c1b63/951.png 1200w,\n/static/3005335bb7748d6a34b0a6f75d0421c8/f8836/951.png 1214w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<h2>풀이</h2>\n<pre><code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        def dfs(node1, node2):\n            if not node1 and not node2:\n                return True\n            if not node1 or not node2 or node1.val != node2.val:\n                return False\n            \n            return (dfs(node1.left, node2.left) and dfs(node1.right, node2.right) or dfs(node1.left, node2.right) and dfs(node1.right, node2.left))\n            \n        return dfs(root1, root2)\n</code></pre>\n<ul>\n<li>DFS를 이용하여 두 트리가 같은지 확인한다.</li>\n<li>두 트리가 같은지 확인하는 방법은 다음과 같다.\n<ol>\n<li>두 트리가 모두 None이면 True를 반환한다.</li>\n<li>두 트리 중 하나만 None이거나 두 트리의 값이 다르면 False를 반환한다.</li>\n<li>두 트리의 왼쪽 자식과 오른쪽 자식을 비교한다.</li>\n<li>두 트리의 왼쪽 자식과 오른쪽 자식을 서로 비교한다.</li>\n<li>두 트리의 왼쪽 자식과 오른쪽 자식을 서로 비교한다.</li>\n<li>두 트리의 왼쪽 자식과 오른쪽 자식을 서로 비교한다.</li>\n</ol>\n</li>\n</ul>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACV0lEQVR42mVTTW/TQBD1f6igh4q2ibP2+mNtZ/1tJ9RplaSlUeln1ApxQeIEf4ALXDlyAgkJiX/6mNnUKIXD0+yOZ96+GT1b+axGuqyhshiBHyAICUEA3/dNdF0XjuP8hRACRVFgeXaGeXeC8XqKyc83OP39HvrTK1jdrEMzaREnCZJHxHGMKIpM9DzvP9IwDKk+RqwiBFWM8KYmNJBzDcsRDpqmQdfNkGUZFBExmU40xuMx0jQ1UUppiFg5q7Rt22A0sCFeDA2cwxEsLl6tVpgv5lguF7i5vsLd+g7NSYuyLFHXtXmIx+d7r1opBa01QorCJeU8BcFSJPtoOkdbzdBOFugWl+iOj1E2JXLaFZOwSh6b1fXjs2K+c9xeh8UJpWgPYUQFCq4XbopJBTf06Ik49jAkW3cG7VDAD0K8vn8Hz+xn9OTFHu6TRgm3J3PEU8LNKCFEfUnq2Cb/Nm/DMURSDA2pHA0wyM83Dzz2GULp+XhR3MKhcV1XPH7cBuUMyUadnRxh7/gDBsUKzy++wpG0S2H3hNRAif1qDcePTFLwi9KjkaSBCBLYYYnD6hq7p5+xe/4FO+sf2Ln7jp37X3h2+Q17s49GuSWJgG0wUA3sIIOjcrhxCdtPIZMKQhWwowaj+gIH2TmG0wcM6lvsF1cYTh6wX17jYPoWw4YmpP1bbFLjsZwNnJDnUuQErcco8owso5HyOUuQJgplGqFIYxQ6QkU5Rj7mfGJ4rP5XKoqSCDX5rjJnrVM0bWs8mOc5qrqBTjO07cScuW46fUnnGjX9aVzLk/4BDcmV62Awd7IAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/1c5d2b1b50f7d6faa2a8c63724e87964/5a190/tc.png\"\n        srcset=\"/static/1c5d2b1b50f7d6faa2a8c63724e87964/772e8/tc.png 200w,\n/static/1c5d2b1b50f7d6faa2a8c63724e87964/e17e5/tc.png 400w,\n/static/1c5d2b1b50f7d6faa2a8c63724e87964/5a190/tc.png 800w,\n/static/1c5d2b1b50f7d6faa2a8c63724e87964/c1b63/tc.png 1200w,\n/static/1c5d2b1b50f7d6faa2a8c63724e87964/bb051/tc.png 1212w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>놀랍게도 100% 성능이 떴다. Editorial 답이랑 같지 않을까 싶다.</p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>O(N) : 트리의 모든 노드를 방문해야 하므로 O(N)이다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>O(N) : 재귀 호출을 하므로 O(N)이다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\nThe number of nodes in each tree is in the range [0, 100].\nEach tree will have unique node values in the range [0, 99].\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/flip-equivalent-binary-trees/\">951. Flip Equivalent Binary Trees</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L951FlipEquivalentBinaryTrees/"}},"staticQueryHashes":[],"slicesMap":{}}