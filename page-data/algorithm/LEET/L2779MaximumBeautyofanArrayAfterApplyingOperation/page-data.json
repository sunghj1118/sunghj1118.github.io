{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L2779MaximumBeautyofanArrayAfterApplyingOperation/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"2779. Maximum Beauty of an Array After Applying Operation","date":"December 11, 2024"},"html":"<h1>문제 설명</h1>\n<p>이 문제는 다음 연산을 수행했을 때, 가장 큰 beauty를 구하는 문제이다. 이때, beauty는 동일한 숫자가 여러번 나오는 subsequence이다.</p>\n<p>연산:</p>\n<ul>\n<li>nums의 두 숫자를 선택한다. (nums[i], nums[j])</li>\n<li>숫자를 [nums[i]-k, nums[i]+k] 사이의 값으로 바꿀 수 있다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 124%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAABYlAAAWJQFJUiTwAAACdUlEQVR42pWV6Y7iQAyE8/7PxT9Wi0ZcQgz3GQKEEO7LO5+lgl4EO7ORLHc6brtcbTtRr9ezz8+m1Wo1K5VKrpFisei6Xq9bo9GwarXq7x8fH76HLTbdbtd4breb66hcrlrx128rFAqG8/1+77Ldbm2z2fh6t9v5Os9z30eyLLPVauX74RNt1olly7HNkrmlaWqHw+FuyHq9Xt+j/+SJjvvMDtulR0+SxKbTqY3H46/13J3NZjN3zhpkoD2fz+8dpunK4jixeBb7YdKO49iWy6XN53PXCEH0DvK3DolOqhjCC0hJmcMgBtX1en0roL1cLo9L4QCHcbpYLNwZaU8mE5fRaOSo0QRQIOw4gwDqeDw+EGKQZesvnnI3wBjnrEGdpkv/Bo8czPPHjYPur5Qx6vf7jgoHQguP4oxvrNEEEkpp9gngDiGbyyA9ihRHvOswa1HBYexCGzlmTc1GGJM20CH4dDq5DoU9iS7gnURKAQS6XXhDQ4eIV2rwpid0dOdwMBhYuVy2SqVirVbLhsOhpw6vnU7HhX3tsUba7bZxlvQJptqMyJuUJepbkEB02CHqb/X1qwKPVKD/06//7GV40ZThCbvgmfBn3l6BiLiAZrPppfE8tiji58L9LhPvFBBSX9yy5h8ciVPxGPInCXvdHYIgrHi1HQUftmBow83yjeJWadFR+IpAoIpXB6DDEaZ2RKsRJNw0jlTwEZ3AB7gkGpHROqCC15hTCSE4U9lp6EYgo5jDWw7JRz/f/Ku5eJ+HROdSNJoUFU1Uzbkf16HKBs40KPXnwynCnoZG+K7g4T/GW0/jC7T6BehfonftoXEYZoNzOfwDAuWCBtwMimgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2779\"\n        title=\"\"\n        src=\"/static/f1c843154603b0f85ac5eef18206f58a/5a190/2779.png\"\n        srcset=\"/static/f1c843154603b0f85ac5eef18206f58a/772e8/2779.png 200w,\n/static/f1c843154603b0f85ac5eef18206f58a/e17e5/2779.png 400w,\n/static/f1c843154603b0f85ac5eef18206f58a/5a190/2779.png 800w,\n/static/f1c843154603b0f85ac5eef18206f58a/18539/2779.png 1074w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<h3>1차 풀이</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABGUlEQVR42o2SW3KEIBBFWcyIvJEgSqyQ2f+qbrqxTOWBlXycGkfl9L2C8DUhhACtDaZpgpTyF3xfzTN8TEh7QUwe2hooY2CchWboeqZ3xBKX/kcpdQu/+Hg8MGuNVDKOVrGRuB6vSDlBWU0D9Ck8jgM5Z6zrOqSUgpRST6lJbr1BePGIxJIDQnIwXpGQBisSbtt2K/sq5OqaEjpvsR+FpI6qqi5T5mRWEsJ7j7+w1vY6hj4Nf+tne8P7s2Hf6zlskic0VFwJuPYITrksy6eQfwvdq3Xv65xz3zZQtNboYe2M6l8DeZd7ZUq7rrmn5o36eTJEjBEMHx3mrjIv5HSzPMXM6IgJrsOLLuEIrsVpRoKh8Ep5Bw/8r/ADB8EwC7ZS3ywAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"a1\"\n        title=\"\"\n        src=\"/static/6a29cf517aa2ecc5d21bf9313d2bb0db/5a190/a1.png\"\n        srcset=\"/static/6a29cf517aa2ecc5d21bf9313d2bb0db/772e8/a1.png 200w,\n/static/6a29cf517aa2ecc5d21bf9313d2bb0db/e17e5/a1.png 400w,\n/static/6a29cf517aa2ecc5d21bf9313d2bb0db/5a190/a1.png 800w,\n/static/6a29cf517aa2ecc5d21bf9313d2bb0db/c1b63/a1.png 1200w,\n/static/6a29cf517aa2ecc5d21bf9313d2bb0db/29007/a1.png 1600w,\n/static/6a29cf517aa2ecc5d21bf9313d2bb0db/ee787/a1.png 2022w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>테케는 다 통과했으나, TLE로 실패. 어떻게 더 빨리 할 수 있을까? 아무래도 for loop 두개 돌리면서 느려지는것 같긴 하다.</p>\n<p>이를 어떻게 더 빠르게 쓸 수 있을지 고민하다가, difference array를 선택하게 되었다. 이는 제일 먼저 앞에 나온 수를 더하고, 마지막 나온 수를 빼는 방식으로 구현할 수 있다.<br>\n그렇게 한다면 O(n)으로 구현이 가능하다.</p>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">class Solution:\n    def maximumBeauty(self, nums: List[int], k: int) -> int:\n        # Handle edge case where nums is empty\n        if not nums:\n            return 0\n        \n        max_num = max(nums)\n        # Initialize counts and a difference array\n        counts = [0] * (max_num + k + 2)  # One extra for boundary handling\n        n = len(nums)\n\n        # Update the difference array based on each number in nums\n        for i in range(n):\n            start = max(0, nums[i] - k)\n            end = min(max_num + k, nums[i] + k)\n            counts[start] += 1          # Increment at start index\n            counts[end + 1] -= 1        # Decrement just past end index\n\n        # Apply the difference array to get the actual counts\n        for i in range(1, len(counts)):\n            counts[i] += counts[i - 1]\n\n        # The maximum value in counts is the answer\n        return max(counts)\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACG0lEQVR42p1Ty5aTQBTkG1y6yQh087KBhgYGSEhigpNJ4momrnJcjAt/wJ1f4Ic4v1ne25l4OOrC46LS9IWurnur4jSbHuXYQpkMSRQjSRJEUYQ4vjwHQQAp5S8IIdB1He4Pe4zDBvrTGqvnJ9z9+ILi2wHOcrlE27bQuUae59BaI8syC94z+ZSQwRelaQqVKESVQvK+JBhEfQaHFQzDgO12i7quiSi3KIrCkjdNA2MMwjC0l7ByVun7Pjzfg3B9iJlnIV0Bh1U8PD5gd7/DcljgeDzgfD5jHEd7AbfHhEzEe1bGqpVSKMvSrkIKyEBaOEqlWA9E1m/p8Bbz1R6r9Ts7hqqqrEI+yK0yEXd0xXU/HYfDxVSRIXFCs6GZJCm1x6ZcjGFMD04J/wZn6h7DzVckPaSa+MOMf4E1hQcurQIfs/YEEUQQNPD/Jowof4H/BgERvh6/IszYbWVVBrbNF8jJKn+rvcAJrDsBbvQGrrnDqw/fke0+Y396wo1HqiNyMUxIdQxJq0+r3U9r9vkyZ6swJkNE/4hZdYTXf4TbneCmc8RmCV/dQmYtIt3BS0rERQ+R3kKoGrGtVQh1b7tiDxz+4eQ3JkeZv0VXFzCaMqZzNJVBoTNUpkBtSvo3ZWhqg7KgbwuNmt9Trab3Fb3nRFhCDud8vkBJuVut16gpe1VVY7EYKIPGZpIDXlAeuXbNZ89nqNb3vf2GCX8C8gmSEfRxdaQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/7bd5923163ad2e9b07ae7b6dedc45c94/5a190/tc.png\"\n        srcset=\"/static/7bd5923163ad2e9b07ae7b6dedc45c94/772e8/tc.png 200w,\n/static/7bd5923163ad2e9b07ae7b6dedc45c94/e17e5/tc.png 400w,\n/static/7bd5923163ad2e9b07ae7b6dedc45c94/5a190/tc.png 800w,\n/static/7bd5923163ad2e9b07ae7b6dedc45c94/2e367/tc.png 1066w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>O(n) : nums의 길이만큼 for loop을 돌아야 하므로 O(n)이다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>O(n) : counts 배열을 nums의 최대값 + k + 2만큼 사용하므로 O(n)이다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n1 &#x3C;= nums.length &#x3C;= 10^5\n0 &#x3C;= nums[i], k &#x3C;= 10^5\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/maximum-beauty-of-an-array-after-applying-operations/\">2779. Maximum Beauty of an Array After Applying Operation</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L2779MaximumBeautyofanArrayAfterApplyingOperation/"}},"staticQueryHashes":[],"slicesMap":{}}