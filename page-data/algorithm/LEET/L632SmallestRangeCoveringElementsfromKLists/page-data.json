{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L632SmallestRangeCoveringElementsfromKLists/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"632. Smallest Range Covering Elements from K Lists","date":"October 13, 2024"},"html":"<h1>문제 설명</h1>\n<p>k개의 정렬된 리스트가 주어지면, 각 리스트에서 하나의 숫자를 선택하여 범위를 형성할 수 있다. 범위의 길이는 선택된 숫자 중 가장 큰 숫자와 가장 작은 숫자의 차이다. 최소 범위를 찾아서 반환한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABzklEQVR42q2T6WrDMBCE/f6vlfzIHRIIJM0FzkUd27mdO1N9Clvc0FIKNSwrydLszGoU9N7eVG801Ol0VCgUVKvVVK/XValUfG42myqVSmq1WioWiyqXy2q4/QT/u92uqtWqer2e+ILz4aBsu1OcJEriWEmSKnZ5sVhov9/rfr/rcrnodDr5fL1ePzPBf/LtdnsCnrZbHQBx8f4eKYqWmk6nms1mOrhi5/PZ53wATlBw684zPh6PHjRIViuFDiCKIs+KAHAymWg+nysMQw0GAx/j8dizX7kzBHvZwzhNU888oEq8XCp1i4mTzc/1eq3NZuPnZFiQYQILC+TaGNmPx0PB0oGF4dRLBYyDWXbUbrfzbAAnYIAswLMsc9Izn5/7M78f0IBGgkz8xxdQFXSan/+swF8LBfRpNBp5ufQEgHyfXnvFOD9/LRigmxulFwS2oE9clvWGNeaEWccsY/77Irndbms4HHqLsMlYmHFf2dr6t5LxDrJhwk2SATVvwRo2ZNbwK+uvPf8EpCogZok8oPkP6WZoANnz46XgQ14ALPMWylvJxnZpP8l9vmXnfqoiy14CGUkW9AwF5F9tQw/7/b5gyovgICAGatke/2+AH6F40rMrlQcXAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"632\"\n        title=\"\"\n        src=\"/static/e7e60dde9932a258b224c7d165b935e3/5a190/632.png\"\n        srcset=\"/static/e7e60dde9932a258b224c7d165b935e3/772e8/632.png 200w,\n/static/e7e60dde9932a258b224c7d165b935e3/e17e5/632.png 400w,\n/static/e7e60dde9932a258b224c7d165b935e3/5a190/632.png 800w,\n/static/e7e60dde9932a258b224c7d165b935e3/cd536/632.png 1114w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">class Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        heap = []\n        max_val = float('-inf')\n\n        # init heap with first element from each list\n        for i, num_list in enumerate(nums):\n            if num_list:\n                heapq.heappush(heap, (num_list[0], i, 0))\n                max_val = max(max_val, num_list[0])\n            \n        result = [0, 10**5]\n\n        while len(heap) == len(nums):\n            min_val, list_index, element_index = heapq.heappop(heap)\n\n            # update the result if we find a smaller range\n            if max_val - min_val &#x3C; result[1] - result[0]:\n                result = [min_val, max_val]\n            \n            # move to the next element in the current list\n            if element_index + 1 &#x3C; len(nums[list_index]):\n                next_val = nums[list_index][element_index + 1]\n                heapq.heappush(heap, (next_val, list_index, element_index+1))\n                \n                max_val = max(max_val, next_val)\n        \n        return result\n</code></pre>\n<ul>\n<li>heap을 초기화하고, 각 리스트의 첫 번째 요소를 heap에 추가한다.</li>\n<li>heap에서 가장 작은 요소를 pop하고, 해당 요소가 속한 리스트의 다음 요소를 heap에 추가한다.</li>\n<li>heap의 길이가 리스트의 길이와 같아지면, 가장 작은 범위를 찾아서 반환한다.</li>\n</ul>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB5UlEQVR42o1TbWrbQBD1eQu9RKB/Cu0R8ivQO7TQAyQUSkNM7BRHxq7cKPrWane1X68zK9tV2phEMB75eebNm/HMLG0z3KRL7OoMZhigtcZA3hgTPdv0kVJhu02RJGsURYmz63O8vfqAN5fv8Sn5jBkT1FVNgRJKqaNn/GDTx3sPa1005xzumg2+l0t8K26RykfMGOyEQFVV6HsZgziJ/bBXzGoZY8/4yScEzDhpPp9juVxQCzmK/BH39ytqa0sFenRdd2ydi7L6AzkXk1rBeRIRfDQiNPi5SJBuMjxkLRarHW5u77BeJ5FQkHpOZBIeh7X2SHgYUSBlo0BSyLPQkqpJSwQWraT5OE8/jkkvtvmkYyLkap4kOx+wq8ZqB3su4Tl7Qsgf3AZ9xY8tzcr6+H4q6UWFY7CHoHW7uNTU7uuSTxI6mheCxa4BPn7VkXwSMvHhHwz/YfsZjgp/d8C7LwN+NTQC4lQG0Pb1Zt1IHAm9s6iEwarw2JQWZWdRy4CHhq5IBeSdQcEYvWeENQqEWRTCUZyPGAuIhOz4T2mbGlrRzqmeVqjHoCWk6GBocVUvRkxNMPkX6wnTihfcj4S8Z3meQ9Ai13VN1yHiGfLxaz1eCF8MY2W8FlLeNGj3GMcpWv7gPf4ATGdAfZIvypgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/53cec41ef88157852afcef4b0b7ed7e4/5a190/tc.png\"\n        srcset=\"/static/53cec41ef88157852afcef4b0b7ed7e4/772e8/tc.png 200w,\n/static/53cec41ef88157852afcef4b0b7ed7e4/e17e5/tc.png 400w,\n/static/53cec41ef88157852afcef4b0b7ed7e4/5a190/tc.png 800w,\n/static/53cec41ef88157852afcef4b0b7ed7e4/f680b/tc.png 1108w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>시간 복잡도는 O(nlogk)이다. n은 리스트의 총 요소의 개수이고, k는 리스트의 개수이다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>공간 복잡도는 O(k)이다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\nnums.length == k\n1 &#x3C;= k &#x3C;= 3500\n1 &#x3C;= nums[i].length &#x3C;= 50\n-105 &#x3C;= nums[i][j] &#x3C;= 10^5\nnums[i] is sorted in non-decreasing order.\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/\">632. Smallest Range Covering Elements from K Lists</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L632SmallestRangeCoveringElementsfromKLists/"}},"staticQueryHashes":[],"slicesMap":{}}