{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L2577MinimumTimetoVisitaCellInaGrid/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"2577. Minimum Time to Visit a Cell In a Grid","date":"November 29, 2024"},"html":"<h1>문제 설명</h1>\n<p>이 문제는 2차원 그리드에서 주어진 좌표를 방문하는데 걸리는 최소 시간이 주어진다. 이때, 이동은 대각선, 수평, 수직으로 이동할 수 있다. 한 칸을 이동하는데 1초가 걸린다고 가정할 때, 주어진 좌표를 방문하는데 걸리는 최소 시간을 구하는 문제이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 127%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAABYlAAAWJQFJUiTwAAACR0lEQVR42qWVB6vjMBCE/f//WQiEkN4bpHen1z1/GyboTO69u3uGQfZqNVs0kqN2u23tTscajYZlMhkrlUrWbDatWCxavV7370Kh4GM+n7dWq2XZbNam06nxPJ9PC5/ott/bebez2Xxhq9XKHSeTiW02G5vP57ZL5rQQPB6P9/unJzonhId4Z6v12hevk/FFtLftdus4nU6237++D4eDA9v5fH7jdru9CHv9vhWTchpJeZRaqVST8pv+Xi6XrVarJbaKtyCXy7mN+U7SJnxoAWO/P/BAkSJT4nYbWxzHniXlM2LHpmyxxUlF+mbu5bOz+/1u0XK59L6Nx2MfQa/Xs9ls5qXTT94Xi8XbJsgf8O0l44gB59Fo5BO8hyTySZMQDMjPM4RkMBh4T+hXt9tN+tF/g7nlcuWbAiiRzQP0jBH78Xh8EUoCIUJpfCWRj7KhoaTL1n/1fAocBtPoPRwOh75TpK5ypKt/fSLkAZAA5NpZhPtfhCIhQyQEfkRIdpDqyNHPHxGKKNQfIv9uk/5IiH4gRVPSGptChtfr1XG5XDwA43cS8rNcrVa9TMi1mHcAMVBAAiBggBLSaohYjGw4MZTLkQrbwCZhh5QAqkKXShjECTkVus/ITnddCGzMsTCdOWs5jticEGaihAvkyIg9BL4EwC8cpYqIzNCgbl4d+tAxvJ11OeiiwOevMhTSGapkgSCQSmbeQwySiLIJpaIx3UONv5VMhpSsjEg/3MlwIdAvQb+F8Of17iGTEvCnDJVduiUqWTYIfwGF/4g0qec6pwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2577\"\n        title=\"\"\n        src=\"/static/261cba3e686c7f60ccec9de5a33cca70/5a190/2577.png\"\n        srcset=\"/static/261cba3e686c7f60ccec9de5a33cca70/772e8/2577.png 200w,\n/static/261cba3e686c7f60ccec9de5a33cca70/e17e5/2577.png 400w,\n/static/261cba3e686c7f60ccec9de5a33cca70/5a190/2577.png 800w,\n/static/261cba3e686c7f60ccec9de5a33cca70/18539/2577.png 1074w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">class Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        # if both initial require more than 1 sec, impossible\n        if grid[0][1] > 1 and grid[1][0] > 1:\n            return -1\n        \n        rows, cols = len(grid), len(grid[0])\n        # possible movements: down, up, right, left\n        directions = [(1,0), (-1,0), (0,1), (0,-1)]\n        visited = set()\n\n        # priority queue stores\n        # ordered by min time to reach each cell\n        pq = [(grid[0][0],0,0)]\n\n        while pq:\n            time, row, col = heapq.heappop(pq)\n\n            # check if reached target\n            if (row, col) == (rows-1, cols-1):\n                return time\n            \n            # skip if cell already visited\n            if (row, col) in visited:\n                continue\n            visited.add((row,col))\n\n            # try all four directions\n            for dx,dy in directions:\n                next_row, next_col = row+dx, col+dy\n\n                if not self._is_valid(visited, next_row, next_col, rows, cols):\n                    continue\n                \n                # calculate the wait time needed to move to next cell\n                wait_time = (\n                    1 if (grid[next_row][next_col] - time) % 2 == 0 else 0\n                )\n                next_time = max(grid[next_row][next_col] + wait_time, time+1)\n                heapq.heappush(pq, (next_time, next_row, next_col))\n            \n        return -1\n    \n    def _is_valid(self, visited, row, col, rows, cols):\n        return 0&#x3C;=row&#x3C;rows and 0&#x3C;=col&#x3C;cols and (row, col) not in visited\n</code></pre>\n<p>def minimumTime:</p>\n<ul>\n<li>오른쪽 칸과 아래 칸의 값이 1보다 크면 불가능한 경우이므로 -1을 반환한다.</li>\n<li>rows, cols는 grid의 행과 열의 길이를 저장한다.</li>\n<li>directions는 이동할 수 있는 방향을 저장한다.</li>\n<li>visited는 방문한 좌표를 저장한다.</li>\n<li>pq는 우선순위 큐로, 각 셀에 도달하는 데 걸리는 최소 시간을 저장한다.</li>\n<li>while pq: 루프를 돌면서\n<ul>\n<li>time, row, col = heapq.heappop(pq)로 pq에서 값을 꺼낸다.</li>\n<li>지금 도착한 셀이 목적지인지 확인한다.</li>\n<li>방문한 셀인지 확인한다.</li>\n<li>네 방향으로 이동해본다.\n<ul>\n<li>이동할 수 없는 경우를 _is_valid로 확인하고 안된다면 continue한다.</li>\n<li>다음 셀로 이동하는데 걸리는 시간을 계산한다.</li>\n<li>다음 셀로 이동하는데 걸리는 시간을 pq에 추가한다.</li>\n<li>pq는 최소 힙이므로, 최소 시간이 먼저 나오게 된다.</li>\n<li>만약 목적지에 도달하면 time을 반환한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>만약 목적지에 도달하지 못하면 -1을 반환한다.</li>\n</ul>\n<p>def _is_valid:</p>\n<ul>\n<li>방문한 셀인지, 그리드를 벗어나는지 확인한다.</li>\n</ul>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACDElEQVR42o2TyW4TQRCG/cLceAIOXFgkFCHOSHkAuCBxMAiIciBRELGjyGBHsUM83mbzbD1bf1S1CThYLG3VVLmWv/7qqel4yZLz2ZAgjajKirIsb0nbtvx+wjBkPJkQL0Jejt9z5+gxd0/2eH7xio4xhiiMyPOcoih2pGmaHUD1VVWNbSyLIqAfjpxc50s6dV2z8n3m8zlZlklihfpUK8MkSZxfmWoDjf3pWGvpaKd+v8doNCSKQjxvymAwYCIjKWsFVCAF11F1ImWoWmOmNLT6syoCWArg9FvA0ouZL1Imold+IOCRY6aixdpd2alWUcb6f/uOHcOm0UAjXaVAbZGbIo1pQdOqj38eB3hTrKcVVf9oaHeS4Sr6D0AtTUxLmMMygxdn4OebhKTcaG8N4xAuVr/A/wLYEuctx1fQHcKjd9DzLJcB7H9SVpbuVzi8hC+LhrSoHXt7C9VuAcrbMZXl4Ru49xoevIVnh7B3AE8/wBPR97tii2//uOFgVHEkzQfLzQRBvpG12bpDI19Ib1rTm8HnacvHccWp2Kczy5HanrAW+2RScj63DuxsWskULRO5isGs5DreXH5HH7UusUnlbcvilql8gtnGrnKx0592WSRiGyeVkZyqcHZZaE3hNsIB6tLq7qVZThjF+EFIlhfE6xRf/EmasU5Sl5PJsmtMc1LZ0aIwzq85CvgdNX3nYXORy98AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/f40d95b11b1faca3d851f354f7cfd58a/5a190/tc.png\"\n        srcset=\"/static/f40d95b11b1faca3d851f354f7cfd58a/772e8/tc.png 200w,\n/static/f40d95b11b1faca3d851f354f7cfd58a/e17e5/tc.png 400w,\n/static/f40d95b11b1faca3d851f354f7cfd58a/5a190/tc.png 800w,\n/static/f40d95b11b1faca3d851f354f7cfd58a/d53ff/tc.png 1068w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>O(MNlog(MN)) : pq에 추가 및 삭제하는데 log(MN)이 걸리고, 셀을 모두 방문하는데 MN이 걸린다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>O(MN) : visited에 모든 셀을 저장한다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\nm == grid.length\nn == grid[i].length\n2 &#x3C;= m, n &#x3C;= 1000\n4 &#x3C;= m * n &#x3C;= 10^5\n0 &#x3C;= grid[i][j] &#x3C;= 10^5\ngrid[0][0] == 0\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/minimum-time-to-visit-all-points/\">2577. Minimum Time to Visit a Cell In a Grid</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L2577MinimumTimetoVisitaCellInaGrid/"}},"staticQueryHashes":[],"slicesMap":{}}