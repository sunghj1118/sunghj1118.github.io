{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L962MaximumWidthRamp/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"962. Maximum Width Ramp","date":"October 10, 2024"},"html":"<h1>문제 설명</h1>\n<p>해당 문제는 배열이 주어졌을 때, 배열의 두 인덱스 i, j가 i &#x3C; j이고, nums[i] &#x3C;= nums[j]일 때, j-i의 최대값을 구하는 문제이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABuklEQVR42q2U64rCQAyF+/4vpiDisrr6x1oRa9Varb3aWs36xU2RRUSWHQiTGTMn5ySpzng8kX5/IB+DD+n1eje/L5PJRDqdjp6xbrcreZ4L63q9yqvl1KdU6iKSNE1ku93K8XiU3W4nYRjK4RDL5XKRuq51f2c5ZR5LHHqSZakEQaBgQbCW1SqQzWYjp9NJwaqqkqIo9Hw+N1KWpRrJqqpu45xwF8nn8Evm87n4vt8aTM0Ay7Jc/SzLFAQ/SRJNUhTl7ZzovUOWOD7Ifr9vg+57qo/JbMwwwIm5Mz3/MC3UV8mu62oTlktfplNXZjNXAdM0vSWKb3U8SBRFupOUO1NAo+yepApI19Buu/l/XSoZNkh5Nhacn9nv31tA5CAb6tThcUyapmmDH/dXChxAFouFAlIHzjCm6LC3Yr8tmYej0UhZrtdr7SCFh7l1nOLTcRLY6JCcMpnxm84hDHhsgRg+oAAR/CifHbPmmdnZ4ctgDAD4j6UMPc/TGsKIhiAVCciCMffv1lJrOBwOFRTpNkYGhM9u8u2ed0iHANZ+y1zyzwIYsmHH5FMKwEhADGCwtM8PH7OaAkoNvwGKUNiTpuOYwwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"962\"\n        title=\"\"\n        src=\"/static/ed4e27aa945cf89dd271f6dcf58e628d/5a190/962.png\"\n        srcset=\"/static/ed4e27aa945cf89dd271f6dcf58e628d/772e8/962.png 200w,\n/static/ed4e27aa945cf89dd271f6dcf58e628d/e17e5/962.png 400w,\n/static/ed4e27aa945cf89dd271f6dcf58e628d/5a190/962.png 800w,\n/static/ed4e27aa945cf89dd271f6dcf58e628d/3fca6/962.png 1112w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h1>풀이 1</h1>\n<h2>풀이 및 해설</h2>\n<p>for loop 두개 해서 비교 연산을 진행하고 max_ramp를 업데이트하는 방식으로 풀어봤는데, 시간 초과가 발생했다.</p>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">class Solution:\n    def maxWidthRamp(self, nums: List[int]) -> int:\n        max_ramp = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                if nums[i] &#x3C;= nums[j]:\n                    max_ramp = max(max_ramp, j-i)\n        \n        return max_ramp\n</code></pre>\n<h2>Complexity Analysis</h2>\n<ul>\n<li>시간 복잡도: O(N^2)</li>\n</ul>\n<h1>풀이 2</h1>\n<h2>풀이 및 해설</h2>\n<ul>\n<li>스택을 사용하여 풀이한다.</li>\n<li>스택에는 인덱스를 저장한다.</li>\n<li>스택에는 값이 감소하는 순서로 저장된다.</li>\n<li>오른쪽에서 왼쪽으로 순회하면서 스택의 top이 현재 값보다 작거나 같을 때까지 pop을 하면서 max_width를 업데이트한다.</li>\n<li>max_width를 반환한다.</li>\n</ul>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">class Solution:\n    def maxWidthRamp(self, nums: List[int]) -> int:\n        n = len(nums)\n        stack = []\n\n        # create a stack of indices in decreasing order of values\n        for i in range(n):\n            if not stack or nums[stack[-1]] > nums[i]:\n                stack.append(i)\n        \n        max_width = 0\n\n        # iterate from right to left\n        for i in range(n-1, -1, -1):\n            while stack and nums[stack[-1]] &#x3C;= nums[i]:\n                max_width = max(max_width, i-stack.pop())\n        \n        return max_width\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACGUlEQVR42nVUS2/TQBD2z0VI/QNw5Eg5IXFD4sKtJySkHuAEFVIAlUPbNA/iPBqFvGzX9nq9r/nYWeMqIc1Kn73z2G9nxjOONiLF1aKPyXYOVdeoPZRSAbw3xoCI0C4pa8znC0wmU2y3CU677/G08xIn31/h3e+PiLQ2yO9zVFUVSKSUgaiF1nqPkMh5Pw0+x5cN8ztcbnv46TEVS0TOOQhRIUkSFEURnKx1YD2TtRG3srUWR5e/N+Lbe70eut0brNcrpMkG43GMOI6R5znKsnyINE3TIDM5X8xZCQ/rLJyPnBEIR8MppvHC16RAPF3h+naA4WAQIhZChDJwZG1Z2miZnO1tSfgdcXqqNpCl8Q4aWWlRGwpGPsTgaPYyoyMZMyE/rDUHxWA9/ed8DI8Q2gMn5x4/ZBywFs3e0dEIbUjD/UN7XmrA7uq9rlIOv2bKfwgcnHkg5CLvLnZYFsDnAaDMft1y6fDmq8L1EtDuSIRc9FIBmST8uCO8viA8Pye8+ET4EhO+jQkfboBJSricOzw5M3h2DrztEDozwoW3S027hBabXGFZAqMEuF353vyjMdoSYi8PNoSreY1ZRhinDXF/qdBfu2AfboBCNR8zCin6lCtRQte+SY2E0b7fZAGtBKyWAaryU6SqZi99s+/IQVc3vRq185ll9yi5iWvVjGKa+b4U4WdQVTL8CHgqWC68nuWitctm7jmwv42LOgvl8qmPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/cac8d2889aff76174986a58197721906/5a190/tc.png\"\n        srcset=\"/static/cac8d2889aff76174986a58197721906/772e8/tc.png 200w,\n/static/cac8d2889aff76174986a58197721906/e17e5/tc.png 400w,\n/static/cac8d2889aff76174986a58197721906/5a190/tc.png 800w,\n/static/cac8d2889aff76174986a58197721906/ea64c/tc.png 1116w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<p>O(NlogN) : 스택에 최대 N개의 값이 들어가므로 O(N)이고, 스택에 값을 넣을 때마다 최대 N번의 비교가 발생하므로 O(NlogN)이다.</p>\n<h3>공간 복잡도</h3>\n<p>O(N) : 스택에 최대 N개의 값이 들어가므로 O(N)이다.</p>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n2 &#x3C;= nums.length &#x3C;= 5 * 10^4\n0 &#x3C;= nums[i] &#x3C;= 5 * 10^4\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/maximum-width-ramp/\">962. Maximum Width Ramp</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L962MaximumWidthRamp/"}},"staticQueryHashes":[],"slicesMap":{}}