{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L1038BSTtoGreaterSumTree/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"1038. Binary Search Tree to Greater Sum Tree","date":"June 25, 2024"},"html":"<h1>문제 설명</h1>\n<p>이 문제는 BST에서 각 노드의 값을 현재 노드의 값보다 큰 값들과의 합을 구하는 문제다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 106.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAACHUlEQVR42q1UiY7aMBDN///aUgQSCCgsZ7iPkMOxc771c3CasFuJojoaecZ23tzjnE4nfHR+od/vo9frYTweo9vtYjKZYDQaYTAYmLNOp2PeDIdDI/M8yzJwFUWBsiwN76QqROzv4XkeDocDbrcb9vs9qOh+v+N4PJkfSXmet+in5SRKQEZXREIYAAKfz2dcr1cEQWAUJElSk1Kq5qWURiaRpxLHdbeY/J5qqw7Ybrf4/JzBdV2s12vM5/OaJ202G8xmMywWC0Or1cq8mU6n2O12xgvH931EUYQ0TVtEC553Eq3gbuPH2LViSHPpHt2ke6TL5WLO6D53yry3oWB8wzBsAdUxpHYLwB8YRwtCIqjlec8QMGnkCUzvWoC0kNm1xIfH49Hw3CnbrDNOjBvvrDKbtD9Z1gItomU2y9b1pmx57nS1uZpuO/bgORbvLodal8slhK7D/wJI81kKTQurUqDVbwD+dCgTXUpejFiWDwVvAJZlAZVkkCo3QS80SprlmjJd2PnLoDVglqXw/BgiblsldVl5vsSjMV4DZOmEUYpcW6ZS3eiqip+UCYSkxTlipVsvLV8DVDpmYVS5JfTUCEXFx5oXsW4v/UVCGkUvATYznGrXg0jpuJmbxwAFglCZu3/OMhMiEw7TZifAJCb7y1D9VodscDumKkrqEZWZLGtenzNxzXd2nH2bNhyWz71rZRJnJsnKzTOOsWYvfwH7bGBiclemWQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1038\"\n        title=\"\"\n        src=\"/static/fa228aff6c83770a005bfdfdc02d094e/5a190/1038.png\"\n        srcset=\"/static/fa228aff6c83770a005bfdfdc02d094e/772e8/1038.png 200w,\n/static/fa228aff6c83770a005bfdfdc02d094e/e17e5/1038.png 400w,\n/static/fa228aff6c83770a005bfdfdc02d094e/5a190/1038.png 800w,\n/static/fa228aff6c83770a005bfdfdc02d094e/c1b63/1038.png 1200w,\n/static/fa228aff6c83770a005bfdfdc02d094e/0d0e4/1038.png 1230w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>오랜만에 트리 문제다. 일단 Binary Search Tree는 왼쪽에 있는 값들은 모두 지금의 노드보다 작은 숫자들이며, 오른쪽은 다 큰 숫자들이라, 자식들이 있다면 현재 노드의 값에다 오른쪽 노드의 값들의 합을 구하면 될 것 같다. 반면, 자신보다 큰 자식 노드가 없다면, 자신보다 큰 값들이 있는지 먼저 찾아봐야 할 것 같다.</p>\n<p>이 문제를 해결하기 위해서는 직관적으로 가장 큰 값부터 시작해서 왼쪽으로 가는게 유리할 것 같고, Sum of a Binary Search Tree를 구하는 문제와 비슷한 방식으로 풀 수 있을 것 같다.</p>\n<h2>풀이 및 해설</h2>\n<h3>핵심 개념 3개:</h3>\n<ol>\n<li>Reverse In-Order Traversal</li>\n</ol>\n<p>이게 아까 말했던 오른쪽에서 왼쪽 순서로 가야 큰 값을 먼저 살핀다.\n2. Cummulative Sum\n지금까지 탐색한 값들의 합을 저장하고, 현재 노드의 값을 대채한다.\n3. 현재 노드 값의 대체\n현재 노드의 값을 현재까지의 합으로 대체한다.</p>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">class Solution:\n    def bstToGst(self, root: TreeNode) -> TreeNode:\n        cummulative_sum = [0] # initialize cummulative sum list\n\n        def reverseInOrder(node: TreeNode):\n            if not node:\n                return\n            \n            # Traverse right subtree first\n            reverseInOrder(node.right)\n\n            # Update cummulative sum\n            cummulative_sum[0] += node.val\n\n            # Update current node value\n            node.val = cummulative_sum[0]\n\n            # Traverse left subtree\n            reverseInOrder(node.left)\n        \n        # Start reverse in order traversal\n        reverseInOrder(root)\n        return root\n</code></pre>\n<ul>\n<li>먼저, cummulative sum을 저장할 리스트를 초기화한다.</li>\n<li>reverseInOrder 함수를 정의한다.</li>\n<li>reverseInOrder 함수는 node를 받아서, node가 None이 아닐 때까지 오른쪽 서브트리를 먼저 탐색한다.</li>\n<li>그리고, cummulative sum을 업데이트하고, 현재 노드의 값을 업데이트한다.</li>\n<li>마지막으로, 왼쪽 서브트리를 탐색한다.</li>\n<li>마지막으로, reverseInOrder 함수를 실행하고, root를 반환한다.</li>\n</ul>\n<p>테스트 케이스는 모두 통과한다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.49999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA/UlEQVR42q1T7QrDIAz0/R9yMBhlYOm3Wq3tzRMc+7GmW7dAwM/L5ZKoIRhcxgpXc8c0GzjrYJ1DCAHfWFwBk76oGCNuVQWt63S4YpomBO9x1pT3AS4xiinEtm3ZfzG1JlZ0MZ2UxdGbJ6DEqDBumgZd1x1mwDslRaOebdvmh2SotYa1Vma4d2GMeTIjSAGnSx2wC7gsS9aOYHVd5z1ZErDv+3MaloK8pulTS83zvK8ho/LTv0xRD/ahZN/0pvrkEYsj6faxhuM45iJQMzrX/mAsdxkSgNWlU5ZSbYJKmiupqcmQqRJoGIasNdc8P902helrIPqp0XtX5aN5fgDXxED9rsTN7gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"test\"\n        title=\"\"\n        src=\"/static/349b20eeff40441ab69e1dd660646cf5/5a190/tests.png\"\n        srcset=\"/static/349b20eeff40441ab69e1dd660646cf5/772e8/tests.png 200w,\n/static/349b20eeff40441ab69e1dd660646cf5/e17e5/tests.png 400w,\n/static/349b20eeff40441ab69e1dd660646cf5/5a190/tests.png 800w,\n/static/349b20eeff40441ab69e1dd660646cf5/c1b63/tests.png 1200w,\n/static/349b20eeff40441ab69e1dd660646cf5/e9140/tests.png 1226w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACE0lEQVR42n1TS2/TQBD2r+XIAW4c+BEgBEJCQuLKgQMgIS5ITZEIUhQkqNuitKWpm9jBdvxYex/e/ZhZJyakwEijsXdmvnkHK5EhjGdIqxxGGyitoLUe2DmHfSqKEj8u58iTDO+jMe5OHuDe9DGez94gkEoiyzI0TeO5bds/uOs6D7oLbEwHpTQsyWWT4nMaYvzzCGdVhIAd8ixHEicQBKiNIQfKVCnPDMqS7aSUXvdPopiBogxPjo8RXUeI4yWu5pcIw5DKKiCEQFVVA2ie50PWLEsqXUgB4wyss54DTX1LFgWyRCBeCZxHa6Rp5sG4BSw5MyYGstb68llytp2llqBvB78HrNCKFIYMOmY3OOzypiJsW/mXWfWAW+f/kdvw9mcA3QC7fUAu5Wa0m2DnGbCqqXSK/2EGyM18OktJud5yJ0O3l9NvWlaA0MABgTwbA6ML4NZL4O1Jr5vOJVrVJxVsd4xaB2ojNL035BwVQEmzOCDnRx+BFxPgySfg9iv6PwTuvAYejoD774Cnhxqjsx1AS5MqhMG6dcQElhscxRYXOUW/tvi2MPiyAL6nDpMrgxnJr0vgNDGYRg6nK+vtPWC/+QairqFkSxNvIRtBsqFTlCQFVFuTDb/XkKIgO3prKvouYUivdeuZZzEA8iJL2V9HUdLCisZ/V1Xtb7clXUVBU7oqvqia9jNfr73enyntKs/iF86J6pKYwzARAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/9ba7b8885fd867abe620aa48420f1e44/5a190/tc.png\"\n        srcset=\"/static/9ba7b8885fd867abe620aa48420f1e44/772e8/tc.png 200w,\n/static/9ba7b8885fd867abe620aa48420f1e44/e17e5/tc.png 400w,\n/static/9ba7b8885fd867abe620aa48420f1e44/5a190/tc.png 800w,\n/static/9ba7b8885fd867abe620aa48420f1e44/c1b63/tc.png 1200w,\n/static/9ba7b8885fd867abe620aa48420f1e44/c929c/tc.png 1218w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<p>노드 방문을 한 번씩만 하기 때문에 O(N)이다.\n각 노드를 정확히 한 번 방문하므로, 전체 시간 복잡도는 O(N)이다.</p>\n<h3>공간 복잡도</h3>\n<p>O(H); H는 트리의 높이로, 재귀 호출 스택의 최대 깊이이다.</p>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n\nThe number of nodes in the tree is in the range [1, 100].\n0 &#x3C;= Node.val &#x3C;= 100\nAll the values in the tree are unique.\n</code></pre>\n<p>노드의 수가 최대 100개로 매우 작기 때문에 O(N) 복잡도의 알고리즘은 충분히 빠르게 실행될 수 있다.</p>\n<p>현재 프로그램이 느린 이유는 재귀 호출로 인해 호출 스택이 깊어지면서, 특히 트리의 높이가 커질 때 스택 프레임 관리에 시간이 더 소요되기 때문이다. 또한, 불필요하게 cummulative_sum을 리스트로 사용하여 간접적인 접근을 하는 것도 성능을 저하시킬 수 있다. 이 때문에 작은 트리에서도 재귀 깊이와 리스트 접근이 누적되어 느리게 작동할 수 있다.</p>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree\">LeetCode</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L1038BSTtoGreaterSumTree/"}},"staticQueryHashes":[],"slicesMap":{}}