{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L3243ShortestDistanceAfterRoadAdditionQueriesI/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"3243. Shortest Distance After Road Addition Queries I","date":"November 27, 2024"},"html":"<h1>문제 설명</h1>\n<p>이 문제는 0에서 n-1개의 노드가 주어지고, 여기에 새로운 경로가 들어있는 paths가 주어집니다.</p>\n<p>이때, 해당 path가 추가될때마다 0부터 n-1까지의 최단거리를 구하는 문제입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 128.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAABYlAAAWJQFJUiTwAAADAklEQVR42q2VXU/iUBCG+4/RaOIPIFm9M/EneG288sbolQnEb0UR1KgISvksYGkLIjLyDDvY3bjKxTaZnOl0Zs573pk5dQqPj5K5uJBcLifZbFYF/fz8XK6uruT29lYymYxcXl7qN/R0Oi35fF5tZ2dnqr+9vQmPE/ht6bRq0mg0pVqtSrPZFNd1pVKpqF6r1eTl5UXCMJRutyu+70un05EgCFTnG/poNJokHEQt6fuutMdO9XpdWq2WlMuThDizSb/f1wAL+u5xfL8rTa81RuPpzo1GQxORGIQIOna+D4dD3QB5fX2VwWCggv39/V0cz/PE85rSbrcVFShrtbpuEIaBOgdBKPixEYJfuVxWOrATiz2KeuKgwA3rhJtQucFmSAwFehRFKqCjEIaOd0VIksdxpV33c9eHhwe5v7+XQqGglaXaxWJRq3p8fCxHR0dyfX2tcaVSaRpHUgckJiAD4aceaHXhkHeQ8Y7wjQRhGGlMr9dTm0OLsLvrlnW3p6dneX6eCKjhlMJUKlW1TXyefseMu6PdGesl9YESx9oBgQPEKmbCE/8eF7NP+5DjsDOQ/8fjwAdw4cN6LF5V6zdr7h8TEghKAkDJBtYOJIrLTAlxhFwalOqC0ngx7njifH6bEKfJNAR/BJAIe3ydiUNQcVURdHJyomNEUx8cHGjL7O3t6RyzcpI46i8T3t3dyfz8vHI0Nzen99/m5qasra1p8kQioeh/LS/L9vb29PgzHdkKY0VgMigQhbI5ZmLi96CJbaKNTTAzbc44EIyNZLbGh+BvmSKEL44Ml0tLS3qdr6+vy+rqqg78wsKCtlUymZTd3d2fjwz0w8NDPdL+/r6iYVa5TUBJcaCBm4b5pa14R6zx402vHMKTTYhdonbjGMfGqyX7Z0JTQIaAChSI/QpYZ55lkGxtbem1nkqllLeL8W/19PRUEWLjR7WzszPtw/jt8mUfLi4u6rFYb25uZGNjQ/uQ5BQM5CsrK5p0pj6EG/uHcGTjBT3eo7yjG792e2M3Dj8Ags21p8u6Z8oAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3243\"\n        title=\"\"\n        src=\"/static/f9b47a97a5df8c138a79b0b6b222d4f0/5a190/3243.png\"\n        srcset=\"/static/f9b47a97a5df8c138a79b0b6b222d4f0/772e8/3243.png 200w,\n/static/f9b47a97a5df8c138a79b0b6b222d4f0/e17e5/3243.png 400w,\n/static/f9b47a97a5df8c138a79b0b6b222d4f0/5a190/3243.png 800w,\n/static/f9b47a97a5df8c138a79b0b6b222d4f0/dd104/3243.png 1064w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def shortestPath(self, n, paths: dict) -> int:\n            # paths : {0: [1], 1: [2], 2: [3, 4], 3: [4]}\n            start = 0\n            end = n-1\n\n            queue = deque([(start, 0)])\n            visited = set([start])\n\n            while queue:\n                node, distance = queue.popleft()\n                if node == end:\n                    return distance\n\n                for neighbor in paths.get(node, []):\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, distance+1))\n            \n            return -1\n        \n        paths = {i:[i+1] for i in range(n-1)}\n        shortest_dists = []\n\n        for q in queries:\n            start, end = q[0],q[1]\n            paths[start].append(end)\n            shortest_dists.append(shortestPath(self, n, paths))\n\n        return shortest_dists\n</code></pre>\n<ul>\n<li>BFS를 이용하여 최단 거리를 구하는 함수 shortestPath를 정의한다.</li>\n<li>모든 query에 대해 paths를 업데이트하고, shortestPath를 호출하여 최단 거리를 구한다.</li>\n<li>최단 거리를 저장한 리스트를 반환한다.</li>\n</ul>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB9UlEQVR42o1TyXITMRD1/3LkH7hw4wv4BQ45QXGAW6AIlYIkJgkuTxYbexZpRstIGumlW+Nx4bCqqqu7pdbr163WbKsbzDcLVEpgCAOcdwghwHufJaWEx6uuBZbFDbqtxKvlOzz58BxPP77Ay+sjzJxzqKsaWmsYY/Z6kmEYfgHkPU4WQ0TZS1zIJeYka1Nhxod1XWO9XkMpReyGzDD4AE7WdV1OEmPMCfjsT4urmfV9j7PzMxQ3BaqqxOL7NU4+nWBeXKKhNigCNHYEklLCWpsZMjgnY5uBJpl5YvLjvkG57rDdahSrFiW1QLQS2lD52oCTcjCznHrK9gR2wJAPGDQOiR6FgygT0h5gkv9ZGfDxK7Ib02+Cd7rtARf+AfgzaGMBqn4PPoFN9koC0v4FkCMdlarcuHlLF46+OmrBsANJBwzPN2kXmw64pz0gmdYDxwUgKPP7BfDsdcTnu4jLcmRbCMBTGxnozTfg7dUYa6n0Poz26YpbtSuZZ29ZBRRNwvHSE3jEl3uPC2JztfFYVDTAncetSDi98znZovQoVcRGBro75Mp2DJFnzJoOvjdwlrTX6Fk7A6tbGnAaH9WST/taZp/jnVW0z1rTnXE+MyD/CEFDq+hHNI1A2yk0gn2TfW0s+aTJ5xnt1BjHP0uIMd7SrDLgA6Dr77dP9ylsAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/dfa0957e09185f037f3bb73b6ab86e8d/5a190/tc.png\"\n        srcset=\"/static/dfa0957e09185f037f3bb73b6ab86e8d/772e8/tc.png 200w,\n/static/dfa0957e09185f037f3bb73b6ab86e8d/e17e5/tc.png 400w,\n/static/dfa0957e09185f037f3bb73b6ab86e8d/5a190/tc.png 800w,\n/static/dfa0957e09185f037f3bb73b6ab86e8d/d5bfb/tc.png 1072w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>O(n+q) : n은 노드의 개수, q는 query의 개수</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>O(n) : n은 노드의 개수</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n3 &#x3C;= n &#x3C;= 500\n1 &#x3C;= queries.length &#x3C;= 500\nqueries[i].length == 2\n0 &#x3C;= queries[i][0] &#x3C; queries[i][1] &#x3C; n\n1 &#x3C; queries[i][1] - queries[i][0]\nThere are no repeated roads among the queries.\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/shortest-distance-after-road-addition-queries-i/\">3243. Shortest Distance After Road Addition Queries I</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L3243ShortestDistanceAfterRoadAdditionQueriesI/"}},"staticQueryHashes":[],"slicesMap":{}}