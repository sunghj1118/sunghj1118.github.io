{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L2392MatrixWithConditions/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"2392. Build a Matrix With Conditions","date":"July 21, 2024"},"html":"<h1>문제 설명</h1>\n<p>여러 조건을 충족하는 행렬을 만드는 문제입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 104.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB0klEQVR42qWU227CMBBE8/8fR3ng1pfywDUBkkDCLRC2PosmTVGlUmppFNvYszuza6KP8djeul17H42s3+87BoOBYzgc+rrT6Viv17PD4WC/jaja7axIU5svFrZer206ndrC5xtfX69Xq6rKzuez3W633wnLQJiGi5vNxmazmZMx3263loZAoCxLe3ZEx9OpuZhlme1CgDzfWlEUDWme52FdOo7Ho0vf7/cOzrHHQEHEj0mSWBzHLhEC5KZp5muy5Qs4l2W5ByA458pyH4jqrwyJoOzuZPfL96wK95DIgjJ53GsIkaXoZAPJarUOcvNGLmcUkDVS+S6Xy3B25TbpbsRB5AJIAUVQZQFzMhXqum6qf7lcmjWIiEYGygIQHcg/9rgEJLO91tclQziZTLxd4jgJMuKmdSBFpoKxr2BtK5B8Ct3ihFR5Pp83HibJyue6BCHeEFiXsUTgN/aQ74Qwk5WyhIwGl6+QcBHCRzKgnsRLJ+QQWbQlqprKTnPIkak+BBTiW9tgKOzPvNOnnh59hESZ+ljNx0bW+Kmp738OwQdk68WoGDL5zxmqUhjbnr9M2O4lFYE5L+QlQhGQHeS0AfgXIUTyEv/ajfoSoUjUZ+BVwk82yly+2k5noAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2392\"\n        title=\"\"\n        src=\"/static/3c67d68ff207c9429f5a5d491e245b4d/5a190/2392.png\"\n        srcset=\"/static/3c67d68ff207c9429f5a5d491e245b4d/772e8/2392.png 200w,\n/static/3c67d68ff207c9429f5a5d491e245b4d/e17e5/2392.png 400w,\n/static/3c67d68ff207c9429f5a5d491e245b4d/5a190/2392.png 800w,\n/static/3c67d68ff207c9429f5a5d491e245b4d/c1b63/2392.png 1200w,\n/static/3c67d68ff207c9429f5a5d491e245b4d/203d3/2392.png 1322w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<ul>\n<li>Topological Sort를 이용하여 숫자들의 순서를 정하고, 이를 이용하여 행렬을 만들어주면 됩니다.\n<ul>\n<li>행에 대한 조건들에 대해서는 DAG를 만들어주고, abovei과 belowi를 잇는 간선이 abovei가 먼저 나와야 한다는 것을 의미합니다.</li>\n<li>동일하게, 열에 대해서는 DAG를 만들어주고, lefti와 righti를 잇는 간선이 lefti가 먼저 나와야 한다는 것을 의미합니다.</li>\n<li>이후, Topological Sort를 이용하여 순서를 정하고, 이를 이용하여 행렬을 만들어주면 됩니다.</li>\n</ul>\n</li>\n<li>Matrix Construction을 사용해서 행렬을 만들어주면 됩니다.</li>\n</ul>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">from typing import List\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n        \n        def topological_sort(conditions):\n            # create a graph and in-degree dictionary\n            graph = defaultdict(list)\n            in_degree = {i: 0 for i in range(1, k+1)}\n\n            # build the graph and in-degree count from conditions\n            for u,v in conditions:\n                graph[u].append(v)\n                in_degree[v] += 1\n\n            # queue to process nodes with in-degree of 0\n            queue = deque([node for node in in_degree if in_degree[node] == 0])\n\n            topo_order = []\n\n            while queue:\n                node = queue.popleft()\n                topo_order.append(node)\n                for neighbor in graph[node]:\n                    in_degree[neighbor] -= 1\n                    if in_degree[neighbor] == 0:\n                        queue.append(neighbor)\n\n            # if the topological sort includes all nodes, return the order\n            if len(topo_order) == k:\n                return topo_order\n            else:\n                return []\n\n        # get the topological order for rows and columns\n        row_order = topological_sort(rowConditions)\n        col_order = topological_sort(colConditions)\n\n        # if either topological sort fails, return an empty matrix\n        if not row_order or not col_order:\n            return []\n\n        # map each number to its position in the row and column orders\n        row_pos = {num: i for i, num in enumerate(row_order)}\n        col_pos = {num: i for i, num in enumerate(col_order)}\n\n        # initialize the k x k matrix with zeros\n        matrix = [[0] * k for _ in range(k)]\n\n        # place each number in the matrix according to its row and positions\n        for num in range(1, k+1):\n            r = row_pos[num]\n            c = col_pos[num]\n            matrix[r][c] = num\n\n        return matrix\n</code></pre>\n<h2>Complexity Analysis</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABy0lEQVR42o2TTW/UMBCG83858ycQx4ozB05wREi0CAlpxYeqCiQQbdnvwnZbymbz4SQbO3Yext5Nu6ULwtJkPOPxO+N3JpGqSwY/J1xlC3StqesaY0zQWmt2rThecn4+ZxknPDh+wr3Dh9z/uMesvCJqXYsRIA/SSdM0NKYJe+ccbdveAvR25zdW4qzccQ1O7AiJnV/MmUzHpGmCyjOSJCFTGVVVURRFqNRXrJQKyTyQtTaA/rki/xkORoxHZyzilP5wIvaQ8eUUVRYBxIN5yfN8Xb2I9/tkdwBbKbFUkj2pSTLNIjNoeWpXVcfp/65ozYf9Z1AbeNvab3G5E7A72L7oWv7qmyyh0B3oDkBP8FbeW93Ma6SLjlniGMcwFrB305bKrGPbuxXeGMMFHP6QrudwNINfwvnjI9h7a3nU07w4hv0TePYJPnyH3hSefvEJkbHZfrJweJE2vD9zvDw1UoHj4Jvj89zyZmR5/rUR2/Kqb+lNXPAd9B2vBw374ju5tNcUhLGx8qR6VWGblXS0krFYrfda9sHeiC6xZiW6COfXZ7XX5gbQD2iaZjJnBclG56ogy3JSEe/LckXsBz7oVGLUxp8Hn5E/ywP+Bk7onzv164HCAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tc\"\n        title=\"\"\n        src=\"/static/5e3b79b858d0e0e1d811dd06dfa5ea4f/5a190/tc.png\"\n        srcset=\"/static/5e3b79b858d0e0e1d811dd06dfa5ea4f/772e8/tc.png 200w,\n/static/5e3b79b858d0e0e1d811dd06dfa5ea4f/e17e5/tc.png 400w,\n/static/5e3b79b858d0e0e1d811dd06dfa5ea4f/5a190/tc.png 800w,\n/static/5e3b79b858d0e0e1d811dd06dfa5ea4f/c1b63/tc.png 1200w,\n/static/5e3b79b858d0e0e1d811dd06dfa5ea4f/86a1e/tc.png 1296w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>시간 복잡도</h3>\n<ul>\n<li>Topological Sort를 이용하여 순서를 정하고, 이를 이용하여 행렬을 만들어주면 됩니다.</li>\n<li>Topological Sort의 시간 복잡도는 O(V+E)입니다. 이때, V는 노드의 수, E는 간선의 수입니다.</li>\n<li>따라서, 전체 시간 복잡도는 O(V+E)입니다.</li>\n</ul>\n<h3>공간 복잡도</h3>\n<ul>\n<li>Topological Sort를 위한 그래프와 in-degree를 저장하기 위한 공간이 필요합니다.</li>\n<li>따라서, 전체 공간 복잡도는 O(V+E)입니다.</li>\n</ul>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n2 &#x3C;= k &#x3C;= 400\n1 &#x3C;= rowConditions.length, colConditions.length &#x3C;= 10^4\nrowConditions[i].length == colConditions[i].length == 2\n1 &#x3C;= abovei, belowi, lefti, righti &#x3C;= k\nabovei != belowi\nlefti != righti\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/build-a-matrix-with-conditions/\">2392. Build a Matrix With Conditions</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Topological_sorting\">Topological Sort</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/topological-sorting/\">GeeksforGeeks - Topological Sort</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/\">GeeksforGeeks - Kahn's Algorithm</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L2392MatrixWithConditions/"}},"staticQueryHashes":[],"slicesMap":{}}