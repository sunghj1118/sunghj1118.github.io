{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L1122RelativeSortArray/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"1122. Relative Sort Array","date":"June 11, 2024"},"html":"<h2>문제 설명</h2>\n<p>두 배열이 주어진다. arr1 배열에서 arr2 배열의 순서대로 정렬하고, 나머지는 오름차순으로 정렬하는 문제다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABEklEQVR42q2RW4+CUAyE+f9/kASWmHARlIuAchGEke9sjnF92OVhmzSnU8J0OnWCIJDruvJ9X0HwpcPhIM/z1HWdiHVdTX7WFn+GU1wuytJMyfGoMAx1Pp+VpqnGcdTeeCd2mqZVXde63W5q29a84KZp1Pf9q3+9Xk2f7Lr+hYdh+EmImizLlOe5iqLQ6XQyCo+bYuokSRRF0aY812XbpixLVVUlhFTVN6bPYIgdq4omE3lJFOIjPzCQb4/HQ8uymLR+Utu+UYhXFvxHOBwCH6ZpMi8DSFvTv9/vJsHzPP9OiEesxgEw2iaYVew6EEEO/pOQ6fjBT+8k1h/6e21x4jg2R+EIXI+DWAsgYk3UgvcQPgEjlQrLpXFM3gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1122\"\n        title=\"\"\n        src=\"/static/d3d1ee0a1f3305a18f6040b7163341e4/5a190/1122.png\"\n        srcset=\"/static/d3d1ee0a1f3305a18f6040b7163341e4/772e8/1122.png 200w,\n/static/d3d1ee0a1f3305a18f6040b7163341e4/e17e5/1122.png 400w,\n/static/d3d1ee0a1f3305a18f6040b7163341e4/5a190/1122.png 800w,\n/static/d3d1ee0a1f3305a18f6040b7163341e4/c1b63/1122.png 1200w,\n/static/d3d1ee0a1f3305a18f6040b7163341e4/aa440/1122.png 1500w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>1차 시도</h2>\n<p>분명 쉬운 난이도인데 뭔가 방법을 찾기가 어렵고 시간복잡도가 엉망이 된것 같다.\n일단은 되게 장황하게 한번 풀어봤는데 테스트케이스는 통과했다. 그런데 시간복잡도가 너무 높거나, 그냥 틀릴 것 같다.</p>\n<pre><code class=\"language-python\">from collections import Counter\n\nclass Solution:\n    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:\n        final, new_arr = [], []\n        c = Counter(arr1) # arr1에 있는 freq를 찾기\n\n        # arr2의 순서를 기준으로\n        for j in arr2:\n            for i, (k,v) in enumerate(c.items()): # counter를 dictionary로 다시 바꿔서\n                if k == j: # arr2의 순서에 부합한 item val k가 있다면\n                    for a in range(v): # 그 k의 갯수 v만큼 최종 배열에 추가\n                        final.append(k)\n\n        # 기타 나머지 값들은 다른 배열에 추가하고 정렬\n        for val in c:\n            if val not in arr2:\n                new_arr.append(val)\n        # 다시 최종 배열에 추가\n        for val in sorted(new_arr):\n            final.append(val)\n\n        return final\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAtklEQVR42qWSzRKDIBCDef+X7K0HK4KVBfnR1Ow4vQs78w23bDbBvMIbU3JIaUeMEaUUjIxJKeE4DjjvMc8Wo2Py7ai1hlorzvMcwtCVcx7erxCJenoPMSY1ZChGlsWp4L7nLihaa4OZpg+sdfemfG3auxBJV6GXwxCCtssMWQ7fXjRDnisi2LYNbJw59FHUkAqu6/cvWEpT60/J+RZku8yPwfJTD59srQVhyyGI2qfwU3LOKvoDa/xe7pZk6q4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"test\"\n        title=\"\"\n        src=\"/static/6b5c7f9a3251735513631e4c69e51f4c/5a190/testcase.png\"\n        srcset=\"/static/6b5c7f9a3251735513631e4c69e51f4c/772e8/testcase.png 200w,\n/static/6b5c7f9a3251735513631e4c69e51f4c/e17e5/testcase.png 400w,\n/static/6b5c7f9a3251735513631e4c69e51f4c/5a190/testcase.png 800w,\n/static/6b5c7f9a3251735513631e4c69e51f4c/c1b63/testcase.png 1200w,\n/static/6b5c7f9a3251735513631e4c69e51f4c/0f586/testcase.png 1498w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>\n<p>arr1에 있는 freq를 찾기</p>\n</li>\n<li>\n<p>arr2의 순서를 기준으로</p>\n</li>\n<li>\n<p>counter를 dictionary로 다시 바꿔서</p>\n</li>\n<li>\n<p>arr2의 순서에 부합한 item val k가 있다면</p>\n</li>\n<li>\n<p>그 k의 갯수 v만큼 최종 배열에 추가</p>\n</li>\n<li>\n<p>기타 나머지 값들은 다른 배열에 추가하고 정렬</p>\n</li>\n<li>\n<p>다시 최종 배열에 추가</p>\n</li>\n</ul>\n<h3>시간복잡도</h3>\n<p><code>O(m×n^2)</code> ; m은 arr2의 길이, n은 arr1의 길이</p>\n<h3>틀린 이유</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABIklEQVR42n2SjZLCIAyEff/XVMfzt5RCWyiwlw1Se+doZ74JpLCEDTvkDByPKIcDyn6PYi0WycUYlZQSPn3WOpxOP+h7u+Z2pRQE7yG7gRAgCpAUmK+8CzEXQsQ0TSLWwzm3FQR6O8AIVn5YicNA3ApzDVbj/YhxnJ6MIjy/BGvpA263O+73xxofj07HjJxfrzedn88XPYQVNmJc/gpyQdeZtaJ5DkoIjFHhxpqrkVU1OP8nOIhgp35YaQobkVLWmHPWcY0Jy7K8sW2cCBY11TmvJhP64qVRjfq/0jq/hYe9XZke8drG9Gp8GzOyekb6ySvSs68eslvzPOtJK6WSyuu6+fk+v71NFaSYMUY9pJ+8mvXydEaH3lvNNX+5jus/Cf4CGe0MsI6ZU6QAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"wr\"\n        title=\"\"\n        src=\"/static/cc339f38f968eea9d269ca2bd694f3b8/5a190/wrong.png\"\n        srcset=\"/static/cc339f38f968eea9d269ca2bd694f3b8/772e8/wrong.png 200w,\n/static/cc339f38f968eea9d269ca2bd694f3b8/e17e5/wrong.png 400w,\n/static/cc339f38f968eea9d269ca2bd694f3b8/5a190/wrong.png 800w,\n/static/cc339f38f968eea9d269ca2bd694f3b8/c1b63/wrong.png 1200w,\n/static/cc339f38f968eea9d269ca2bd694f3b8/e4ee8/wrong.png 1496w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<pre><code>arr1 = [2,21,43,38,0,42,33,7,24,13,12,27,12,24,5,23,29,48,30,31]  \narr2 = [2,42,38,0,43,21]\n\noutput = [2,42,38,0,43,21,5,7,12,13,23,24,27,29,30,31,33,48]  \nexpected = [2,42,38,0,43,21,5,7,12,12,13,23,24,24,27,29,30,31,33,48]\n</code></pre>\n<p>보면 24와 12가 하나씩 누락됐다. 왜 그럴까?</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 49%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABOklEQVR42oWS3W6DMAyFef+n282uVqimqQVBYeQPkjjhLE4bVK3danRkESVfTmxXWmtobeA9ZTnnn8p7n/ZZaGVANu0lwrZtiDEiphxCAKW1ahwnsISQWQxflnWXMUvOvFkvAf1wwXgZMCsJuSpY525mfIZX53OLum5wOp0zjAFF90CXDvjkQgiBSU6gSKBACDEkhzGLHWdg0xzB2VqHdbUPskkMdBSwJYCRAn3foptaDGpApzoYb/IFVdt2OByaDHwGK3LeQSyEul/wfhIY5QxL6+6uRAbyk18CU63ESvi6SLx9fOJ7lhmwpe8+bsA615CfXJrx6DDVMD3Z6hXzNKS1Bc+iUkrv3S1AbsTvseGxuFnKxf8rqtLFArrKZAhR2BVCvDv2D1ApBXbJkOuQ6/zPNePZK9odvogfuJ8JoSYaZGwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"fix\"\n        title=\"\"\n        src=\"/static/719aeb43fecdeb40694cb7d727524237/5a190/fix.png\"\n        srcset=\"/static/719aeb43fecdeb40694cb7d727524237/772e8/fix.png 200w,\n/static/719aeb43fecdeb40694cb7d727524237/e17e5/fix.png 400w,\n/static/719aeb43fecdeb40694cb7d727524237/5a190/fix.png 800w,\n/static/719aeb43fecdeb40694cb7d727524237/c1b63/fix.png 1200w,\n/static/719aeb43fecdeb40694cb7d727524237/29007/fix.png 1600w,\n/static/719aeb43fecdeb40694cb7d727524237/efe17/fix.png 2860w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>보니까 해당하지 않는 값들에 대하여 한번씩만 들어가고 있었다. 이를 수정하니, 테스트 케이스는 통과하긴 했는데, 아무래도 아직도 시간복잡도는 상당히 높다.</p>\n<h3>제출시도:</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABGElEQVR42nVQy27DMAzz/3/S/mCXnXcaUKAo2rRpktqy4ycrunNPGwHCikPRlMzsFqSUkHNGrRVEbRVRIr6u3/g4ffa7FCu2NcA9BMEFJNW31nrPYFOduU4TlmWBiMB7j33fEWN8idWYZB1LUU3A+XzEfZ3xEAcbnIbJ3ZyhquqMcw4kzXhZtHGkpRHBc9fGnIs+vmG1qz7q4byDRIEkTV0Ccs0wo2mAhkz4Hp+nakJMvc4x6+gbTtcjbu6G2c9Y/B2llf6woYgmw4hJOX4IoY/PWh3h99gnuC8zLvME621P9EZ7TWIo6ntT8qQhSUOS/wlRQ458uUz4ORzgxeMvGOsE1uoe/SvR2OEgv/G7w1oa7GYhurv/8ASaxCMQ6YVWpwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"t1\"\n        title=\"\"\n        src=\"/static/eb2bd5e01f8abdcb67154488efb28085/5a190/t1.png\"\n        srcset=\"/static/eb2bd5e01f8abdcb67154488efb28085/772e8/t1.png 200w,\n/static/eb2bd5e01f8abdcb67154488efb28085/e17e5/t1.png 400w,\n/static/eb2bd5e01f8abdcb67154488efb28085/5a190/t1.png 800w,\n/static/eb2bd5e01f8abdcb67154488efb28085/c1b63/t1.png 1200w,\n/static/eb2bd5e01f8abdcb67154488efb28085/29007/t1.png 1600w,\n/static/eb2bd5e01f8abdcb67154488efb28085/7e23a/t1.png 2850w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>놀랍게도 통과했다. 시간복잡도가 너무 높아서 더 깎아보겠다.</p>\n<h2>2차 시도</h2>\n<p>일단 Nested for loop이 가장 문제다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA5ElEQVR42oWQ22rDQAwF/f9/WDcvCaS2Exzf1rvemyZau6WhBCoYBAKNxKnk8UDuN5hGZYJh+GVZwBhwGxI8zkXGweCMZbOelDI5572nlIgxUtE0SP2BnE7I5QJtQ5ntdN1BOboafBSGaaHvO4w1jHbGuFVFiaCyQ3i9wmeNFFTM5Yy07S5hHA+KUL/1+on3nvbeM+oBFx0pR16rys4h1h6sK1mJuiw65wVRkfUBBL5uE/X5RgiBv1VN88yqMrdtWKV0pwKrBM3lh6gkzSsnUbJ6hXdVrRp6ufQfJR+RQyLfvBM+AUGz026ccwlDAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"new\"\n        title=\"\"\n        src=\"/static/41db5e9a5bce10e132c97230784cb285/5a190/new.png\"\n        srcset=\"/static/41db5e9a5bce10e132c97230784cb285/772e8/new.png 200w,\n/static/41db5e9a5bce10e132c97230784cb285/e17e5/new.png 400w,\n/static/41db5e9a5bce10e132c97230784cb285/5a190/new.png 800w,\n/static/41db5e9a5bce10e132c97230784cb285/c1b63/new.png 1200w,\n/static/41db5e9a5bce10e132c97230784cb285/29007/new.png 1600w,\n/static/41db5e9a5bce10e132c97230784cb285/38abd/new.png 2766w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\npop을 하니까 이게 결국에 freq를 반환한다. 그래서 [new]*freq를 하면, freq만큼 new가 반복된다. 이렇게 하면 번거롭게 for loop을 다시 안 돌려도 된다.</p>\n<p>이미 있는 값들은 다 pop 당했으니 remaining = sorted(c.elements())을 하면, 기존에 남았던 값들만 정렬해서 반환한다.</p>\n<p>여기서 마지막으로 final.extend(remaining)을 하면, 기존에 정렬된 값들과 남은 값들을 합쳐서 반환한다.</p>\n<p>이렇게 하면 다음과 같이 조금은 빨라진다.<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABL0lEQVR42o2TyU6EQBCG5/3jO3jzCfQFPHgz8YJBDh4MDEvS7HtD//LXpAmgk5kmlaqmuj9q44RlJU2Kc5lATxrzPO/kuOq6RRwnyIoCj9/PePh8wkvwJj6zPCcaZV1BZQpd14n0fS96GAYYY3bAUY+XM4vvXbl4jT/wVfysfgHyQHgOkWWZQAi00LZtobUWPY4jbi0BEuQ4DqIoEjtNUyilUFXVkmItIL7nnmWYpklkNkbS3GYhQF7g4aZpJBIrjJa+Y12v1XcF3rsIYfo3U7ZfZOjXhP4wDJEkyaWjh2bdFSEvbRviui48z1traKF/anisjQWx07aeBPi+jyAIBM4JoOa5HdButqPyn2a37RhZzabR3tZ1TdlGwotbXZal2HmeyyQUyx/CPW3CaG+Bv0hrW85ddyshAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"t2\"\n        title=\"\"\n        src=\"/static/269079954f684b13a5c26d80c2359fc2/5a190/t2.png\"\n        srcset=\"/static/269079954f684b13a5c26d80c2359fc2/772e8/t2.png 200w,\n/static/269079954f684b13a5c26d80c2359fc2/e17e5/t2.png 400w,\n/static/269079954f684b13a5c26d80c2359fc2/5a190/t2.png 800w,\n/static/269079954f684b13a5c26d80c2359fc2/c1b63/t2.png 1200w,\n/static/269079954f684b13a5c26d80c2359fc2/b1ffc/t2.png 1492w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">from collections import Counter\n\nclass Solution:\n    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:\n        final = []\n        c = Counter(arr1) # arr1에 있는 freq를 찾기\n        print(c)\n\n        # add elements from arr2 in the order\n        for num in arr2:\n            if num in c:\n                t = c.pop(num)\n                final.extend([num] * t)\n\n        remaining = sorted(c.elements())\n        final.extend(remaining)\n\n        return final\n</code></pre>\n<h2>Complexity Analysis</h2>\n<h3>Time Complexity</h3>\n<ul>\n<li>Counter: O(N) ; N은 arr1 배열의 길이</li>\n<li>For loop: O(M) ; M은 arr2 배열의 길이</li>\n<li>Sorting remaining elements: O(KlogK) ; K는 arr1에서 arr2에 없는 요소의 수 (최대 N)</li>\n</ul>\n<p>최종적으로 O(NlogN+M)이다.</p>\n<h3>Space Complexity</h3>\n<p>O(N) ; N은 nums 배열의 길이</p>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n\n1 &#x3C;= arr1.length, arr2.length &#x3C;= 1000  \n0 &#x3C;= arr1[i], arr2[i] &#x3C;= 1000  \nAll the elements of arr2 are distinct.  \nEach arr2[i] is in arr1.  \n</code></pre>\n<h1>Update 2024-06-13: HashMap</h1>\n<p>이것보다 더 빠른 방법이 있을것 같아서 다시 한번 풀어보았다. HashMap을 사용하면 아마 빨라질것 같아서 한번 사용해보았다.</p>\n<pre><code class=\"language-python\">class Solution:\n    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:\n        final = []\n        remaining = []\n        count_map = {}\n\n        # initialize count map with relative order elements\n        for value in arr2:\n            count_map[value] = 0\n\n        # count occurrences of elements in target array\n        for value in arr1:\n            if value in count_map:\n                count_map[value] += 1\n            else:\n                remaining.append(value)\n        \n        #sort remaining\n        remaining.sort()\n\n        # add elements following relative order\n        for value in arr2:\n            for _ in range(count_map[value]):\n                final.append(value)\n        \n        # add remaining elements\n        final.extend(remaining)\n        return final\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.49999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABN0lEQVR42oWSzU7DMBCE+/53noArdySucOIE1wghQGqSqg1N7fgnjtOh43Zbp0Gw0cSOvf48XmeBQwxjxFKvsLUK4zhOtN/vkccwRKw3DfRW47F+wU1xh9v3e6hg0vyCLy5cbzdo9Q7OOjjn4L2HtfYAGCZA5prDePABxe4LD+Uznlav8LG/ABmqVajKCtbYBMuhfd8jhJD6146v4wz8WH6ieCtQtTWa7wZNc5RS6gzmN+ExxqRUktMzA3bewHoHG47ORHTGxXSW1/W3+k6ATPgruJhg1lTqyjHRDBjHOEnIxc0I67ruLDr/12G+m7TGGNR1nS6J9SRMa53EseujXxyeCi1Hk8S2bVGWZTqm3Hz+F1B5uSYOeZNMpCtpZTHn6EocspVx3vwMSDcCyFsB5yDpE8a5HPgD8yRcM1V8fskAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"hash\"\n        title=\"\"\n        src=\"/static/4fdebdf231b68e72c92c075533a18ed9/5a190/hash.png\"\n        srcset=\"/static/4fdebdf231b68e72c92c075533a18ed9/772e8/hash.png 200w,\n/static/4fdebdf231b68e72c92c075533a18ed9/e17e5/hash.png 400w,\n/static/4fdebdf231b68e72c92c075533a18ed9/5a190/hash.png 800w,\n/static/4fdebdf231b68e72c92c075533a18ed9/c1b63/hash.png 1200w,\n/static/4fdebdf231b68e72c92c075533a18ed9/aa440/hash.png 1500w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>훨씬 빨라졌으며, 시간복잡도가 더 빠른지 분석을 해보자.</p>\n<h3>Time Complexity</h3>\n<ul>\n<li>Initializing count map with elements from arr2: O(M) ; M은 arr2 배열의 길이</li>\n<li>Counting occurrences of elements in arr1: O(N) ; N은 arr1 배열의 길이</li>\n<li>Sorting remaining elements: O(RlogR) ; R은 arr1에서 arr2에 없는 요소의 수 (최대 N)</li>\n<li>Adding elements following relative order: O(N) ; N은 arr1 배열의 길이</li>\n</ul>\n<p>최종적으로 O(NlogN+M)이다.</p>\n<h3>Space Complexity</h3>\n<ul>\n<li>Count map: O(M) ; M은 arr2 배열의 길이</li>\n<li>Remaining list: O(R) ; R은 arr1에서 arr2에 없는 요소의 수</li>\n<li>Final list: O(N) ; N은 arr1 배열의 길이</li>\n</ul>\n<p>최종적으로 O(N)이다.</p>\n<h2>분석</h2>\n<p>두개의 풀이가 시간복잡도가 같은데, 어째서 두번째 풀이가 더 빠르게 나왔을까? 각 단계에서 실행시간이 더 빠르기 때문이다. 하나씩 비교해보자.</p>\n<h3>Counter: O(N) vs HashMap: O(M)</h3>\n<ul>\n<li>첫 번째 구현에서 Counter는 arr1 전체를 한 번 훑어야 하며, 이는 O(N).</li>\n<li>두 번째 구현에서 count_map 초기화는 arr2에 대해 수행되며, 이는 O(M). 그 후, arr1을 한 번 훑어서 카운트를 증가시키는 것도 O(N). 따라서 이 단계에서는 큰 차이가 없다.</li>\n</ul>\n<h3>요소 추가 및 정렬</h3>\n<ul>\n<li>첫 번째 구현에서는 Counter에서 요소를 하나씩 꺼내면서 final에 추가하고, 남은 요소들을 정렬합니다.</li>\n<li>두 번째 구현에서는 count_map에서 카운트를 참조하여 final에 요소를 추가합니다. 남은 요소들은 별도의 리스트에 추가하고 마지막에 한 번만 정렬합니다. 여기서, 두 번째 구현이 Counter의 요소를 한 번씩 꺼내는 것보다 더 효율적입니다.</li>\n</ul>\n<h3>나머지 요소 처리</h3>\n<ul>\n<li>첫 번째 구현에서는 남은 요소들을 sorted로 정렬합니다.</li>\n<li>두 번째 구현에서도 남은 요소들을 정렬하지만, 이미 arr1에서 arr2에 없는 요소들만 따로 모아서 정렬합니다.</li>\n</ul>\n<h2>결론</h2>\n<p>두 번째 구현이 더 빠른 이유는 Counter의 요소를 하나씩 꺼내고 확장하는 과정이 첫 번째 구현보다 덜 비효율적이기 때문이다. Counter의 요소를 한 번씩 꺼내는 것보다는 Hash Map에서 카운트를 참조하여 직접 리스트에 추가하는 것이 상수 시간 복잡도에서 더 효율적이다. 또한, 남은 요소들을 별도로 정렬하고 추가하는 과정이 더 단순화되어 있다.</p>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/relative-sort-array\">LeetCode</a></li>\n<li><a href=\"https://docs.python.org/3/library/collections.html#collections.Counter\">Python - Counter</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L1122RelativeSortArray/"}},"staticQueryHashes":[],"slicesMap":{}}