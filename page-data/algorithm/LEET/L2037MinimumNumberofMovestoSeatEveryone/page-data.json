{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LEET/L2037MinimumNumberofMovestoSeatEveryone/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"2037. Minimum Number of Moves to Seat Everyone","date":"June 13, 2024"},"html":"<h2>문제 설명</h2>\n<p>설명이 조금 헷갈리는 문제다.</p>\n<p>핵심만 말하자면, 의자 자리 배열이 주어지고, 사람의 초기 위치 배열이 주어진다.</p>\n<p>사람이 앉을 때, 겹쳐서 앉으면 불편하기 때문에, 사람들이 모두 서로 다른 의자에 앉기 위해 필요한 최소 이동 횟수를 구하는 문제다.</p>\n<p>즉, 의자 배열이 [3,1,5]가  주어지면 1번 3번 5번 자리에 의자가 있다는 뜻이다. 또한, 사람의 초기 위치 배열이 [2,7,4]가 주어지면, 2번 7번 4번 자리에 사람이 있다는 뜻이다.</p>\n<p>그렇다면, 최소 거리를 찾으려면 아마 가장 가까운 의자들에 앉혀야 할 것이다. 그러나, 그리디하게 가장 가까운 위치 앉히다가, 갑자기 마지막 사람이 가장 먼 위치에 앉아야 하는 경우가 생길 수 있다. 이런 경우를 대비해서 정렬을 한번 거쳐야 할수도 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABY0lEQVR42q2S53KDQAyEef9HtBlsirHpuIGpCp8SZSCJ/+VmdnQ6LYuaE8WxRFEk+70rnufJ8XiU3W4nQRAofN+XeOEQg3c4HCTLMnl3nPr5lLKuJV9IEM/ns5RlqRiGQfq+VzuOo6LrOvW7rlf/897J6/XSu1MWpVwuFxU6nU6aDUA8TVMJw1DjvOHDi7Uq3pPlLVPO7XZTUefxeEhVVXK9XjUru2PrJXMsWXKmaZJ5nv/Ed8nPpWQTMQHs/X7Xv+I3TaM+HPjEiWGJkVnTtCqsGUKCwEf4WIiGtm03d/gALrA3eurQH/6U57ki+xqOZWqtsLtVYz9AaCPIo2WJLYpCs8W3jK0FvCFG/O3a0HDG/l/HSZJE1wBh2yvbLfPXU+T89LeLvZTjuq6WauUDylo3/d3K/BIkE5aVTAHCNhgbFIOjd8SADYo7K7MRpCTbK4g0n0lCxgKGwYfrjG2QfL8W/ABEXOslrloI7QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2037\"\n        title=\"\"\n        src=\"/static/4671a359e8a484023e23dc408f46c976/5a190/2037.png\"\n        srcset=\"/static/4671a359e8a484023e23dc408f46c976/772e8/2037.png 200w,\n/static/4671a359e8a484023e23dc408f46c976/e17e5/2037.png 400w,\n/static/4671a359e8a484023e23dc408f46c976/5a190/2037.png 800w,\n/static/4671a359e8a484023e23dc408f46c976/c1b63/2037.png 1200w,\n/static/4671a359e8a484023e23dc408f46c976/0f586/2037.png 1498w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>풀이 및 해설</h2>\n<p>엄청 러프하게 풀어봤을때는, 두 배열 모두 정렬을 한 후, 각 위치의 차이를 구하고, 그 차이의 합을 구해봤다. 사실 이 풀이에는 단점이 많지만, 두 배열의 길이가 같다는 조건이 있기 때문에 가능한 풀이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA1ElEQVR42pVQS27EIBTj/lfqDXqAbqtsMs0oEwUI3wdxMdKTqi4q1ZJJ9DC2wbjk4YJHkwYRgaJWgb8uvK3v+LCfc1Zqx/5yeO1fOE+LnOuYyfgKSqmQ1mCcddi2DSEEXMMg54yUEtrY/AmKpXfEK+H5eIwz6zA90ceM2vu+p86UUuC9R4xxmrElBUoV0jAVQZfR8rljXVc4a2c4PbSAwS8wkWQ6mytaG03YpjbEkGYBBUOVhouasJ1e+TgOLMsyk3Vf2/4FQ6GakEwm+Z58V/7/x/Ab/KPVsHSp2C8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"a1\"\n        title=\"\"\n        src=\"/static/777603214170e24c31df7f48bdf8487a/5a190/a1.png\"\n        srcset=\"/static/777603214170e24c31df7f48bdf8487a/772e8/a1.png 200w,\n/static/777603214170e24c31df7f48bdf8487a/e17e5/a1.png 400w,\n/static/777603214170e24c31df7f48bdf8487a/5a190/a1.png 800w,\n/static/777603214170e24c31df7f48bdf8487a/c1b63/a1.png 1200w,\n/static/777603214170e24c31df7f48bdf8487a/29007/a1.png 1600w,\n/static/777603214170e24c31df7f48bdf8487a/f726e/a1.png 2610w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<pre><code class=\"language-python\">class Solution:\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\n        seats = sorted(seats)\n        students = sorted(students)\n        total_movement = 0\n\n        for i in range(len(students)):\n            if seats[i] != students[i]:\n                total_movement += abs(students[i] - seats[i])\n        \n        return total_movement\n</code></pre>\n<h3>시간복잡도</h3>\n<p><code>O(nlogn)</code> ; 정렬을 사용했기 때문에</p>\n<h3>공간복잡도</h3>\n<p><code>O(1)</code> ; 추가적인 공간을 사용하지 않았기 때문에</p>\n<h2>Constraint Analysis</h2>\n<pre><code>Constraints:\n\nn == seats.length == students.length\n1 &#x3C;= n &#x3C;= 100\n1 &#x3C;= seats[i], students[j] &#x3C;= 100\n</code></pre>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone\">LeetCode</a></li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LEET/L2037MinimumNumberofMovestoSeatEveryone/"}},"staticQueryHashes":[],"slicesMap":{}}