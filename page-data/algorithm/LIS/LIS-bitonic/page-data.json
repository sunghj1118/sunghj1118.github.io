{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/LIS/LIS-bitonic/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"[DP][LIS] Longest Bitonic Subsequence","date":"May 17, 2024"},"html":"<h2>Longest Bitonic Subsequence는 LIS를 활용한 DP문제로, 주어진 배열에서 가장 긴 바이토닉 수열을 찾는 문제다.</h2>\n<p>이를 활용한 백준 11504 문제를 살펴보자.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 69%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAABTUlEQVR42qVTCW7EIAzk/x+t1CwQrhBCwPXQOJse26pbSyOHw/aMcZS1E2k90XQzZIxlrymvKz1jtVZSPU/UN0/92ITvvdOzppYl07ZtYxFjHICtzFL2932nnPMZhDullPEN772/JyxlHQEwBJVDLi5eE6KAMMc9yBOZy7LcE/q4/EviF8mO6YLy7Bw5BqqnlAbAapzN8zgDQghjjbPKzMEQSuChRCHAGEPW2gFctsaMPSTAntZ6fEti9BAJBZAMoE3MMJz9kmoCWeMc3/BA+6FFKnAPIVMCr5WlUEHyQ574zyYllLHzmRBAIqxlbMbewUy8vP73DLn5GB1hJ7IA6cufXlnz7/byqinygF+TAcIc5vkhbsZRqe2XsQmJfOKebTu11vnp2wlZt9YopkzW8ziteKz9IZRzPIcukJsxj4FZQfr2AaXU98QH9voYb2Y+S2dXGPXHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"11504\"\n        title=\"\"\n        src=\"/static/e71cba9b032175d470d889e72aef1ea1/5a190/11504.png\"\n        srcset=\"/static/e71cba9b032175d470d889e72aef1ea1/772e8/11504.png 200w,\n/static/e71cba9b032175d470d889e72aef1ea1/e17e5/11504.png 400w,\n/static/e71cba9b032175d470d889e72aef1ea1/5a190/11504.png 800w,\n/static/e71cba9b032175d470d889e72aef1ea1/c1b63/11504.png 1200w,\n/static/e71cba9b032175d470d889e72aef1ea1/29007/11504.png 1600w,\n/static/e71cba9b032175d470d889e72aef1ea1/70c12/11504.png 2110w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>수열 S가 어떤 수 Sk를 기준으로 S1 &#x3C; S2 &#x3C; ... Sk-1 &#x3C; Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.</p>\n<p><strong>쉽게 말해, 커졌다 작아지면 바이토닉 수열이다.</strong></p>\n<p>예제의 경우 {1 5 2 1 4 3 4 5 2 1} 수열에서 가장 긴 바이토닉 부분 수열을 찾아야 하는데, 이때 {<strong>1</strong> 5 <strong>2</strong> 1 4 <strong>3 4 5 2 1</strong>} 가장 긴 바이토닉 부분 수열이다.</p>\n<p>해당하지 않는 숫자들을 없애면 {1 2 3 4 5 2 1}이 된다.</p>\n<hr>\n<h3>첫인상</h3>\n<p>이 문제를 풀 때는 LIS 문제와 비슷한 방식으로 풀면 될 것 같다. 그러나, 가장 큰 숫자를 기준으로 나눠야 할지 고민이 되긴 한다.</p>\n<p>따라서, 이 문제는 <strong>DP</strong>로 풀어야 한다.</p>\n<p>일단은 앞뒤로 LIS를 하나씩 해봤다:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAl0lEQVR42o2Q4Q6DIAyEfRcFBEpbiG77s+39n+pmzVxMlqg/vhw05ei1izHh9XxDtWIYHEIY4X1Y2Z8N5/wp3ThGTDxDiiATIWcCUflCPy2F1w9ODa2plQZhhZnbxBvb3TSlfM3QuwBKy2SF0PfDWrTom+65FNl2w8TQppcfHRoSC27tgXm6Q2qF6D9aG1gUcYmdlh0f8QGRPLCOq04rlgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2lists\"\n        title=\"\"\n        src=\"/static/b241eefa14ae4c604a1ffa474cbbf3f2/5a190/twolists.png\"\n        srcset=\"/static/b241eefa14ae4c604a1ffa474cbbf3f2/772e8/twolists.png 200w,\n/static/b241eefa14ae4c604a1ffa474cbbf3f2/e17e5/twolists.png 400w,\n/static/b241eefa14ae4c604a1ffa474cbbf3f2/5a190/twolists.png 800w,\n/static/b241eefa14ae4c604a1ffa474cbbf3f2/d6a46/twolists.png 1008w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA9ElEQVR42nWQWY7EIAxEc5AAXlhDgCyk06O+/73Gyd9o0qgEtqyinjyAC7Xv+zG/fjYf0TdrM7uZfbGcSGoDRn85AwLYOIfAKTsfiTxSQIrEUjuU1qDR6qsZHXLyGUvlXn10WimRUuM1N9qAvsLNoxlRHvl/Lq2dS9vK1pcwpWktcbIUkW8cIPiff5kJmIi0t5wTJzeV6qxnGwhBIPTFoR/JBwBgFFcObYFzcUebSiYWGCW0wCCZose1DTkCoBlHFVJt515r7u8ec4lLy7W4SLIStGgA1GiU+qOhNfyc8Tzc+xOPF++7vm/qnXunbdXrcmt90C/E2EOlFhQbTwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2listimplementation\"\n        title=\"\"\n        src=\"/static/a2479c107f4191719d120068fbb32e0a/5a190/image.png\"\n        srcset=\"/static/a2479c107f4191719d120068fbb32e0a/772e8/image.png 200w,\n/static/a2479c107f4191719d120068fbb32e0a/e17e5/image.png 400w,\n/static/a2479c107f4191719d120068fbb32e0a/5a190/image.png 800w,\n/static/a2479c107f4191719d120068fbb32e0a/c1b63/image.png 1200w,\n/static/a2479c107f4191719d120068fbb32e0a/6c2de/image.png 1334w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>그런데 지금 보니까 굳이 두개를 할 필요가 있나? 그냥 가장 큰 숫자를 기준으로 그 다음에 얼마나 많은 작은 숫자들이 있는지 파악해도 되지 않나? 그런데 그걸 구현할 방법이 생각이 안나서 일단은 두개로 나눠서 풀어보자.</p>\n<hr>\n<p>보니까 두개의 배열의 인덱스 값에 대해서 합이 가장 큰 경우가 가장 긴 바이토닉 수열이다. 그래서 두개의 배열을 만들어서 각각 LIS를 구하고, 그 두개의 합이 가장 큰 경우를 찾으면 될 것 같다.</p>\n<h2>Solution</h2>\n<p>이 문제를 풀기 위해서 LIS를 앞뒤로 두개 사용했다.</p>\n<ol>\n<li>n+1만큼의 dp 수열을 두개 만든다.</li>\n<li>앞으로 LIS를 구하는 dp를 구현한다.</li>\n</ol>\n<p>2-1. 첫번째 for loop은 현재 원소를 기준으로 이전 원소들을 비교한다.<br>\n2-2. 두번째 for loop은 이전 원소들을 비교한다.<br>\n2-3. 현재 원소가 이전 원소보다 크다면, dp[i] = max(dp[i], dp[j]+1)을 통해 dp[i]를 갱신한다. 즉, 이전의 원소들보다 더 크면 dp[i]를 갱신한다.\n3. 뒤로 LIS를 구하는 dp를 구현한다.<br>\n3-1. 첫번째 for loop은 reversed(range(n))로 반대로 순회한다.<br>\n3-2. 두번째 for loop에서는 range(i, n)를 하여 i부터 마지막 값까지 비교한다.<br>\n3-3. 현재 값이 이후 값보다 크다면, dp2[i] = max(dp2[i], dp2[j]+1)을 통해 dp2[i]를 갱신한다. 즉, 이후의 원소들보다 더 크면 dp2[i]를 갱신한다.\n4. dp와 dp2들의 각각 원소들을 더한다.\n5. 이 중 가장 큰 값을 반환한다.</p>\n<pre><code class=\"language-python\"># LIS: Longest Bitonic Subsequence\n\ndef LIS(n, seq):\n    dp = [1]*(n+1) # 원소들마다 순서를 기록하는 dp 리스트\n    dp2 = [1]*(n+1) # 원소들마다 역순서를 기록하는 dp 리스트\n\n    # 순서대로 LIS\n    for i in range(n):\n        for j in range(i):\n            if seq[i] > seq[j]: # 현재 원소가 이전 원소들보다 크다면\n                dp[i] = max(dp[i], dp[j]+1)\n    \n    # 역순 LIS\n    for i in reversed(range(n)):\n        for j in range(i, n):\n            if seq[i] > seq[j]: # 현재 원소가 이전 원소들보다 크다면\n                dp2[i] = max(dp2[i], dp2[j]+1)\n    \n    # 각각의 LIS dp 배열들을 합치기\n    sum_dp = [1]*(n+1)\n    for i in range(len(dp)):\n        sum_dp[i] = dp[i] + dp2[i] -1\n    \n    # 최장 바이토닉 수열의 길이 반환\n    return max(sum_dp)\n            \n\nn = int(input()) # 수열의 길이\nseq = list(map(int, input().split())) # 수열\nprint(LIS(n, seq))\n\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAABgElEQVR42pWTW27jMBRDu4+xrPfTUWQ7yQQYoPtfFkspKdD+TJyPCytAfExeUh/aGliv4aKFjQ7aKhinYYPBPM+YJgHB6ecj86G1QTo1bHvF5doQkoXLdgB94Tnyg0FDKnkMaLSmooBYApbFwhPkkhkgnx9AQwdKEyiOAK2FMQalFIS6cDKUlLQ5jZl+2JXyANA5xz9KGGmosGH/d8V+21DbglwLUonDct9xV/oKOoCath2tat8DcvApIMQEa/xQfzSQX8AlFyxtRb7vON125BwYBO2qGcrIkb7S6jXQcof9IP5M8D7jvDc02t2uG0qtqNtKtY9gtCPwlWXvactZxFPmi1TaItM1Y69imsdzfLAnLB6//zfDsmdtztsd698N988btrWxPn1/+pmuPDzPlGeqig+V2SMtDIU7/Aa+FcrooaLVlLDUhHyuo8RCPDso3gT6ENiziHLOyCXD8z4Pdbzj2jxvyDvAECP3V7HyHp/2y6hLYA/7DnsDemVmeRz4BXOqhd500xuHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"solution\"\n        title=\"\"\n        src=\"/static/72e03420be7db1e421182ede6715701c/5a190/solution.png\"\n        srcset=\"/static/72e03420be7db1e421182ede6715701c/772e8/solution.png 200w,\n/static/72e03420be7db1e421182ede6715701c/e17e5/solution.png 400w,\n/static/72e03420be7db1e421182ede6715701c/5a190/solution.png 800w,\n/static/72e03420be7db1e421182ede6715701c/c1b63/solution.png 1200w,\n/static/72e03420be7db1e421182ede6715701c/acf8f/solution.png 1340w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 8.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAa0lEQVR42i2OQRLDMAgD8/9/9pjWSQEDJlZlT5nRARYJDlHDnBOZAVXBGIUmXzyczb9WiQhMFeGOjEBQ2n2z5dPF2R9iHVXFRcV1vWGeeLUTSmMxPMfYfAXe7bNDnQHmgfPmAXLhA51czPEDb9ab0nbM+6UAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"bj\"\n        title=\"\"\n        src=\"/static/b54518654f47e7f92147b4644dd59e5b/5a190/baek.png\"\n        srcset=\"/static/b54518654f47e7f92147b4644dd59e5b/772e8/baek.png 200w,\n/static/b54518654f47e7f92147b4644dd59e5b/e17e5/baek.png 400w,\n/static/b54518654f47e7f92147b4644dd59e5b/5a190/baek.png 800w,\n/static/b54518654f47e7f92147b4644dd59e5b/c1b63/baek.png 1200w,\n/static/b54518654f47e7f92147b4644dd59e5b/29007/baek.png 1600w,\n/static/b54518654f47e7f92147b4644dd59e5b/cdf95/baek.png 2106w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>Topics</h2>\n<ul>\n<li>DP</li>\n<li>LIS</li>\n</ul>"}},"pageContext":{"slug":"/algorithm/LIS/LIS-bitonic/"}},"staticQueryHashes":[],"slicesMap":{}}